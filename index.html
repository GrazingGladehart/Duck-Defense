<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duck Defense 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            overflow: hidden;
            background: #87CEEB;
            cursor: crosshair;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 10;
        }

        #weapon-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.6);
            padding: 15px 25px;
            border-radius: 10px;
            color: white;
            font-size: 20px;
            text-shadow: 1px 1px 2px black;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 5;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 3px black;
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 40px;
            border-radius: 20px;
            color: white;
            text-align: center;
            display: none;
            z-index: 20;
        }

        #game-over h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff4444;
        }

        #game-over button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
        }

        #game-over button:hover {
            background: #45a049;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 40px;
            border-radius: 20px;
            color: white;
            text-align: center;
            z-index: 20;
        }

        #instructions h2 {
            margin-bottom: 20px;
            color: #FFD700;
        }

        #instructions ul {
            text-align: left;
            margin: 20px 0;
            list-style-position: inside;
        }

        #instructions li {
            margin: 10px 0;
        }

        #instructions button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
        }

        #quit-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 30px;
            font-size: 18px;
            background: rgba(220, 20, 60, 0.8);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            pointer-events: auto;
            z-index: 15;
            display: none;
        }

        #quit-btn:hover {
            background: rgba(180, 20, 60, 0.9);
        }

        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            display: none;
            z-index: 10;
            pointer-events: none;
        }

        #joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.15);
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.3);
            pointer-events: auto;
            touch-action: none;
        }

        #joystick-thumb {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .mobile-action-btns {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }

        .mobile-btn {
            width: 70px;
            height: 70px;
            background: rgba(255,255,255,0.25);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
            user-select: none;
            border: 2px solid rgba(255,255,255,0.4);
            touch-action: none;
        }

        .mobile-btn:active {
            background: rgba(255,255,255,0.5);
            transform: scale(0.95);
        }

        #mobile-jump {
            background: rgba(100, 200, 255, 0.3);
            border-color: rgba(100, 200, 255, 0.5);
        }

        #mobile-attack {
            background: rgba(255, 100, 100, 0.3);
            border-color: rgba(255, 100, 100, 0.5);
            width: 80px;
            height: 80px;
            font-size: 12px;
        }

        /* Main Menu Styles */
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a3a2a 0%, #0d1f15 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .menu-title {
            font-size: 64px;
            color: #FFD700;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.8);
            margin-bottom: 10px;
        }

        .menu-subtitle {
            font-size: 20px;
            color: #8FBC8F;
            margin-bottom: 40px;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .menu-btn {
            padding: 18px 60px;
            font-size: 22px;
            background: linear-gradient(180deg, #4CAF50 0%, #2E7D32 100%);
            color: white;
            border: 3px solid #66BB6A;
            border-radius: 12px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
            min-width: 280px;
        }

        .menu-btn:hover {
            background: linear-gradient(180deg, #66BB6A 0%, #388E3C 100%);
            transform: scale(1.05);
        }

        .menu-btn.secondary {
            background: linear-gradient(180deg, #455A64 0%, #263238 100%);
            border-color: #607D8B;
        }

        .menu-btn.secondary:hover {
            background: linear-gradient(180deg, #607D8B 0%, #37474F 100%);
        }

        /* Settings Page */
        #settings-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a3a2a 0%, #0d1f15 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .settings-panel {
            background: rgba(0,0,0,0.7);
            padding: 40px;
            border-radius: 20px;
            min-width: 400px;
        }

        .settings-panel h2 {
            color: #FFD700;
            text-align: center;
            margin-bottom: 30px;
            font-size: 36px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
        }

        .setting-label {
            font-size: 18px;
            color: white;
        }

        .setting-select {
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 8px;
            border: none;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }

        .difficulty-btns {
            display: flex;
            gap: 10px;
        }

        .diff-btn {
            padding: 10px 20px;
            border: 2px solid #666;
            background: transparent;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .diff-btn.active {
            background: #4CAF50;
            border-color: #66BB6A;
        }

        .diff-btn:hover {
            border-color: #4CAF50;
        }

        .input-btns {
            display: flex;
            gap: 10px;
        }

        .input-btn {
            padding: 10px 20px;
            border: 2px solid #666;
            background: transparent;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .input-btn.active {
            background: #2196F3;
            border-color: #42A5F5;
        }

        .input-btn:hover {
            border-color: #2196F3;
        }

        .character-btns {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }

        .char-btn {
            padding: 10px 15px;
            border: 2px solid #666;
            background: transparent;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .char-btn.active {
            background: #FF6B00;
            border-color: #FF8C00;
        }

        .char-btn:hover {
            border-color: #FF6B00;
        }

        .char-description {
            font-size: 12px;
            color: #aaa;
            font-style: italic;
        }

        #ability-bar {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            overflow: hidden;
            display: none;
            z-index: 10;
        }

        #ability-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF6B00, #FFD700);
            width: 100%;
            transition: width 0.1s;
        }

        #ability-text {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 12px;
            line-height: 20px;
            text-shadow: 1px 1px 2px black;
        }

        #ability-prompt {
            position: absolute;
            bottom: 110px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
            display: none;
            z-index: 10;
        }

        /* Stats Page */
        #stats-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a3a2a 0%, #0d1f15 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 100;
            overflow-y: auto;
            padding: 40px 20px;
        }

        .stats-container {
            background: rgba(0,0,0,0.7);
            padding: 30px;
            border-radius: 20px;
            max-width: 800px;
            width: 100%;
        }

        .stats-container h2 {
            color: #FFD700;
            text-align: center;
            margin-bottom: 30px;
            font-size: 36px;
        }

        .stats-graph {
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .stats-graph h3 {
            color: #8FBC8F;
            margin-bottom: 15px;
        }

        #score-graph {
            width: 100%;
            height: 200px;
            background: #1a1a1a;
            border-radius: 8px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-card {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-card .stat-value {
            font-size: 36px;
            color: #4CAF50;
            font-weight: bold;
        }

        .stat-card .stat-label {
            font-size: 14px;
            color: #aaa;
            margin-top: 5px;
        }

        .stat-card.highlight .stat-value {
            color: #FFD700;
        }

        .back-btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 18px;
            background: #455A64;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }

        .back-btn:hover {
            background: #607D8B;
        }

        .no-stats {
            text-align: center;
            color: #888;
            padding: 40px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>Kills: <span id="kills">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Time: <span id="time">0</span>s</div>
    </div>
    
    <div id="weapon-display">
        Weapon: <span id="current-weapon">Fists</span>
    </div>

    <button id="quit-btn">QUIT TO MENU</button>
    
    <div id="ability-bar">
        <div id="ability-fill"></div>
        <div id="ability-text">ABILITY READY - Press Q</div>
    </div>
    <div id="ability-prompt">Press Q for Special Ability!</div>

    <div id="mobile-controls">
        <div id="joystick-container">
            <div id="joystick-thumb"></div>
        </div>
        <div class="mobile-action-btns">
            <div class="mobile-btn" id="mobile-jump">JUMP</div>
            <div class="mobile-btn" id="mobile-attack">ATTACK</div>
        </div>
    </div>

    <div id="crosshair"></div>

    <!-- Main Menu -->
    <div id="main-menu">
        <div class="menu-title">Duck Defense 3D</div>
        <div class="menu-subtitle">Survive the hunter invasion!</div>
        <div class="menu-buttons">
            <button class="menu-btn" id="play-btn">PLAY GAME</button>
            <button class="menu-btn secondary" id="settings-menu-btn">SETTINGS</button>
            <button class="menu-btn secondary" id="stats-btn">STATISTICS</button>
        </div>
    </div>

    <!-- Settings Page -->
    <div id="settings-page">
        <div class="settings-panel">
            <h2>Settings</h2>
            <div class="setting-row">
                <span class="setting-label">Difficulty</span>
                <div class="difficulty-btns">
                    <button class="diff-btn" data-diff="easy">Easy</button>
                    <button class="diff-btn active" data-diff="normal">Normal</button>
                    <button class="diff-btn" data-diff="hard">Hard</button>
                </div>
            </div>
            <div class="setting-row">
                <span class="setting-label">Input Method</span>
                <div class="input-btns">
                    <button class="input-btn active" data-input="computer">Computer</button>
                    <button class="input-btn" data-input="mobile">Mobile</button>
                </div>
            </div>
            <div class="setting-row" style="flex-direction: column; align-items: flex-start;">
                <span class="setting-label" style="margin-bottom: 10px;">Character</span>
                <div class="character-btns">
                    <button class="char-btn active" data-char="duck">Duck</button>
                    <button class="char-btn" data-char="titanTurkey">Titan Turkey</button>
                    <button class="char-btn" data-char="kungPowChicken">Kung Pow Chicken</button>
                    <button class="char-btn" data-char="mericaMallard">Merica Mallard</button>
                </div>
                <div class="char-description" id="char-description">Classic yellow duck - balanced gameplay</div>
            </div>
            <button class="back-btn" id="settings-back-btn">BACK TO MENU</button>
        </div>
    </div>

    <!-- Stats Page -->
    <div id="stats-page">
        <div class="stats-container">
            <h2>Your Statistics</h2>
            <div class="stats-graph">
                <h3>Score History</h3>
                <canvas id="score-graph"></canvas>
            </div>
            <div class="stats-grid" id="stats-grid">
                <!-- Stats will be populated dynamically -->
            </div>
            <button class="back-btn" id="stats-back-btn">BACK TO MENU</button>
        </div>
    </div>

    <div id="game-over">
        <h1>GAME OVER!</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button id="restart-btn">PLAY AGAIN</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ==================== GAME SETTINGS (persisted) ====================
        const defaultSettings = {
            difficulty: 'normal',
            inputMethod: 'computer',
            character: 'duck'
        };
        
        // Character configurations
        const characterConfig = {
            duck: {
                name: 'Duck',
                description: 'Classic yellow duck - balanced gameplay',
                colors: { body: 0xFFFF00, head: 0xFFFF00, beak: 0xFFA500, wing: 0xFFDD00 },
                ability: null,
                abilityCooldown: 0
            },
            titanTurkey: {
                name: 'Titan Turkey',
                description: 'Football helmet charge - ram through enemies!',
                colors: { body: 0x8B4513, head: 0xCC3333, beak: 0xFFAA00, wing: 0x6B3513 },
                ability: 'helmetCharge',
                abilityCooldown: 15000,
                abilityDuration: 10000
            },
            kungPowChicken: {
                name: 'Kung Pow Chicken',
                description: 'Martial arts master - devastating combo attacks!',
                colors: { body: 0xFFFFFF, head: 0xFFFFFF, beak: 0xFFCC00, wing: 0xEEEEEE },
                ability: 'martialArts',
                abilityCooldown: 8000,
                abilityDuration: 5000
            },
            mericaMallard: {
                name: 'Merica Mallard',
                description: 'Patriotic power - eagle strike from above!',
                colors: { body: 0x002868, head: 0x002868, beak: 0xBF0A30, wing: 0xFFFFFF },
                ability: 'eagleStrike',
                abilityCooldown: 12000,
                abilityDuration: 0
            }
        };
        
        function loadSettings() {
            const saved = localStorage.getItem('duckDefenseSettings');
            return saved ? JSON.parse(saved) : { ...defaultSettings };
        }
        
        function saveSettings() {
            localStorage.setItem('duckDefenseSettings', JSON.stringify(gameSettings));
        }
        
        const gameSettings = loadSettings();
        
        // Difficulty multipliers
        const difficultyConfig = {
            easy: { spawnRate: 4000, enemyHealth: 0.7, enemyDamage: 0.5, enemySpeed: 0.7 },
            normal: { spawnRate: 3000, enemyHealth: 1.0, enemyDamage: 1.0, enemySpeed: 1.0 },
            hard: { spawnRate: 2000, enemyHealth: 1.5, enemyDamage: 1.5, enemySpeed: 1.3 }
        };

        // ==================== STATS SYSTEM ====================
        function loadAllStats() {
            const saved = localStorage.getItem('duckDefenseStats');
            return saved ? JSON.parse(saved) : { games: [], totalKills: 0, totalTime: 0, totalVehicleTime: 0, weaponKills: {} };
        }
        
        function saveAllStats() {
            localStorage.setItem('duckDefenseStats', JSON.stringify(allTimeStats));
        }
        
        const allTimeStats = loadAllStats();
        
        // Current session stats
        const sessionStats = {
            kills: 0,
            timeAlive: 0,
            vehicleTime: 0,
            vehicleKills: 0,
            weaponKills: {},
            weaponsUsed: new Set()
        };
        
        function resetSessionStats() {
            sessionStats.kills = 0;
            sessionStats.timeAlive = 0;
            sessionStats.vehicleTime = 0;
            sessionStats.vehicleKills = 0;
            sessionStats.weaponKills = {};
            sessionStats.weaponsUsed = new Set();
        }
        
        function trackKill(weaponOrType) {
            sessionStats.kills++;
            sessionStats.weaponKills[weaponOrType] = (sessionStats.weaponKills[weaponOrType] || 0) + 1;
            sessionStats.weaponsUsed.add(weaponOrType);
        }
        
        function recordGameEnd(score, timeAlive) {
            allTimeStats.games.push({
                score: score,
                time: timeAlive,
                date: Date.now(),
                difficulty: gameSettings.difficulty
            });
            allTimeStats.totalKills += sessionStats.kills;
            allTimeStats.totalTime += timeAlive;
            allTimeStats.totalVehicleTime += sessionStats.vehicleTime;
            
            for (const [weapon, kills] of Object.entries(sessionStats.weaponKills)) {
                allTimeStats.weaponKills[weapon] = (allTimeStats.weaponKills[weapon] || 0) + kills;
            }
            
            // Keep only last 50 games for graph
            if (allTimeStats.games.length > 50) {
                allTimeStats.games = allTimeStats.games.slice(-50);
            }
            
            saveAllStats();
        }

        // ==================== GAME STATE ====================
        const gameState = {
            kills: 0,
            lives: 3,
            currentWeapon: 'fists',
            isGameOver: false,
            isPaused: true,
            enemySpawnRate: 3000,
            lastSpawnTime: 0,
            gameStartTime: 0,
            gameTime: 0,
            vehicle: null
        };

        // ==================== WEAPONS CONFIG ====================
        const weapons = {
            fists: { damage: 10, range: 3, cooldown: 500, type: 'melee' },
            sword: { damage: 30, range: 5, cooldown: 400, type: 'melee' },
            hammer: { damage: 50, range: 4, cooldown: 800, type: 'melee' },
            rifle: { damage: 80, range: 100, cooldown: 600, type: 'projectile', speed: 1.2 },
            machineGun: { damage: 50, range: 20, cooldown: 150, type: 'projectile', speed: 1.0 },
            catapult: { damage: 60, range: 40, cooldown: 1500, type: 'arc', speed: 0.3 },
            cannon: { damage: 100, range: 50, cooldown: 2000, type: 'projectile', speed: 0.5, aoe: 5 }
        };

        // ==================== SCENE SETUP ====================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x6B8E7F); // Murky marsh sky
        scene.fog = new THREE.Fog(0x8B9A8E, 20, 70); // Humid marsh fog

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(20, 40, 20);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -60;
        directionalLight.shadow.camera.right = 60;
        directionalLight.shadow.camera.top = 60;
        directionalLight.shadow.camera.bottom = -60;
        scene.add(directionalLight);

        // ==================== TERRAIN ====================
        const terrainSize = 100;
        const terrainSegments = 50;
        const obstacles = [];
        
        function getTerrainHeight(x, z) {
            const scale = 0.05;
            return Math.sin(x * scale) * Math.cos(z * scale) * 3 + 
                   Math.sin(x * scale * 0.3) * 2;
        }

        const groundGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSegments, terrainSegments);
        const vertices = groundGeometry.attributes.position.array;
        
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 1];
            vertices[i + 2] = getTerrainHeight(x, z);
        }
        
        groundGeometry.computeVertexNormals();
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3D5A3D }); // Darker marsh ground
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Dark murky swamp water patches with enhanced aesthetics
        const waterZones = [];
        for (let i = 0; i < 40; i++) {
            const radius = Math.random() * 4 + 2;
            const waterGeom = new THREE.CircleGeometry(radius, 16);
            const waterMat = new THREE.MeshLambertMaterial({ color: 0x2F4538, transparent: true, opacity: 0.8 }); // Dark swamp water
            const water = new THREE.Mesh(waterGeom, waterMat);
            water.rotation.x = -Math.PI / 2;
            const x = (Math.random() - 0.5) * 90;
            const z = (Math.random() - 0.5) * 90;
            const terrainY = getTerrainHeight(x, z);
            water.position.set(x, terrainY + 0.05, z);
            scene.add(water);
            
            // Add lily pads floating on larger ponds
            if (radius > 3) {
                for (let j = 0; j < 3; j++) {
                    const lilyGeom = new THREE.CircleGeometry(0.4, 8);
                    const lilyMat = new THREE.MeshLambertMaterial({ color: 0x4A6741 });
                    const lily = new THREE.Mesh(lilyGeom, lilyMat);
                    lily.rotation.x = -Math.PI / 2;
                    const angle = (j / 3) * Math.PI * 2 + Math.random();
                    const dist = radius * 0.5 * Math.random();
                    lily.position.set(x + Math.cos(angle) * dist, terrainY + 0.1, z + Math.sin(angle) * dist);
                    scene.add(lily);
                }
            }
            
            // Add reeds/cattails around pond edges
            const reedCount = Math.floor(radius * 2);
            for (let j = 0; j < reedCount; j++) {
                const reedGeom = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 4);
                const reedMat = new THREE.MeshLambertMaterial({ color: 0x5C6F4E });
                const reed = new THREE.Mesh(reedGeom, reedMat);
                const angle = (j / reedCount) * Math.PI * 2;
                const edgeDist = radius + 0.3 + Math.random() * 0.3;
                reed.position.set(x + Math.cos(angle) * edgeDist, terrainY + 0.75, z + Math.sin(angle) * edgeDist);
                reed.rotation.z = (Math.random() - 0.5) * 0.2;
                scene.add(reed);
                
                // Cattail bulb on top
                const bulbGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.3, 6);
                const bulbMat = new THREE.MeshLambertMaterial({ color: 0x6B4423 });
                const bulb = new THREE.Mesh(bulbGeom, bulbMat);
                bulb.position.set(
                    x + Math.cos(angle) * edgeDist,
                    terrainY + 1.5,
                    z + Math.sin(angle) * edgeDist
                );
                scene.add(bulb);
            }
            
            waterZones.push({ position: new THREE.Vector3(x, 0, z), radius: radius });
        }

        // Cypress trees with spanish moss (collision obstacles)
        function createTree() {
            const tree = new THREE.Group();
            
            // Wider base, narrow top - cypress style
            const trunkGeom = new THREE.CylinderGeometry(0.25, 0.5, 5, 8);
            const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4A3C28 }); // Dark cypress bark
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // Sparse canopy
            const leavesGeom = new THREE.ConeGeometry(1.5, 3, 8);
            const leavesMat = new THREE.MeshLambertMaterial({ color: 0x4A6741 }); // Darker cypress green
            const leaves = new THREE.Mesh(leavesGeom, leavesMat);
            leaves.position.y = 5.5;
            leaves.castShadow = true;
            tree.add(leaves);
            
            // Spanish moss hanging down
            for (let i = 0; i < 3; i++) {
                const mossGeom = new THREE.BoxGeometry(0.1, 1.5, 0.1);
                const mossMat = new THREE.MeshLambertMaterial({ color: 0x8B9467 }); // Grayish-green moss
                const moss = new THREE.Mesh(mossGeom, mossMat);
                moss.position.set(
                    (Math.random() - 0.5) * 1.5,
                    4.2,
                    (Math.random() - 0.5) * 1.5
                );
                moss.rotation.z = (Math.random() - 0.5) * 0.3;
                tree.add(moss);
            }
            
            return tree;
        }

        for (let i = 0; i < 40; i++) {
            const tree = createTree();
            const x = (Math.random() - 0.5) * 80;
            const z = (Math.random() - 0.5) * 80;
            if (Math.abs(x) > 10 || Math.abs(z) > 10) {
                const terrainY = getTerrainHeight(x, z);
                tree.position.set(x, terrainY, z);
                scene.add(tree);
                obstacles.push({ 
                    position: new THREE.Vector3(x, 0, z), 
                    radius: 0.5, 
                    type: 'tree',
                    walkableHeight: terrainY + 5  // Top of trunk at y=5 from base
                });
            }
        }

        // Swamp vegetation - palmetto bushes (slow movement)
        const bushZones = [];
        function createBush() {
            const bushGeom = new THREE.SphereGeometry(1, 6, 6);
            const bushMat = new THREE.MeshLambertMaterial({ color: 0x3A4F3A }); // Darker swamp vegetation
            const bush = new THREE.Mesh(bushGeom, bushMat);
            bush.scale.set(1.2, 0.5, 1.2);
            bush.castShadow = true;
            return bush;
        }

        for (let i = 0; i < 60; i++) {
            const bush = createBush();
            const x = (Math.random() - 0.5) * 90;
            const z = (Math.random() - 0.5) * 90;
            bush.position.set(x, getTerrainHeight(x, z) + 0.3, z);
            scene.add(bush);
            bushZones.push({ position: new THREE.Vector3(x, 0, z), radius: 1.2 });
        }

        // Garbage piles - aesthetic swamp trash
        function createGarbagePile() {
            const pile = new THREE.Group();
            
            // Various junk pieces
            for (let i = 0; i < 5; i++) {
                const junkGeom = new THREE.BoxGeometry(
                    Math.random() * 0.5 + 0.2,
                    Math.random() * 0.4 + 0.1,
                    Math.random() * 0.5 + 0.2
                );
                const junkColors = [0x3A3A3A, 0x5C4033, 0x2F2F2F, 0x8B4513];
                const junkMat = new THREE.MeshLambertMaterial({ color: junkColors[Math.floor(Math.random() * junkColors.length)] });
                const junk = new THREE.Mesh(junkGeom, junkMat);
                junk.position.set(
                    (Math.random() - 0.5) * 0.8,
                    Math.random() * 0.3,
                    (Math.random() - 0.5) * 0.8
                );
                junk.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                pile.add(junk);
            }
            
            return pile;
        }

        for (let i = 0; i < 12; i++) {
            const garbagePile = createGarbagePile();
            const x = (Math.random() - 0.5) * 70;
            const z = (Math.random() - 0.5) * 70;
            garbagePile.position.set(x, getTerrainHeight(x, z), z);
            scene.add(garbagePile);
        }

        // Glowing lanterns - atmospheric marsh lighting
        function createLantern() {
            const lantern = new THREE.Group();
            
            // Pole
            const poleGeom = new THREE.CylinderGeometry(0.05, 0.05, 2.5, 6);
            const poleMat = new THREE.MeshLambertMaterial({ color: 0x2F2F2F });
            const pole = new THREE.Mesh(poleGeom, poleMat);
            pole.position.y = 1.25;
            lantern.add(pole);
            
            // Lantern cage
            const cageGeom = new THREE.BoxGeometry(0.3, 0.4, 0.3);
            const cageMat = new THREE.MeshLambertMaterial({ color: 0x1A1A1A });
            const cage = new THREE.Mesh(cageGeom, cageMat);
            cage.position.y = 2.6;
            lantern.add(cage);
            
            // Glowing light inside
            const lightGeom = new THREE.SphereGeometry(0.15, 8, 8);
            const lightMat = new THREE.MeshLambertMaterial({ 
                color: 0xFFAA00, 
                emissive: 0xFFAA00, 
                emissiveIntensity: 1 
            });
            const light = new THREE.Mesh(lightGeom, lightMat);
            light.position.y = 2.6;
            lantern.add(light);
            
            // Point light for glow
            const pointLight = new THREE.PointLight(0xFFAA00, 0.5, 8);
            pointLight.position.y = 2.6;
            lantern.add(pointLight);
            
            return lantern;
        }

        for (let i = 0; i < 10; i++) {
            const lantern = createLantern();
            const angle = (i / 10) * Math.PI * 2;
            const distance = 20 + Math.random() * 15;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            lantern.position.set(x, getTerrainHeight(x, z), z);
            scene.add(lantern);
        }

        // Hut (collision obstacle) - Complex marsh-blended design
        function createHut() {
            const hut = new THREE.Group();
            
            // Weathered wooden stilts/supports for swamp
            const stiltMat = new THREE.MeshLambertMaterial({ color: 0x3A2817 });
            for (let i = 0; i < 4; i++) {
                const stiltGeom = new THREE.CylinderGeometry(0.2, 0.25, 2, 6);
                const stilt = new THREE.Mesh(stiltGeom, stiltMat);
                const x = i < 2 ? -3 : 3;
                const z = i % 2 === 0 ? -3 : 3;
                stilt.position.set(x, 1, z);
                stilt.castShadow = true;
                hut.add(stilt);
            }
            
            // Main cabin - weathered wood planks
            const baseGeom = new THREE.BoxGeometry(8, 4, 8);
            const baseMat = new THREE.MeshLambertMaterial({ color: 0x5C4033 }); // Darker weathered wood
            const base = new THREE.Mesh(baseGeom, baseMat);
            base.position.y = 2;
            base.castShadow = true;
            hut.add(base);
            
            // Horizontal planks detail
            for (let i = 0; i < 5; i++) {
                const plankGeom = new THREE.BoxGeometry(8.1, 0.15, 8.1);
                const plankMat = new THREE.MeshLambertMaterial({ color: 0x4A3528 });
                const plank = new THREE.Mesh(plankGeom, plankMat);
                plank.position.y = 0.5 + i * 0.8;
                hut.add(plank);
            }
            
            // Mossy overgrowth on sides
            const mossMat = new THREE.MeshLambertMaterial({ color: 0x6B8E6B });
            for (let i = 0; i < 8; i++) {
                const mossGeom = new THREE.BoxGeometry(0.2, 1.2, 0.3);
                const moss = new THREE.Mesh(mossGeom, mossMat);
                const angle = (i / 8) * Math.PI * 2;
                moss.position.set(Math.cos(angle) * 4.1, 2 + Math.random(), Math.sin(angle) * 4.1);
                moss.rotation.y = angle;
                hut.add(moss);
            }
            
            // Thatched roof - darker swamp reeds
            const roofGeom = new THREE.ConeGeometry(6, 3, 4);
            const roofMat = new THREE.MeshLambertMaterial({ color: 0x6B5D4F }); // Dark thatch
            const roof = new THREE.Mesh(roofGeom, roofMat);
            roof.position.y = 5.5;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            hut.add(roof);
            
            // Roof moss patches
            for (let i = 0; i < 6; i++) {
                const roofMossGeom = new THREE.BoxGeometry(1, 0.1, 1);
                const roofMoss = new THREE.Mesh(roofMossGeom, mossMat);
                const angle = (i / 6) * Math.PI * 2;
                roofMoss.position.set(Math.cos(angle) * 2, 5.5 + Math.random() * 0.5, Math.sin(angle) * 2);
                roofMoss.rotation.y = angle;
                hut.add(roofMoss);
            }
            
            // Small door
            const doorGeom = new THREE.BoxGeometry(1.5, 2.5, 0.1);
            const doorMat = new THREE.MeshLambertMaterial({ color: 0x2F1F10 });
            const door = new THREE.Mesh(doorGeom, doorMat);
            door.position.set(0, 1.5, 4.05);
            hut.add(door);
            
            return hut;
        }

        const hut = createHut();
        scene.add(hut);
        obstacles.push({ 
            position: new THREE.Vector3(0, 0, 0), 
            radius: 4.5,
            type: 'hut',
            walkableHeight: 4  // Top of base at y=4
        });

        // ==================== DUCK PLAYER ====================
        function createDuck() {
            return createCharacter('duck');
        }
        
        function createCharacter(charType) {
            const config = characterConfig[charType] || characterConfig.duck;
            const bird = new THREE.Group();
            bird.userData.charType = charType;
            
            const bodyGeom = new THREE.SphereGeometry(0.6, 8, 8);
            const bodyMat = new THREE.MeshLambertMaterial({ color: config.colors.body });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.scale.y = 1.2;
            body.castShadow = true;
            bird.add(body);
            bird.userData.body = body;
            
            const headGeom = new THREE.SphereGeometry(0.4, 8, 8);
            const headMat = new THREE.MeshLambertMaterial({ color: config.colors.head });
            const head = new THREE.Mesh(headGeom, headMat);
            head.position.y = 0.8;
            head.castShadow = true;
            bird.add(head);
            bird.userData.head = head;
            
            const beakGeom = new THREE.ConeGeometry(0.15, 0.3, 4);
            const beakMat = new THREE.MeshLambertMaterial({ color: config.colors.beak });
            const beak = new THREE.Mesh(beakGeom, beakMat);
            beak.rotation.x = Math.PI / 2;
            beak.position.set(0, 0.8, 0.4);
            beak.castShadow = true;
            bird.add(beak);
            
            const eyeGeom = new THREE.SphereGeometry(0.08, 6, 6);
            const eyeMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
            leftEye.position.set(-0.15, 0.9, 0.3);
            const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
            rightEye.position.set(0.15, 0.9, 0.3);
            bird.add(leftEye, rightEye);
            
            // Wings
            const wingGeom = new THREE.BoxGeometry(0.8, 0.1, 0.5);
            const wingMat = new THREE.MeshLambertMaterial({ color: config.colors.wing });
            const leftWing = new THREE.Mesh(wingGeom, wingMat);
            leftWing.position.set(-0.5, 0.2, 0);
            leftWing.rotation.z = -Math.PI / 6;
            leftWing.castShadow = true;
            bird.add(leftWing);
            bird.userData.leftWing = leftWing;
            
            const rightWing = new THREE.Mesh(wingGeom, wingMat);
            rightWing.position.set(0.5, 0.2, 0);
            rightWing.rotation.z = Math.PI / 6;
            rightWing.castShadow = true;
            bird.add(rightWing);
            bird.userData.rightWing = rightWing;
            
            // Character-specific features
            if (charType === 'titanTurkey') {
                // Turkey wattle
                const wattleGeom = new THREE.SphereGeometry(0.15, 6, 6);
                const wattleMat = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                const wattle = new THREE.Mesh(wattleGeom, wattleMat);
                wattle.scale.y = 1.5;
                wattle.position.set(0, 0.6, 0.35);
                bird.add(wattle);
                
                // Football helmet (hidden until ability active)
                const helmetGeom = new THREE.SphereGeometry(0.45, 8, 8);
                const helmetMat = new THREE.MeshLambertMaterial({ color: 0x1E90FF });
                const helmet = new THREE.Mesh(helmetGeom, helmetMat);
                helmet.position.y = 0.85;
                helmet.scale.set(1.1, 0.9, 1.1);
                helmet.visible = false;
                bird.add(helmet);
                bird.userData.helmet = helmet;
                
                // Facemask
                const maskGeom = new THREE.TorusGeometry(0.2, 0.02, 4, 8);
                const maskMat = new THREE.MeshLambertMaterial({ color: 0xCCCCCC });
                const mask = new THREE.Mesh(maskGeom, maskMat);
                mask.position.set(0, 0.85, 0.4);
                mask.rotation.x = Math.PI / 2;
                mask.visible = false;
                bird.add(mask);
                bird.userData.facemask = mask;
            }
            
            if (charType === 'kungPowChicken') {
                // Headband
                const bandGeom = new THREE.TorusGeometry(0.38, 0.03, 4, 16);
                const bandMat = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                const band = new THREE.Mesh(bandGeom, bandMat);
                band.position.y = 0.95;
                band.rotation.x = Math.PI / 2;
                bird.add(band);
                
                // Tail ribbons
                const ribbonGeom = new THREE.BoxGeometry(0.05, 0.3, 0.02);
                const ribbon1 = new THREE.Mesh(ribbonGeom, bandMat);
                ribbon1.position.set(-0.3, 0.85, -0.2);
                ribbon1.rotation.z = 0.3;
                const ribbon2 = new THREE.Mesh(ribbonGeom, bandMat);
                ribbon2.position.set(-0.35, 0.75, -0.2);
                ribbon2.rotation.z = 0.5;
                bird.add(ribbon1, ribbon2);
            }
            
            if (charType === 'mericaMallard') {
                // Uncle Sam hat
                const hatBaseGeom = new THREE.CylinderGeometry(0.35, 0.35, 0.05, 16);
                const hatBaseMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const hatBase = new THREE.Mesh(hatBaseGeom, hatBaseMat);
                hatBase.position.y = 1.15;
                bird.add(hatBase);
                
                const hatTopGeom = new THREE.CylinderGeometry(0.25, 0.25, 0.4, 16);
                const hatTopMat = new THREE.MeshLambertMaterial({ color: 0xBF0A30 });
                const hatTop = new THREE.Mesh(hatTopGeom, hatTopMat);
                hatTop.position.y = 1.35;
                bird.add(hatTop);
                
                // Star on hat
                const starGeom = new THREE.SphereGeometry(0.08, 4, 4);
                const starMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const star = new THREE.Mesh(starGeom, starMat);
                star.position.set(0, 1.35, 0.25);
                bird.add(star);
            }
            
            return bird;
        }

        function createWeaponModel(weaponType) {
            const weapon = new THREE.Group();
            
            switch(weaponType) {
                case 'sword':
                    const bladeGeom = new THREE.BoxGeometry(0.12, 2.0, 0.06);
                    const bladeMat = new THREE.MeshLambertMaterial({ color: 0xE0E0E0 });
                    const blade = new THREE.Mesh(bladeGeom, bladeMat);
                    blade.position.y = 1.0;
                    weapon.add(blade);
                    
                    // Blade edge highlight
                    const edgeGeom = new THREE.BoxGeometry(0.02, 2.0, 0.06);
                    const edgeMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                    const edge = new THREE.Mesh(edgeGeom, edgeMat);
                    edge.position.set(0.055, 1.0, 0);
                    weapon.add(edge);
                    
                    const handleGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 6);
                    const handleMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const handle = new THREE.Mesh(handleGeom, handleMat);
                    handle.position.y = -0.25;
                    weapon.add(handle);
                    
                    // Crossguard/Hilt
                    const guardGeom = new THREE.BoxGeometry(0.5, 0.08, 0.08);
                    const guardMat = new THREE.MeshLambertMaterial({ color: 0xDAA520 });
                    const guard = new THREE.Mesh(guardGeom, guardMat);
                    guard.position.y = 0;
                    weapon.add(guard);
                    
                    // Pommel
                    const pommelGeom = new THREE.SphereGeometry(0.12, 6, 6);
                    const pommel = new THREE.Mesh(pommelGeom, guardMat);
                    pommel.position.y = -0.5;
                    weapon.add(pommel);
                    break;
                    
                case 'hammer':
                    const hammerHeadGeom = new THREE.BoxGeometry(0.8, 0.8, 0.5);
                    const hammerHeadMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
                    const hammerHead = new THREE.Mesh(hammerHeadGeom, hammerHeadMat);
                    hammerHead.position.y = 1.5;
                    weapon.add(hammerHead);
                    
                    // Metal band on hammer head
                    const bandGeom = new THREE.BoxGeometry(0.82, 0.15, 0.52);
                    const bandMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
                    const band = new THREE.Mesh(bandGeom, bandMat);
                    band.position.y = 1.5;
                    weapon.add(band);
                    
                    const hammerHandleGeom = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6);
                    const hammerHandleMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
                    const hammerHandle = new THREE.Mesh(hammerHandleGeom, hammerHandleMat);
                    hammerHandle.position.y = 0.75;
                    weapon.add(hammerHandle);
                    
                    // Handle grip
                    const gripGeom = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
                    const gripMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const grip = new THREE.Mesh(gripGeom, gripMat);
                    grip.position.y = 0.3;
                    weapon.add(grip);
                    break;
                    
                case 'rifle':
                case 'machineGun':
                    const barrelGeom = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
                    const gunMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    const barrel = new THREE.Mesh(barrelGeom, gunMat);
                    barrel.rotation.z = Math.PI / 2;
                    barrel.position.x = 0.5;
                    weapon.add(barrel);
                    
                    const stockGeom = new THREE.BoxGeometry(0.3, 0.15, 0.1);
                    const stock = new THREE.Mesh(stockGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    stock.position.x = -0.1;
                    weapon.add(stock);
                    break;
                    
                case 'catapult':
                    const catapultBaseGeom = new THREE.BoxGeometry(0.8, 0.3, 0.6);
                    const catapultBase = new THREE.Mesh(catapultBaseGeom, new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                    catapultBase.position.y = 0.15;
                    weapon.add(catapultBase);
                    
                    const catapultArmGeom = new THREE.BoxGeometry(0.08, 1.0, 0.08);
                    const catapultArm = new THREE.Mesh(catapultArmGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    catapultArm.position.y = 0.65;
                    weapon.add(catapultArm);
                    
                    // Spoon/bucket
                    const spoonGeom = new THREE.BoxGeometry(0.3, 0.1, 0.3);
                    const spoon = new THREE.Mesh(spoonGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    spoon.position.y = 1.1;
                    weapon.add(spoon);
                    
                    // Support beams
                    const supportGeom = new THREE.BoxGeometry(0.1, 0.6, 0.1);
                    const support1 = new THREE.Mesh(supportGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    support1.position.set(-0.3, 0.45, 0);
                    support1.rotation.z = -0.3;
                    weapon.add(support1);
                    const support2 = new THREE.Mesh(supportGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    support2.position.set(0.3, 0.45, 0);
                    support2.rotation.z = 0.3;
                    weapon.add(support2);
                    break;
                    
                case 'cannon':
                    const cannonBarrelGeom = new THREE.CylinderGeometry(0.25, 0.2, 1.2, 8);
                    const cannonBarrel = new THREE.Mesh(cannonBarrelGeom, new THREE.MeshLambertMaterial({ color: 0x333333 }));
                    cannonBarrel.rotation.z = Math.PI / 2;
                    cannonBarrel.position.set(0.6, 0.3, 0);
                    weapon.add(cannonBarrel);
                    
                    // Cannon mouth rim
                    const rimGeom = new THREE.CylinderGeometry(0.26, 0.25, 0.1, 8);
                    const rim = new THREE.Mesh(rimGeom, new THREE.MeshLambertMaterial({ color: 0x666666 }));
                    rim.rotation.z = Math.PI / 2;
                    rim.position.set(1.15, 0.3, 0);
                    weapon.add(rim);
                    
                    // Carriage base
                    const carriageGeom = new THREE.BoxGeometry(0.6, 0.2, 0.5);
                    const carriage = new THREE.Mesh(carriageGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    carriage.position.y = 0.1;
                    weapon.add(carriage);
                    
                    const wheelGeom = new THREE.CylinderGeometry(0.15, 0.15, 0.08, 8);
                    const wheel1 = new THREE.Mesh(wheelGeom, new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                    wheel1.rotation.x = Math.PI / 2;
                    wheel1.position.set(0, 0.15, -0.3);
                    weapon.add(wheel1);
                    const wheel2 = new THREE.Mesh(wheelGeom, new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                    wheel2.rotation.x = Math.PI / 2;
                    wheel2.position.set(0, 0.15, 0.3);
                    weapon.add(wheel2);
                    break;
            }
            
            weapon.scale.set(0.8, 0.8, 0.8);
            return weapon;
        }

        const player = {
            mesh: createCharacter(gameSettings.character),
            velocity: new THREE.Vector3(),
            position: new THREE.Vector3(8, 1, 0), // Start outside hut
            lookAngle: 0,
            isJumping: false,
            jumpsUsed: 0,
            maxJumps: 2,
            canAttack: true,
            lastAttackTime: 0,
            weaponModel: null,
            wingFlapTime: 0,
            bloodDripCounter: 0,
            // Ability system
            abilityActive: false,
            abilityEndTime: 0,
            abilityCooldownEnd: 0,
            comboCount: 0,
            lastComboTime: 0
        };

        player.mesh.position.copy(player.position);
        scene.add(player.mesh);

        function updatePlayerWeapon() {
            if (player.weaponModel) {
                player.mesh.remove(player.weaponModel);
            }
            
            if (gameState.currentWeapon !== 'fists') {
                player.weaponModel = createWeaponModel(gameState.currentWeapon);
                player.weaponModel.position.set(0.5, 0.3, 0);
                player.weaponModel.rotation.z = -Math.PI / 4;
                player.mesh.add(player.weaponModel);
            } else {
                player.weaponModel = null;
            }
        }

        // ==================== MOUSE INPUT ====================
        let mouseX = 0;
        let mouseY = 0;

        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // ==================== ENEMIES ====================
        const enemies = [];
        const bloodParticles = [];

        function createHunter(type = 'basic') {
            const hunter = new THREE.Group();
            hunter.userData.type = type;
            
            if (type === 'hulk') {
                // Hulk Hunter - Huge, green, carries a club
                const bodyGeom = new THREE.CylinderGeometry(0.8, 0.9, 2.5, 8);
                const bodyMat = new THREE.MeshLambertMaterial({ color: 0x556B2F }); // Olive green
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.position.y = 1.25;
                body.castShadow = true;
                hunter.add(body);
                
                // Massive head
                const headGeom = new THREE.SphereGeometry(0.6, 8, 8);
                const headMat = new THREE.MeshLambertMaterial({ color: 0x8FBC8F }); // Dark sea green
                const head = new THREE.Mesh(headGeom, headMat);
                head.position.y = 3.0;
                head.castShadow = true;
                hunter.add(head);
                
                // Angry eyes
                const eyeGeom = new THREE.SphereGeometry(0.12, 6, 6);
                const eyeMat = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
                leftEye.position.set(-0.2, 3.1, 0.5);
                const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
                rightEye.position.set(0.2, 3.1, 0.5);
                hunter.add(leftEye, rightEye);
                
                // Big muscular arms
                const armGeom = new THREE.CylinderGeometry(0.25, 0.3, 1.5, 6);
                const armMat = new THREE.MeshLambertMaterial({ color: 0x556B2F });
                const leftArm = new THREE.Mesh(armGeom, armMat);
                leftArm.position.set(-1.0, 1.8, 0);
                leftArm.rotation.z = Math.PI / 4;
                const rightArm = new THREE.Mesh(armGeom, armMat);
                rightArm.position.set(1.0, 1.8, 0);
                rightArm.rotation.z = -Math.PI / 4;
                hunter.add(leftArm, rightArm);
                
                // Giant club
                const clubHandleGeom = new THREE.CylinderGeometry(0.15, 0.12, 2.0, 6);
                const clubMat = new THREE.MeshLambertMaterial({ color: 0x4A3728 });
                const clubHandle = new THREE.Mesh(clubHandleGeom, clubMat);
                clubHandle.position.set(1.5, 2.0, 0);
                clubHandle.rotation.z = -Math.PI / 3;
                hunter.add(clubHandle);
                
                const clubHeadGeom = new THREE.SphereGeometry(0.5, 8, 8);
                const clubHead = new THREE.Mesh(clubHeadGeom, clubMat);
                clubHead.position.set(2.2, 2.8, 0);
                clubHead.scale.set(1.2, 0.8, 0.8);
                hunter.add(clubHead);
                
                // Spikes on club
                for (let i = 0; i < 6; i++) {
                    const spikeGeom = new THREE.ConeGeometry(0.1, 0.3, 4);
                    const spikeMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    const spike = new THREE.Mesh(spikeGeom, spikeMat);
                    const angle = (i / 6) * Math.PI * 2;
                    spike.position.set(
                        2.2 + Math.cos(angle) * 0.4,
                        2.8 + Math.sin(angle) * 0.3,
                        Math.sin(angle) * 0.4
                    );
                    spike.rotation.z = angle;
                    hunter.add(spike);
                }
                
                return hunter;
            }
            
            if (type === 'catapult') {
                // Catapult Hunter - Carries a portable catapult
                const bodyGeom = new THREE.CylinderGeometry(0.35, 0.35, 1.4, 6);
                const bodyMat = new THREE.MeshLambertMaterial({ color: 0x8B0000 }); // Dark red
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.position.y = 0.7;
                body.castShadow = true;
                hunter.add(body);
                
                const headGeom = new THREE.SphereGeometry(0.3, 8, 8);
                const headMat = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
                const head = new THREE.Mesh(headGeom, headMat);
                head.position.y = 1.6;
                head.castShadow = true;
                hunter.add(head);
                
                // Military helmet
                const helmetGeom = new THREE.SphereGeometry(0.35, 8, 8);
                const helmetMat = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
                const helmet = new THREE.Mesh(helmetGeom, helmetMat);
                helmet.position.y = 1.75;
                helmet.scale.y = 0.6;
                hunter.add(helmet);
                
                // Portable catapult on back
                const catBaseGeom = new THREE.BoxGeometry(0.6, 0.2, 0.4);
                const catMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
                const catBase = new THREE.Mesh(catBaseGeom, catMat);
                catBase.position.set(0, 1.2, -0.4);
                hunter.add(catBase);
                
                const catArmGeom = new THREE.BoxGeometry(0.1, 0.8, 0.1);
                const catArm = new THREE.Mesh(catArmGeom, catMat);
                catArm.position.set(0, 1.6, -0.4);
                catArm.rotation.x = -0.3;
                hunter.add(catArm);
                hunter.userData.catapultArm = catArm;
                
                // Ammo pouch
                const pouchGeom = new THREE.SphereGeometry(0.2, 6, 6);
                const pouchMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const pouch = new THREE.Mesh(pouchGeom, pouchMat);
                pouch.position.set(0.5, 0.5, 0);
                hunter.add(pouch);
                
                return hunter;
            }
            
            // Basic hunter (default)
            const bodyGeom = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 6);
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 0.6;
            body.castShadow = true;
            hunter.add(body);
            
            const headGeom = new THREE.SphereGeometry(0.3, 8, 8);
            const headMat = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
            const head = new THREE.Mesh(headGeom, headMat);
            head.position.y = 1.5;
            head.castShadow = true;
            hunter.add(head);
            
            const hatGeom = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 8);
            const hatMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const hat = new THREE.Mesh(hatGeom, hatMat);
            hat.position.y = 1.9;
            hunter.add(hat);
            
            const gunGeom = new THREE.BoxGeometry(0.1, 0.1, 0.6);
            const gunMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const gun = new THREE.Mesh(gunGeom, gunMat);
            gun.position.set(0.4, 1.0, 0);
            gun.rotation.x = -Math.PI / 6;
            hunter.add(gun);
            
            return hunter;
        }

        function createAlligator() {
            const gator = new THREE.Group();
            
            // Body - long and low
            const bodyGeom = new THREE.BoxGeometry(2.5, 0.5, 0.8);
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0x3A5F3A }); // Dark green
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 0.25;
            body.castShadow = true;
            gator.add(body);
            
            // Head - wider at the front
            const headGeom = new THREE.BoxGeometry(0.8, 0.4, 0.9);
            const head = new THREE.Mesh(headGeom, bodyMat);
            head.position.set(1.5, 0.25, 0);
            head.castShadow = true;
            gator.add(head);
            
            // Snout
            const snoutGeom = new THREE.BoxGeometry(0.5, 0.2, 0.6);
            const snout = new THREE.Mesh(snoutGeom, new THREE.MeshLambertMaterial({ color: 0x2F4F2F }));
            snout.position.set(1.9, 0.2, 0);
            gator.add(snout);
            
            // Eyes
            const eyeGeom = new THREE.SphereGeometry(0.1, 6, 6);
            const eyeMat = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
            const eye1 = new THREE.Mesh(eyeGeom, eyeMat);
            eye1.position.set(1.7, 0.4, 0.3);
            gator.add(eye1);
            const eye2 = new THREE.Mesh(eyeGeom, eyeMat);
            eye2.position.set(1.7, 0.4, -0.3);
            gator.add(eye2);
            
            // Tail
            const tailGeom = new THREE.ConeGeometry(0.4, 1.2, 4);
            const tail = new THREE.Mesh(tailGeom, bodyMat);
            tail.rotation.z = -Math.PI / 2;
            tail.position.set(-1.8, 0.25, 0);
            tail.castShadow = true;
            gator.add(tail);
            
            // Spikes on back
            for (let i = 0; i < 6; i++) {
                const spikeGeom = new THREE.ConeGeometry(0.1, 0.3, 4);
                const spike = new THREE.Mesh(spikeGeom, new THREE.MeshLambertMaterial({ color: 0x2F4F2F }));
                spike.position.set(-0.8 + i * 0.5, 0.5, 0);
                gator.add(spike);
            }
            
            return gator;
        }

        // Alligators array
        const alligators = [];
        
        // Spawn alligators near water zones
        for (let i = 0; i < 8; i++) {
            const waterZone = waterZones[Math.floor(Math.random() * waterZones.length)];
            const angle = Math.random() * Math.PI * 2;
            const dist = waterZone.radius + 1;
            const x = waterZone.position.x + Math.cos(angle) * dist;
            const z = waterZone.position.z + Math.sin(angle) * dist;
            
            const gator = {
                mesh: createAlligator(),
                position: new THREE.Vector3(x, getTerrainHeight(x, z), z),
                angle: angle,
                homePosition: new THREE.Vector3(x, 0, z),
                patrolRadius: 5,
                lastBiteTime: 0,
                biteCooldown: 2000
            };
            
            gator.mesh.position.copy(gator.position);
            gator.mesh.rotation.y = angle;
            scene.add(gator.mesh);
            alligators.push(gator);
        }

        function createBloodParticle(position, type = 'normal') {
            // Different sizes and colors based on type
            let size = 0.1;
            let color = 0x8B0000;
            let lifetime = 60;
            
            if (type === 'large') {
                size = 0.2;
                color = 0xFF0000; // Brighter red for large chunks
                lifetime = 80;
            } else if (type === 'spray') {
                size = 0.08;
                color = 0x660000; // Darker spray
                lifetime = 40;
            }
            
            const geom = new THREE.SphereGeometry(size, 4, 4);
            const mat = new THREE.MeshLambertMaterial({ color: color });
            const particle = new THREE.Mesh(geom, mat);
            particle.position.copy(position);
            particle.castShadow = true;
            scene.add(particle);
            
            // Different velocity patterns based on type
            let vel;
            if (type === 'spray') {
                vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.15,
                    Math.random() * 0.15,
                    (Math.random() - 0.5) * 0.15
                );
            } else {
                vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.4,
                    Math.random() * 0.4 + 0.2,
                    (Math.random() - 0.5) * 0.4
                );
            }
            
            bloodParticles.push({
                mesh: particle,
                velocity: vel,
                lifetime: lifetime
            });
        }

        // Wind streak particles for weapon swings
        const windStreaks = [];
        
        function createWindStreak(position, direction, weaponType) {
            // Create elongated wind streak particles
            const geom = weaponType === 'sword' ? 
                new THREE.BoxGeometry(0.15, 0.05, 0.8) : // Sword - long thin streak
                new THREE.BoxGeometry(0.2, 0.2, 0.6);     // Hammer - thicker streak
            
            const mat = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF, 
                transparent: true, 
                opacity: 0.8 
            });
            const streak = new THREE.Mesh(geom, mat);
            streak.position.copy(position);
            
            // Orient streak along swing direction
            const angle = Math.atan2(direction.x, direction.z);
            streak.rotation.y = angle;
            
            scene.add(streak);
            
            windStreaks.push({
                mesh: streak,
                velocity: direction.clone().multiplyScalar(0.3),
                lifetime: 12,
                initialOpacity: 0.8
            });
        }

        function createTruck() {
            const truck = new THREE.Group();
            const bodyGeom = new THREE.BoxGeometry(3, 1.2, 5);
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0x5a4a3a });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 1;
            body.castShadow = true;
            truck.add(body);
            const cabinGeom = new THREE.BoxGeometry(2.5, 1.5, 2);
            const cabinMat = new THREE.MeshLambertMaterial({ color: 0x3d3d3d });
            const cabin = new THREE.Mesh(cabinGeom, cabinMat);
            cabin.position.set(0, 2.2, 1);
            cabin.castShadow = true;
            truck.add(cabin);
            const bedGeom = new THREE.BoxGeometry(2.8, 0.8, 2.5);
            const bedMat = new THREE.MeshLambertMaterial({ color: 0x4a3a2a });
            const bed = new THREE.Mesh(bedGeom, bedMat);
            bed.position.set(0, 1.2, -1.2);
            truck.add(bed);
            const wheelGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 12);
            const wheelMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
            [[-1.4, 0.5, 1.5], [1.4, 0.5, 1.5], [-1.4, 0.5, -1.5], [1.4, 0.5, -1.5]].forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(...pos);
                truck.add(wheel);
            });
            return truck;
        }

        const vehicles = [];
        let lastTruckSpawnTime = Date.now();

        function spawnTruckWithDriver() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 48;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            const terrainY = getTerrainHeight(x, z);
            
            const truck = createTruck();
            truck.position.set(x, terrainY, z);
            truck.rotation.y = angle + Math.PI;
            scene.add(truck);
            
            const driver = createHunter();
            driver.position.set(0, 2.5, 0.8);
            truck.add(driver);
            
            const vehicle = {
                mesh: truck,
                position: new THREE.Vector3(x, terrainY, z),
                rotation: angle + Math.PI,
                velocity: new THREE.Vector3(),
                hasDriver: true,
                driver: {
                    mesh: driver,
                    health: 80,
                    lastShootTime: 0,
                    shootCooldown: 1500
                }
            };
            vehicles.push(vehicle);
        }

        function spawnEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 45;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            
            // Determine enemy type based on game time
            let enemyType = 'basic';
            const gameMinutes = gameState.gameTime / 60;
            
            if (gameMinutes >= 4) {
                // After 4 minutes: can spawn hulk hunters (20% chance)
                const roll = Math.random();
                if (roll < 0.2) {
                    enemyType = 'hulk';
                } else if (roll < 0.5) {
                    enemyType = 'catapult';
                }
            } else if (gameMinutes >= 2) {
                // After 2 minutes: can spawn catapult hunters (30% chance)
                if (Math.random() < 0.3) {
                    enemyType = 'catapult';
                }
            }
            
            // Configure enemy stats based on type
            let health, shootCooldown, lives, yOffset;
            switch (enemyType) {
                case 'hulk':
                    health = 200;
                    shootCooldown = 0; // Melee only
                    lives = 3;
                    yOffset = 1.5;
                    break;
                case 'catapult':
                    health = 80;
                    shootCooldown = 3500; // Slower but more powerful
                    lives = 1;
                    yOffset = 1;
                    break;
                default: // basic
                    health = 50;
                    shootCooldown = 2000;
                    lives = 1;
                    yOffset = 1;
            }
            
            const enemy = {
                mesh: createHunter(enemyType),
                position: new THREE.Vector3(x, getTerrainHeight(x, z) + yOffset, z),
                health: health,
                maxHealth: health,
                lastShootTime: 0,
                shootCooldown: shootCooldown,
                type: enemyType,
                lives: lives,
                lastMeleeTime: 0
            };
            
            enemy.mesh.position.copy(enemy.position);
            scene.add(enemy.mesh);
            enemies.push(enemy);
        }

        // ==================== PROJECTILES ====================
        const projectiles = [];

        function createProjectile(start, direction, config, fromPlayer = true, weaponType = null) {
            // Make cannon and catapult projectiles much larger (player only)
            let projectileSize = 0.15;
            let canPierce = false;
            
            // Only apply special projectile properties for player weapons
            if (fromPlayer && weaponType) {
                if (weaponType === 'cannon') {
                    projectileSize = 0.5;
                    canPierce = true;
                } else if (weaponType === 'catapult') {
                    projectileSize = 0.4;
                    canPierce = true;
                }
            }
            
            const geom = new THREE.SphereGeometry(projectileSize, 8, 8);
            const mat = new THREE.MeshLambertMaterial({ 
                color: fromPlayer ? (canPierce ? 0xFF6600 : 0xFFFF00) : 0xFF0000 
            });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.copy(start);
            mesh.castShadow = true;
            scene.add(mesh);
            
            projectiles.push({
                mesh,
                velocity: direction.clone().multiplyScalar(config.speed || 0.5),
                damage: config.damage,
                lifetime: 200,
                isArc: config.type === 'arc',
                aoe: config.aoe || 0,
                fromPlayer,
                canPierce,
                hitEnemies: [],
                hitVehicles: [],
                weaponType: weaponType
            });
        }

        function createEnemyProjectile(start, direction) {
            const geom = new THREE.SphereGeometry(0.12, 6, 6);
            const mat = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.copy(start);
            mesh.castShadow = true;
            scene.add(mesh);
            
            projectiles.push({
                mesh,
                velocity: direction.clone().multiplyScalar(0.5),
                damage: 1,
                lifetime: 150,
                fromPlayer: false
            });
        }

        // ==================== WEAPON PICKUPS ====================
        const pickups = [];

        function createPickup(weaponType) {
            const geom = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const mat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.castShadow = true;
            
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 15 + 5;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            mesh.position.set(x, getTerrainHeight(x, z) + 0.5, z);
            
            scene.add(mesh);
            pickups.push({ mesh, weaponType, rotation: 0 });
        }

        const weaponTypes = ['sword', 'hammer', 'rifle', 'machineGun', 'catapult', 'cannon'];
        for (let i = 0; i < 5; i++) {
            createPickup(weaponTypes[Math.floor(Math.random() * weaponTypes.length)]);
        }

        // ==================== INPUT ====================
        const keys = {};
        let mouseDown = false;

        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            // Q key for ability activation
            if (e.key.toLowerCase() === 'q' && gameState.playing) {
                activateAbility();
            }
        });
        window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousedown', () => mouseDown = true);
        window.addEventListener('mouseup', () => mouseDown = false);

        // ==================== COLLISION DETECTION ====================
        function checkCollision(position, radius) {
            for (let obstacle of obstacles) {
                const dist = Math.sqrt(
                    Math.pow(position.x - obstacle.position.x, 2) +
                    Math.pow(position.z - obstacle.position.z, 2)
                );
                if (dist < radius + obstacle.radius) {
                    return true;
                }
            }
            return false;
        }

        function getSpeedModifier(position) {
            let modifier = 1.0;
            
            // Check water
            for (let water of waterZones) {
                const dist = Math.sqrt(
                    Math.pow(position.x - water.position.x, 2) +
                    Math.pow(position.z - water.position.z, 2)
                );
                if (dist < water.radius) {
                    modifier = Math.min(modifier, 0.4);
                }
            }
            
            // Check bushes
            for (let bush of bushZones) {
                const dist = Math.sqrt(
                    Math.pow(position.x - bush.position.x, 2) +
                    Math.pow(position.z - bush.position.z, 2)
                );
                if (dist < bush.radius) {
                    modifier = Math.min(modifier, 0.6);
                }
            }
            
            return modifier;
        }

        // ==================== DAY/NIGHT CYCLE ====================
        function updateDayNight() {
            if (gameState.isPaused || gameState.isGameOver) return;
            
            const timeInSeconds = gameState.gameTime;
            const cycleDuration = 180; // 3 minutes for full day-night cycle
            const cycleProgress = (timeInSeconds % cycleDuration) / cycleDuration;
            
            let skyColor, fogColor, ambientIntensity, directionalIntensity;
            
            if (cycleProgress < 0.5) {
                // Day to dusk (0 - 0.5) - Marsh colors
                const t = cycleProgress * 2;
                skyColor = new THREE.Color().lerpColors(
                    new THREE.Color(0x6B8E7F), // Murky marsh day
                    new THREE.Color(0x1a2618), // Dark swamp night
                    t
                );
                fogColor = new THREE.Color().lerpColors(
                    new THREE.Color(0x8B9A8E), // Marsh fog
                    new THREE.Color(0x2a3a2a), // Night marsh fog
                    t
                );
                ambientIntensity = 0.6 - (t * 0.4);
                directionalIntensity = 0.8 - (t * 0.6);
            } else {
                // Night to dawn (0.5 - 1.0) - Marsh colors
                const t = (cycleProgress - 0.5) * 2;
                skyColor = new THREE.Color().lerpColors(
                    new THREE.Color(0x1a2618), // Dark swamp night
                    new THREE.Color(0x6B8E7F), // Murky marsh day
                    t
                );
                fogColor = new THREE.Color().lerpColors(
                    new THREE.Color(0x2a3a2a), // Night marsh fog
                    new THREE.Color(0x8B9A8E), // Marsh fog
                    t
                );
                ambientIntensity = 0.2 + (t * 0.4);
                directionalIntensity = 0.2 + (t * 0.6);
            }
            
            scene.background = skyColor;
            scene.fog.color = fogColor;
            ambientLight.intensity = ambientIntensity;
            directionalLight.intensity = directionalIntensity;
        }

        // ==================== GAME LOGIC ====================
        function updatePlayer(delta) {
            if (gameState.isPaused || gameState.isGameOver) return;

            let baseSpeed = 0.04; // Slower base speed
            const jumpForce = 1.25; // Increased jump force
            const gravity = -0.04;
            
            // Titan Turkey speed boost when ability active
            if (gameSettings.character === 'titanTurkey' && player.abilityActive) {
                baseSpeed = 0.08; // Double speed during charge!
            }

            // Get speed modifier based on terrain
            const speedModifier = getSpeedModifier(player.position);
            const moveSpeed = baseSpeed * speedModifier;

            // Store old position for collision rollback
            const oldPosition = player.position.clone();

            // Movement relative to look direction
            const forward = new THREE.Vector3(-Math.sin(player.lookAngle), 0, -Math.cos(player.lookAngle));
            const right = new THREE.Vector3(Math.cos(player.lookAngle), 0, -Math.sin(player.lookAngle));

            if (keys['w']) {
                player.velocity.add(forward.clone().multiplyScalar(moveSpeed));
            }
            if (keys['s']) {
                player.velocity.add(forward.clone().multiplyScalar(-moveSpeed));
            }
            if (keys['a']) {
                player.velocity.add(right.clone().multiplyScalar(-moveSpeed));
            }
            if (keys['d']) {
                player.velocity.add(right.clone().multiplyScalar(moveSpeed));
            }
            
            // Joystick input (mobile)
            if (joystickState.active) {
                player.velocity.add(forward.clone().multiplyScalar(-joystickState.y * moveSpeed));
                player.velocity.add(right.clone().multiplyScalar(joystickState.x * moveSpeed));
            }

            // Double Jump with wing flapping
            if (keys[' '] && player.jumpsUsed < player.maxJumps) {
                if (!player.lastJumpKey) {
                    player.velocity.y = jumpForce;
                    player.jumpsUsed++;
                    player.isJumping = true;
                    player.wingFlapTime = 10; // Wing flap duration
                    player.lastJumpKey = true;
                }
            } else {
                player.lastJumpKey = false;
            }

            // Wing flapping animation
            if (player.wingFlapTime > 0) {
                player.wingFlapTime--;
                const flapAngle = Math.sin(player.wingFlapTime * 0.8) * Math.PI / 3;
                player.mesh.userData.leftWing.rotation.z = -Math.PI / 6 - flapAngle;
                player.mesh.userData.rightWing.rotation.z = Math.PI / 6 + flapAngle;
            } else {
                player.mesh.userData.leftWing.rotation.z = -Math.PI / 6;
                player.mesh.userData.rightWing.rotation.z = Math.PI / 6;
            }

            // Apply velocity
            player.position.add(player.velocity);
            player.velocity.multiplyScalar(0.85);

            // Check collision and rollback if needed
            if (checkCollision(player.position, 0.6)) {
                player.position.copy(oldPosition);
                player.velocity.x *= -0.5;
                player.velocity.z *= -0.5;
            }

            // Gravity and terrain/structure collision
            player.velocity.y += gravity;
            const terrainY = getTerrainHeight(player.position.x, player.position.z);
            
            // Check if player is above a walkable structure (hut or tree)
            let groundY = terrainY;
            for (const obstacle of obstacles) {
                if (obstacle.walkableHeight) {
                    const dist2D = Math.sqrt(
                        Math.pow(player.position.x - obstacle.position.x, 2) +
                        Math.pow(player.position.z - obstacle.position.z, 2)
                    );
                    
                    // If player is within structure radius and above it, use structure height
                    if (dist2D < obstacle.radius && player.position.y >= obstacle.walkableHeight - 1) {
                        groundY = Math.max(groundY, obstacle.walkableHeight);
                    }
                }
            }
            
            if (player.position.y <= groundY + 1) {
                player.position.y = groundY + 1;
                player.velocity.y = 0;
                player.isJumping = false;
                player.jumpsUsed = 0; // Reset jumps when on ground
            }

            // Boundary
            const maxDist = 48;
            if (Math.abs(player.position.x) > maxDist) {
                player.position.x = Math.sign(player.position.x) * maxDist;
            }
            if (Math.abs(player.position.z) > maxDist) {
                player.position.z = Math.sign(player.position.z) * maxDist;
            }

            // Mouse look direction
            const lookDir = new THREE.Vector3(mouseX, 0, -mouseY).normalize();
            player.lookAngle = Math.atan2(lookDir.x, lookDir.z);

            // Update mesh
            player.mesh.position.copy(player.position);
            player.mesh.rotation.y = player.lookAngle;
            
            // Weapon swing animation
            if (player.weaponModel && player.weaponModel.userData.swingTime > 0) {
                player.weaponModel.userData.swingTime--;
                const t = player.weaponModel.userData.swingTime / 15;
                
                if (player.weaponModel.userData.swingType === 'arc') {
                    // Sword arc swing
                    const swingAngle = Math.sin((1 - t) * Math.PI) * Math.PI / 2;
                    player.weaponModel.rotation.z = -Math.PI / 4 + swingAngle;
                    player.weaponModel.rotation.y = Math.sin((1 - t) * Math.PI) * Math.PI / 3;
                } else if (player.weaponModel.userData.swingType === 'chop') {
                    // Hammer vertical chop
                    const chopAngle = Math.sin((1 - t) * Math.PI) * Math.PI / 1.5;
                    player.weaponModel.rotation.x = -chopAngle;
                }
            } else if (player.weaponModel) {
                // Reset to default position
                player.weaponModel.rotation.set(0, 0, -Math.PI / 4);
            }

            // Update injuries based on lives lost
            if (gameState.lives <= 2) {
                player.mesh.userData.body.material.color.setHex(0xFFCC00);
                
                // Blood trail when injured - drip every few frames
                player.bloodDripCounter++;
                const dripRate = gameState.lives === 1 ? 8 : 15; // More frequent when more injured
                if (player.bloodDripCounter >= dripRate) {
                    player.bloodDripCounter = 0;
                    const dripPos = player.position.clone();
                    dripPos.y += 0.3;
                    createBloodParticle(dripPos, 'spray');
                }
            }
            if (gameState.lives <= 1) {
                player.mesh.userData.head.material.color.setHex(0xFF8800);
                player.mesh.rotation.x = 0.1;
            }

            // Camera follow (third-person)
            const camDist = 12;
            const camHeight = 8;
            camera.position.x = player.position.x + Math.sin(player.lookAngle) * camDist;
            camera.position.y = player.position.y + camHeight;
            camera.position.z = player.position.z + Math.cos(player.lookAngle) * camDist;
            camera.lookAt(player.position);

            // Attack
            const weapon = weapons[gameState.currentWeapon];
            const now = Date.now();
            if (mouseDown && now - player.lastAttackTime > weapon.cooldown) {
                player.lastAttackTime = now;
                
                if (weapon.type === 'melee') {
                    meleeAttack();
                } else {
                    shootProjectile();
                }
            }
        }

        // ==================== ABILITY SYSTEM ====================
        function activateAbility() {
            const charType = gameSettings.character;
            const config = characterConfig[charType];
            if (!config.ability) return;
            
            const now = Date.now();
            if (now < player.abilityCooldownEnd) return;
            if (player.abilityActive) return;
            
            player.abilityActive = true;
            player.abilityEndTime = now + config.abilityDuration;
            player.abilityCooldownEnd = now + config.abilityCooldown;
            
            // Activate character-specific ability
            if (charType === 'titanTurkey') {
                // Show helmet
                if (player.mesh.userData.helmet) {
                    player.mesh.userData.helmet.visible = true;
                    player.mesh.userData.facemask.visible = true;
                }
            } else if (charType === 'kungPowChicken') {
                player.comboCount = 0;
            } else if (charType === 'mericaMallard') {
                // Eagle strike - instant damage in area
                executeEagleStrike();
                player.abilityActive = false;
            }
            
            updateAbilityUI();
        }
        
        function executeEagleStrike() {
            // Jump up and slam down
            player.velocity.y = 0.5;
            
            // Create eagle effect particles
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2),
                    new THREE.MeshBasicMaterial({ color: 0xFFD700 })
                );
                particle.position.copy(player.position);
                particle.position.x += Math.cos(angle) * 2;
                particle.position.z += Math.sin(angle) * 2;
                scene.add(particle);
                
                const vel = new THREE.Vector3(Math.cos(angle) * 0.2, 0.1, Math.sin(angle) * 0.2);
                bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 30 });
            }
            
            // Damage all enemies in range (reverse loop to safely remove)
            const strikeRadius = 8;
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = player.position.distanceTo(enemy.position);
                if (dist < strikeRadius) {
                    enemy.health -= 80;
                    if (enemy.health <= 0) {
                        for (let j = 0; j < 20; j++) {
                            createBloodParticle(enemy.position.clone(), 'large');
                        }
                        scene.remove(enemy.mesh);
                        enemies.splice(i, 1);
                        gameState.kills++;
                        trackKill('eagleStrike');
                        updateUI();
                    }
                }
            }
        }
        
        function updateAbilityState(delta) {
            const charType = gameSettings.character;
            const config = characterConfig[charType];
            const abilityBar = document.getElementById('ability-bar');
            const abilityPrompt = document.getElementById('ability-prompt');
            
            if (!abilityBar || !abilityPrompt) return;
            if (!gameState.playing) return;
            
            if (!config.ability) {
                abilityBar.style.display = 'none';
                abilityPrompt.style.display = 'none';
                return;
            }
            
            const now = Date.now();
            
            // Show ability bar for characters with abilities
            abilityBar.style.display = 'block';
            
            if (player.abilityActive && now >= player.abilityEndTime) {
                // Ability ended
                player.abilityActive = false;
                if (charType === 'titanTurkey') {
                    if (player.mesh.userData.helmet) {
                        player.mesh.userData.helmet.visible = false;
                        player.mesh.userData.facemask.visible = false;
                    }
                }
            }
            
            updateAbilityUI();
        }
        
        function updateAbilityUI() {
            const charType = gameSettings.character;
            const config = characterConfig[charType];
            if (!config.ability) return;
            
            const now = Date.now();
            const fill = document.getElementById('ability-fill');
            const text = document.getElementById('ability-text');
            const prompt = document.getElementById('ability-prompt');
            
            if (!fill || !text || !prompt) return;
            
            if (player.abilityActive) {
                // Show remaining duration
                const remaining = Math.max(0, player.abilityEndTime - now);
                const percent = (remaining / config.abilityDuration) * 100;
                fill.style.width = percent + '%';
                fill.style.background = 'linear-gradient(90deg, #FF0000, #FF6600)';
                text.textContent = 'ABILITY ACTIVE!';
                prompt.style.display = 'none';
            } else if (now < player.abilityCooldownEnd) {
                // Show cooldown
                const remaining = player.abilityCooldownEnd - now;
                const percent = 100 - (remaining / config.abilityCooldown) * 100;
                fill.style.width = percent + '%';
                fill.style.background = 'linear-gradient(90deg, #666, #888)';
                text.textContent = 'Cooldown: ' + Math.ceil(remaining / 1000) + 's';
                prompt.style.display = 'none';
            } else {
                // Ready
                fill.style.width = '100%';
                fill.style.background = 'linear-gradient(90deg, #FF6B00, #FFD700)';
                text.textContent = 'ABILITY READY - Press Q';
                prompt.style.display = 'block';
            }
        }

        function performMartialArtsCombo(attackDir) {
            const comboMoves = ['Jab!', 'Cross!', 'Kick!', 'Uppercut!', 'DRAGON STRIKE!'];
            const moveIndex = Math.min(player.comboCount - 1, comboMoves.length - 1);
            const damage = 30 + (player.comboCount * 15); // Increasing damage with combo
            const range = 2.5 + (player.comboCount * 0.3); // Increasing range
            
            // Create combo effect particles
            for (let i = 0; i < 5; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15),
                    new THREE.MeshBasicMaterial({ color: player.comboCount >= 5 ? 0xFF0000 : 0xFFFF00 })
                );
                particle.position.copy(player.position);
                particle.position.add(attackDir.clone().multiplyScalar(1 + i * 0.3));
                particle.position.y += 0.5;
                scene.add(particle);
                
                const vel = attackDir.clone().multiplyScalar(0.3);
                vel.y = Math.random() * 0.2;
                bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 15 });
            }
            
            // Hit enemies in range with combo damage
            const attackPos = player.position.clone().add(attackDir.clone().multiplyScalar(range / 2));
            enemies.forEach((enemy, idx) => {
                const dist = attackPos.distanceTo(enemy.position);
                if (dist < range) {
                    enemy.health -= damage;
                    if (enemy.health <= 0) {
                        for (let i = 0; i < 15; i++) {
                            createBloodParticle(enemy.position.clone(), 'large');
                        }
                        scene.remove(enemy.mesh);
                        enemies.splice(idx, 1);
                        gameState.kills++;
                        trackKill('martialArts');
                        updateUI();
                    }
                }
            });
        }

        function meleeAttack() {
            const charType = gameSettings.character;
            const weapon = weapons[gameState.currentWeapon];
            const attackDir = new THREE.Vector3(
                -Math.sin(player.lookAngle),
                0,
                -Math.cos(player.lookAngle)
            );
            
            // Kung Pow Chicken combo system when ability active
            if (charType === 'kungPowChicken' && player.abilityActive) {
                player.comboCount++;
                performMartialArtsCombo(attackDir);
                return;
            }
            
            // Weapon swing animation
            if (player.weaponModel) {
                if (gameState.currentWeapon === 'sword') {
                    // Sword wide arc swing animation
                    player.weaponModel.userData.swingTime = 15;
                    player.weaponModel.userData.swingType = 'arc';
                } else if (gameState.currentWeapon === 'hammer') {
                    // Hammer vertical chop animation
                    player.weaponModel.userData.swingTime = 20;
                    player.weaponModel.userData.swingType = 'chop';
                }
            }
            
            // Create dramatic wind streak effects for melee weapons
            if (gameState.currentWeapon === 'sword' || gameState.currentWeapon === 'hammer') {
                const streakCount = gameState.currentWeapon === 'sword' ? 8 : 5;
                for (let i = 0; i < streakCount; i++) {
                    const offset = player.position.clone();
                    offset.y += 1 + (Math.random() - 0.5) * 0.4;
                    
                    // Spread streaks in arc for sword, forward for hammer
                    let dir = attackDir.clone();
                    if (gameState.currentWeapon === 'sword') {
                        const spread = (i / streakCount - 0.5) * 1.5;
                        dir = new THREE.Vector3(
                            -Math.sin(player.lookAngle + spread),
                            (Math.random() - 0.5) * 0.2,
                            -Math.cos(player.lookAngle + spread)
                        ).normalize();
                    }
                    
                    offset.add(dir.clone().multiplyScalar(1 + i * 0.3));
                    createWindStreak(offset, dir, gameState.currentWeapon);
                }
            }
            
            // Better hitbox detection - larger multipliers and more forgiving angles
            let hitboxMultiplier = 2.5; // Base multiplier for all melee
            if (gameState.currentWeapon === 'sword') hitboxMultiplier = 1.6;
            if (gameState.currentWeapon === 'hammer') hitboxMultiplier = 1.4;
            
            enemies.forEach((enemy, idx) => {
                const dist = player.position.distanceTo(enemy.position);
                if (dist < weapon.range * hitboxMultiplier) {
                    const toEnemy = enemy.position.clone().sub(player.position).normalize();
                    const angleThreshold = gameState.currentWeapon === 'sword' ? 0.2 : 0.4; // Lower = wider cone
                    if (attackDir.dot(toEnemy) > angleThreshold) {
                        enemy.health -= weapon.damage;
                        if (enemy.health <= 0) {
                            // Enhanced graphic gore effect
                            // Large splatter burst
                            for (let i = 0; i < 30; i++) {
                                createBloodParticle(enemy.position.clone(), Math.random() < 0.3 ? 'large' : 'normal');
                            }
                            // Blood spray in attack direction
                            for (let i = 0; i < 10; i++) {
                                const spray = enemy.position.clone();
                                spray.add(attackDir.clone().multiplyScalar(i * 0.3));
                                createBloodParticle(spray, 'spray');
                            }
                            scene.remove(enemy.mesh);
                            enemies.splice(idx, 1);
                            gameState.kills++;
                            trackKill(gameState.currentWeapon);
                            updateUI();
                        }
                    }
                }
            });
        }

        function shootProjectile() {
            const weapon = weapons[gameState.currentWeapon];
            const direction = new THREE.Vector3(
                -Math.sin(player.lookAngle),
                weapon.type === 'arc' ? 0.3 : 0,
                -Math.cos(player.lookAngle)
            ).normalize();
            
            const start = player.position.clone();
            start.y += 1;
            
            createProjectile(start, direction, weapon, true, gameState.currentWeapon);
        }

        function updateEnemies(delta) {
            if (gameState.isPaused || gameState.isGameOver) return;

            const now = Date.now();
            
            // Titan Turkey ram damage check
            if (gameSettings.character === 'titanTurkey' && player.abilityActive) {
                const ramRadius = 1.5;
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const dist = player.position.distanceTo(enemy.position);
                    if (dist < ramRadius) {
                        enemy.health -= 60;
                        // Knockback effect
                        const knockDir = enemy.position.clone().sub(player.position).normalize();
                        enemy.position.add(knockDir.multiplyScalar(2));
                        enemy.mesh.position.copy(enemy.position);
                        
                        if (enemy.health <= 0) {
                            for (let j = 0; j < 20; j++) {
                                createBloodParticle(enemy.position.clone(), 'large');
                            }
                            scene.remove(enemy.mesh);
                            enemies.splice(i, 1);
                            gameState.kills++;
                            trackKill('helmetCharge');
                            updateUI();
                        }
                    }
                }
            }
            
            enemies.forEach((enemy, idx) => {
                // Move toward player
                const toPlayer = player.position.clone().sub(enemy.position);
                const dist = toPlayer.length();
                
                if (dist > 5) {
                    toPlayer.normalize().multiplyScalar(0.06);
                    enemy.position.add(toPlayer);
                    
                    // Keep on terrain
                    const terrainY = getTerrainHeight(enemy.position.x, enemy.position.z);
                    enemy.position.y = terrainY + 1;
                    
                    enemy.mesh.position.copy(enemy.position);
                    enemy.mesh.lookAt(player.position);
                }
                
                // Shoot at player with improved accuracy
                if (dist < 30 && now - enemy.lastShootTime > enemy.shootCooldown) {
                    enemy.lastShootTime = now;
                    const shootDir = toPlayer.normalize();
                    const start = enemy.position.clone();
                    start.y += 1;
                    createEnemyProjectile(start, shootDir);
                }
            });

            // Spawn enemies
            if (now - gameState.lastSpawnTime > gameState.enemySpawnRate) {
                gameState.lastSpawnTime = now;
                spawnEnemy();
                gameState.enemySpawnRate = Math.max(1000, gameState.enemySpawnRate - 50);
            }
            
            // Spawn trucks occasionally (every 15-25 seconds)
            if (now - lastTruckSpawnTime > 15000 + Math.random() * 10000 && vehicles.length < 3) {
                lastTruckSpawnTime = now;
                spawnTruckWithDriver();
            }
        }

        function updateVehicles(delta) {
            if (gameState.isPaused || gameState.isGameOver) return;
            
            const now = Date.now();
            
            vehicles.forEach((vehicle, vIdx) => {
                if (gameState.vehicle === vehicle) {
                    // Player is driving this vehicle
                    const driveSpeed = 0.15;
                    const turnSpeed = 0.03;
                    
                    // Keyboard controls
                    if (keys['w']) {
                        vehicle.velocity.x -= Math.sin(vehicle.rotation) * driveSpeed;
                        vehicle.velocity.z -= Math.cos(vehicle.rotation) * driveSpeed;
                    }
                    if (keys['s']) {
                        vehicle.velocity.x += Math.sin(vehicle.rotation) * driveSpeed * 0.5;
                        vehicle.velocity.z += Math.cos(vehicle.rotation) * driveSpeed * 0.5;
                    }
                    if (keys['a']) vehicle.rotation += turnSpeed;
                    if (keys['d']) vehicle.rotation -= turnSpeed;
                    
                    // Joystick controls (mobile)
                    if (joystickState.active) {
                        if (joystickState.y < -0.2) {
                            vehicle.velocity.x -= Math.sin(vehicle.rotation) * driveSpeed * Math.abs(joystickState.y);
                            vehicle.velocity.z -= Math.cos(vehicle.rotation) * driveSpeed * Math.abs(joystickState.y);
                        }
                        if (joystickState.y > 0.2) {
                            vehicle.velocity.x += Math.sin(vehicle.rotation) * driveSpeed * 0.5 * joystickState.y;
                            vehicle.velocity.z += Math.cos(vehicle.rotation) * driveSpeed * 0.5 * joystickState.y;
                        }
                        if (joystickState.x < -0.2) vehicle.rotation += turnSpeed * Math.abs(joystickState.x);
                        if (joystickState.x > 0.2) vehicle.rotation -= turnSpeed * joystickState.x;
                    }
                    
                    vehicle.position.add(vehicle.velocity);
                    vehicle.velocity.multiplyScalar(0.92);
                    
                    const terrainY = getTerrainHeight(vehicle.position.x, vehicle.position.z);
                    vehicle.position.y = terrainY;
                    
                    vehicle.mesh.position.copy(vehicle.position);
                    vehicle.mesh.rotation.y = vehicle.rotation;
                    
                    // Player follows vehicle
                    player.position.copy(vehicle.position);
                    player.position.y += 3;
                    player.mesh.position.copy(player.position);
                    player.mesh.visible = false;
                    
                    // Run over enemies!
                    enemies.forEach((enemy, idx) => {
                        const dist = vehicle.position.distanceTo(enemy.position);
                        if (dist < 3) {
                            for (let i = 0; i < 20; i++) {
                                createBloodParticle(enemy.position.clone(), Math.random() < 0.3 ? 'large' : 'normal');
                            }
                            scene.remove(enemy.mesh);
                            enemies.splice(idx, 1);
                            gameState.kills++;
                            trackKill('vehicle');
                            sessionStats.vehicleKills++;
                            updateUI();
                        }
                    });
                    
                    // Track vehicle time
                    sessionStats.vehicleTime += delta / 1000;
                    
                    // Exit vehicle with E
                    if (keys['e'] && !vehicle.exitCooldown) {
                        gameState.vehicle = null;
                        player.mesh.visible = true;
                        player.position.x = vehicle.position.x + 3;
                        player.position.z = vehicle.position.z;
                        player.position.y = getTerrainHeight(player.position.x, player.position.z) + 1;
                        player.mesh.position.copy(player.position);
                        vehicle.exitCooldown = true;
                        setTimeout(() => vehicle.exitCooldown = false, 500);
                    }
                } else if (vehicle.hasDriver) {
                    // AI drives toward player
                    const toPlayer = player.position.clone().sub(vehicle.position);
                    const dist = toPlayer.length();
                    
                    if (dist > 10) {
                        const targetAngle = Math.atan2(-toPlayer.x, -toPlayer.z);
                        let angleDiff = targetAngle - vehicle.rotation;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        vehicle.rotation += Math.sign(angleDiff) * Math.min(0.02, Math.abs(angleDiff));
                        
                        vehicle.velocity.x -= Math.sin(vehicle.rotation) * 0.08;
                        vehicle.velocity.z -= Math.cos(vehicle.rotation) * 0.08;
                    }
                    
                    vehicle.position.add(vehicle.velocity);
                    vehicle.velocity.multiplyScalar(0.95);
                    
                    const terrainY = getTerrainHeight(vehicle.position.x, vehicle.position.z);
                    vehicle.position.y = terrainY;
                    
                    vehicle.mesh.position.copy(vehicle.position);
                    vehicle.mesh.rotation.y = vehicle.rotation;
                    
                    // Driver shoots
                    if (dist < 35 && now - vehicle.driver.lastShootTime > vehicle.driver.shootCooldown) {
                        vehicle.driver.lastShootTime = now;
                        const shootDir = toPlayer.normalize();
                        const start = vehicle.position.clone();
                        start.y += 3;
                        createEnemyProjectile(start, shootDir);
                    }
                } else {
                    // Empty vehicle - player can enter with E
                    const dist = player.position.distanceTo(vehicle.position);
                    if (dist < 4 && keys['e'] && !gameState.vehicle && !vehicle.enterCooldown) {
                        gameState.vehicle = vehicle;
                        vehicle.enterCooldown = true;
                        setTimeout(() => vehicle.enterCooldown = false, 500);
                    }
                }
            });
        }

        function updateAlligators(delta) {
            if (gameState.isPaused || gameState.isGameOver) return;
            
            const now = Date.now();
            
            alligators.forEach(gator => {
                // Patrol around home position
                const toHome = gator.homePosition.clone().sub(new THREE.Vector3(gator.position.x, 0, gator.position.z));
                const homeDistance = toHome.length();
                
                // Wander if too far from home
                if (homeDistance > gator.patrolRadius) {
                    toHome.normalize().multiplyScalar(0.03);
                    gator.position.x += toHome.x;
                    gator.position.z += toHome.z;
                } else {
                    // Slow patrol
                    gator.angle += 0.01;
                    gator.position.x = gator.homePosition.x + Math.cos(gator.angle) * 2;
                    gator.position.z = gator.homePosition.z + Math.sin(gator.angle) * 2;
                }
                
                // Keep on terrain
                const terrainY = getTerrainHeight(gator.position.x, gator.position.z);
                gator.position.y = terrainY;
                
                // Update mesh
                gator.mesh.position.copy(gator.position);
                gator.mesh.rotation.y = gator.angle;
                
                // Check if player is close enough to bite
                const toPlayer = player.position.clone().sub(gator.position);
                const distToPlayer = toPlayer.length();
                
                if (distToPlayer < 2.5 && now - gator.lastBiteTime > gator.biteCooldown) {
                    gator.lastBiteTime = now;
                    gameState.lives--;
                    
                    // Blood splash when bitten
                    for (let i = 0; i < 10; i++) {
                        createBloodParticle(player.position.clone(), Math.random() < 0.5 ? 'large' : 'normal');
                    }
                    
                    updateUI();
                    if (gameState.lives <= 0) {
                        gameOver();
                    }
                }
            });
        }

        function updateProjectiles(delta) {

            /*if (proj.fromPlayer) {
            enemies.forEach((enemy, idx) => {
            const dist = proj.mesh.position.distanceTo(enemy.position);
            const alreadyHit = proj.hitEnemies && proj.hitEnemies.includes(enemy);


            // Adjustable hit radius by weapon type
            let hitRadius = 1.7;
            if (gameState.currentWeapon === 'rifle') hitRadius = 2.2;
            if (gameState.currentWeapon === 'machineGun') hitRadius = 1.5;


            if (dist < hitRadius && !alreadyHit) {
            enemy.health -= proj.damage;


            if (proj.canPierce) {
            proj.hitEnemies.push(enemy);
            }


            if (enemy.health <= 0) {
            for (let i = 0; i < 15; i++) {
            createBloodParticle(enemy.position.clone());
            }
            scene.remove(enemy.mesh);
            enemies.splice(idx, 1);
            gameState.kills++;
            trackKill(proj.weaponType || 'projectile');
            updateUI();
            }


            if (!proj.canPierce) {
            proj.lifetime = 0;
            }
            }
            });
            }*/
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                if (proj.isArc) {
                    proj.velocity.y -= 0.015;
                }
                
                proj.mesh.position.add(proj.velocity);
                proj.lifetime--;
                
                // Keep on terrain for arc projectiles
                const terrainY = getTerrainHeight(proj.mesh.position.x, proj.mesh.position.z);
                
                // Check obstacle collisions (trees and hut)
                let hitObstacle = false;
                for (const obstacle of obstacles) {
                    const dist = new THREE.Vector2(
                        proj.mesh.position.x - obstacle.position.x,
                        proj.mesh.position.z - obstacle.position.z
                    ).length();
                    if (dist < obstacle.radius) {
                        hitObstacle = true;
                        break;
                    }
                }
                
                if (hitObstacle) {
                    proj.lifetime = 0;
                }
                
                // Check collisions
                if (proj.fromPlayer) {
                    // Larger hit radius for better accuracy
                    let hitRadius = 2.0;
                    if (proj.weaponType === 'rifle') hitRadius = 2.5;
                    if (proj.weaponType === 'machineGun') hitRadius = 1.8;
                    if (proj.weaponType === 'cannon') hitRadius = 3.0;
                    if (proj.weaponType === 'catapult') hitRadius = 2.5;
                    
                    enemies.forEach((enemy, idx) => {
                        const dist = proj.mesh.position.distanceTo(enemy.position);
                        const alreadyHit = proj.hitEnemies && proj.hitEnemies.includes(enemy);
                        
                        if (dist < hitRadius && !alreadyHit) {
                            enemy.health -= proj.damage;
                            
                            if (proj.canPierce) {
                                proj.hitEnemies.push(enemy);
                            }
                            
                            if (enemy.health <= 0) {
                                for (let i = 0; i < 15; i++) {
                                    createBloodParticle(enemy.position.clone());
                                }
                                scene.remove(enemy.mesh);
                                enemies.splice(idx, 1);
                                gameState.kills++;
                                trackKill(proj.weaponType || gameState.currentWeapon);
                                updateUI();
                            }
                            
                            if (!proj.canPierce) {
                                proj.lifetime = 0;
                            }
                        }
                    });
                    
                    // Hit vehicle drivers
                    vehicles.forEach((vehicle, vIdx) => {
                        if (vehicle.hasDriver) {
                            const driverPos = vehicle.position.clone();
                            driverPos.y += 2.5;
                            const dist = proj.mesh.position.distanceTo(driverPos);
                            const alreadyHit = proj.hitVehicles && proj.hitVehicles.includes(vehicle);
                            
                            if (dist < hitRadius && !alreadyHit) {
                                vehicle.driver.health -= proj.damage;
                                
                                if (proj.canPierce) {
                                    if (!proj.hitVehicles) proj.hitVehicles = [];
                                    proj.hitVehicles.push(vehicle);
                                }
                                
                                if (vehicle.driver.health <= 0) {
                                    for (let i = 0; i < 20; i++) {
                                        createBloodParticle(driverPos, Math.random() < 0.3 ? 'large' : 'normal');
                                    }
                                    vehicle.mesh.remove(vehicle.driver.mesh);
                                    vehicle.hasDriver = false;
                                    gameState.kills++;
                                    trackKill(proj.weaponType || gameState.currentWeapon);
                                    updateUI();
                                }
                                
                                if (!proj.canPierce) {
                                    proj.lifetime = 0;
                                }
                            }
                        }
                    });
                } else {
                    // Enemy projectile hitting player
                    const distToPlayer = proj.mesh.position.distanceTo(player.position);
                    if (distToPlayer < 1.2) {
                        gameState.lives--;
                        updateUI();
                        proj.lifetime = 0;
                        
                        // Blood effect on player
                        for (let i = 0; i < 5; i++) {
                            createBloodParticle(player.position.clone());
                        }
                        
                        if (gameState.lives <= 0) {
                            gameOver();
                        }
                    }
                }
                
                // Catapult ground blast radius
                if (proj.weaponType === 'catapult' && proj.mesh.position.y <= terrainY + 0.5) {
                    const blastRadius = 6;
                    // Create explosion effect
                    for (let j = 0; j < 15; j++) {
                        const particle = new THREE.Mesh(
                            new THREE.SphereGeometry(0.3, 6, 6),
                            new THREE.MeshLambertMaterial({ color: 0xFF6600 })
                        );
                        particle.position.copy(proj.mesh.position);
                        scene.add(particle);
                        const vel = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.5,
                            Math.random() * 0.4,
                            (Math.random() - 0.5) * 0.5
                        );
                        bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 30 });
                    }
                    
                    // Damage all enemies in blast radius
                    enemies.forEach((enemy, idx) => {
                        const dist = proj.mesh.position.distanceTo(enemy.position);
                        if (dist < blastRadius) {
                            const damage = proj.damage * (1 - dist / blastRadius);
                            enemy.health -= damage;
                            if (enemy.health <= 0) {
                                for (let k = 0; k < 20; k++) {
                                    createBloodParticle(enemy.position.clone(), 'large');
                                }
                                scene.remove(enemy.mesh);
                                enemies.splice(idx, 1);
                                gameState.kills++;
                                trackKill('catapult');
                                updateUI();
                            }
                        }
                    });
                    proj.lifetime = 0;
                }
                
                if (proj.lifetime <= 0 || proj.mesh.position.y < terrainY) {
                    scene.remove(proj.mesh);
                    projectiles.splice(i, 1);
                }
            }
        }

        function updateBloodParticles(delta) {
            for (let i = bloodParticles.length - 1; i >= 0; i--) {
                const particle = bloodParticles[i];
                
                particle.velocity.y -= 0.02;
                particle.mesh.position.add(particle.velocity);
                particle.lifetime--;
                
                const terrainY = getTerrainHeight(particle.mesh.position.x, particle.mesh.position.z);
                if (particle.mesh.position.y <= terrainY) {
                    particle.mesh.position.y = terrainY + 0.05;
                    particle.velocity.multiplyScalar(0.3);
                    particle.mesh.scale.multiplyScalar(0.95);
                }
                
                if (particle.lifetime <= 0 || particle.mesh.scale.x < 0.1) {
                    scene.remove(particle.mesh);
                    bloodParticles.splice(i, 1);
                }
            }
        }

        function updateWindStreaks(delta) {
            for (let i = windStreaks.length - 1; i >= 0; i--) {
                const streak = windStreaks[i];
                
                // Move forward and fade out
                streak.mesh.position.add(streak.velocity);
                streak.lifetime--;
                
                // Fade out opacity and scale
                const fadeProgress = streak.lifetime / 12;
                streak.mesh.material.opacity = streak.initialOpacity * fadeProgress;
                streak.mesh.scale.multiplyScalar(0.92);
                
                if (streak.lifetime <= 0) {
                    scene.remove(streak.mesh);
                    windStreaks.splice(i, 1);
                }
            }
        }

        function updatePickups(delta) {
            pickups.forEach((pickup, idx) => {
                pickup.rotation += 0.02;
                pickup.mesh.rotation.y = pickup.rotation;
                pickup.mesh.position.y += Math.sin(pickup.rotation * 2) * 0.01;
                
                const dist = player.position.distanceTo(pickup.mesh.position);
                if (dist < 1.5) {
                    gameState.currentWeapon = pickup.weaponType;
                    updatePlayerWeapon();
                    updateUI();
                    scene.remove(pickup.mesh);
                    pickups.splice(idx, 1);
                    
                    // Spawn new pickup
                    setTimeout(() => {
                        createPickup(weaponTypes[Math.floor(Math.random() * weaponTypes.length)]);
                    }, 5000);
                }
            });
        }

        function updateUI() {
            document.getElementById('kills').textContent = gameState.kills;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('time').textContent = Math.floor(gameState.gameTime);
            document.getElementById('current-weapon').textContent = 
                gameState.currentWeapon.charAt(0).toUpperCase() + gameState.currentWeapon.slice(1);
        }

        function gameOver() {
            gameState.isGameOver = true;
            const finalScore = gameState.kills * 100 + Math.floor(gameState.gameTime);
            document.getElementById('final-score').textContent = finalScore;
            document.getElementById('game-over').style.display = 'block';
            
            // Record stats
            sessionStats.timeAlive = Math.floor(gameState.gameTime);
            recordGameEnd(finalScore, sessionStats.timeAlive);
        }

        function resetGame() {
            gameState.kills = 0;
            gameState.lives = 3;
            gameState.currentWeapon = 'fists';
            gameState.isGameOver = false;
            gameState.isPaused = false;
            gameState.enemySpawnRate = 3000;
            gameState.lastSpawnTime = Date.now();
            gameState.gameStartTime = Date.now();
            gameState.gameTime = 0;
            
            player.position.set(8, getTerrainHeight(8, 0) + 1, 0); // Start outside hut
            player.velocity.set(0, 0, 0);
            player.lookAngle = 0;
            
            // Reset ability state
            player.abilityActive = false;
            player.abilityEndTime = 0;
            player.abilityCooldownEnd = 0;
            player.comboCount = 0;
            
            // Recreate character mesh with selected character
            scene.remove(player.mesh);
            player.mesh = createCharacter(gameSettings.character);
            player.mesh.position.copy(player.position);
            scene.add(player.mesh);
            
            updatePlayerWeapon();
            
            enemies.forEach(e => scene.remove(e.mesh));
            enemies.length = 0;
            
            alligators.forEach(g => scene.remove(g.mesh));
            alligators.length = 0;
            
            vehicles.forEach(v => scene.remove(v.mesh));
            vehicles.length = 0;
            gameState.vehicle = null;
            lastTruckSpawnTime = Date.now();
            player.mesh.visible = true;
            
            // Respawn alligators
            for (let i = 0; i < 8; i++) {
                const waterZone = waterZones[Math.floor(Math.random() * waterZones.length)];
                const angle = Math.random() * Math.PI * 2;
                const dist = waterZone.radius + 1;
                const x = waterZone.position.x + Math.cos(angle) * dist;
                const z = waterZone.position.z + Math.sin(angle) * dist;
                
                const gator = {
                    mesh: createAlligator(),
                    position: new THREE.Vector3(x, getTerrainHeight(x, z), z),
                    angle: angle,
                    homePosition: new THREE.Vector3(x, 0, z),
                    patrolRadius: 5,
                    lastBiteTime: 0,
                    biteCooldown: 2000
                };
                
                gator.mesh.position.copy(gator.position);
                gator.mesh.rotation.y = angle;
                scene.add(gator.mesh);
                alligators.push(gator);
            }
            
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles.length = 0;
            
            bloodParticles.forEach(p => scene.remove(p.mesh));
            bloodParticles.length = 0;
            
            windStreaks.forEach(w => scene.remove(w.mesh));
            windStreaks.length = 0;
            
            document.getElementById('game-over').style.display = 'none';
            updateUI();
        }

        // ==================== EVENT LISTENERS ====================
        // Joystick logic
        const joystickState = { active: false, x: 0, y: 0 };
        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');
        
        function updateJoystick(touch) {
            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const maxDist = rect.width / 2 - 25;
            
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dy = (dy / dist) * maxDist;
            }
            
            joystickThumb.style.left = `calc(50% + ${dx}px)`;
            joystickThumb.style.top = `calc(50% + ${dy}px)`;
            
            joystickState.x = dx / maxDist;
            joystickState.y = dy / maxDist;
        }
        
        function resetJoystick() {
            joystickState.active = false;
            joystickState.x = 0;
            joystickState.y = 0;
            joystickThumb.style.left = '50%';
            joystickThumb.style.top = '50%';
        }
        
        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickState.active = true;
            updateJoystick(e.touches[0]);
        });
        
        joystickContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (joystickState.active) {
                updateJoystick(e.touches[0]);
            }
        });
        
        joystickContainer.addEventListener('touchend', (e) => {
            e.preventDefault();
            resetJoystick();
        });
        
        joystickContainer.addEventListener('touchcancel', (e) => {
            resetJoystick();
        });

        // Mobile button logic
        document.getElementById('mobile-jump').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.isPaused && !gameState.isGameOver && player.jumpsUsed < 2) {
                player.velocity.y = 0.2;
                player.jumpsUsed++;
                player.isJumping = true;
            }
        });

        document.getElementById('mobile-attack').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.isPaused && !gameState.isGameOver) {
                const weapon = weapons[gameState.currentWeapon];
                if (weapon.type === 'melee') {
                    meleeAttack();
                } else {
                    shootProjectile();
                }
            }
        });

        // ==================== MENU NAVIGATION ====================
        function showMenu() {
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('settings-page').style.display = 'none';
            document.getElementById('stats-page').style.display = 'none';
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('quit-btn').style.display = 'none';
            document.getElementById('ability-bar').style.display = 'none';
            document.getElementById('ability-prompt').style.display = 'none';
        }
        
        function hideAllMenus() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('settings-page').style.display = 'none';
            document.getElementById('stats-page').style.display = 'none';
        }
        
        function startGame() {
            hideAllMenus();
            resetSessionStats();
            document.getElementById('quit-btn').style.display = 'block';
            
            // Apply difficulty settings
            const diff = difficultyConfig[gameSettings.difficulty];
            gameState.enemySpawnRate = diff.spawnRate;
            
            // Apply input method
            if (gameSettings.inputMethod === 'mobile') {
                document.getElementById('mobile-controls').style.display = 'flex';
            } else {
                document.getElementById('mobile-controls').style.display = 'none';
            }
            
            gameState.isPaused = false;
            gameState.gameStartTime = Date.now();
            gameState.lastSpawnTime = Date.now();
            lastTruckSpawnTime = Date.now();
        }
        
        // Draw score graph
        function drawScoreGraph() {
            const canvas = document.getElementById('score-graph');
            const ctx = canvas.getContext('2d');
            const games = allTimeStats.games;
            
            // Set canvas size
            canvas.width = canvas.parentElement.clientWidth - 40;
            canvas.height = 200;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (games.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No games played yet!', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const padding = 40;
            const graphWidth = canvas.width - padding * 2;
            const graphHeight = canvas.height - padding * 2;
            
            const maxScore = Math.max(...games.map(g => g.score), 100);
            
            // Draw axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            // Draw grid lines
            ctx.strokeStyle = '#333';
            for (let i = 0; i <= 4; i++) {
                const y = padding + (graphHeight / 4) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();
                
                ctx.fillStyle = '#666';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(Math.round(maxScore - (maxScore / 4) * i), padding - 5, y + 3);
            }
            
            // Draw line graph
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            games.forEach((game, i) => {
                const x = padding + (graphWidth / Math.max(games.length - 1, 1)) * i;
                const y = canvas.height - padding - (game.score / maxScore) * graphHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#66BB6A';
            games.forEach((game, i) => {
                const x = padding + (graphWidth / Math.max(games.length - 1, 1)) * i;
                const y = canvas.height - padding - (game.score / maxScore) * graphHeight;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function populateStats() {
            const grid = document.getElementById('stats-grid');
            const stats = allTimeStats;
            const games = stats.games;
            
            if (games.length === 0) {
                grid.innerHTML = '<div class="no-stats">Play some games to see your statistics!</div>';
                return;
            }
            
            const highScore = Math.max(...games.map(g => g.score));
            const avgScore = Math.round(games.reduce((sum, g) => sum + g.score, 0) / games.length);
            const totalGames = games.length;
            const totalTime = Math.floor(stats.totalTime);
            const vehicleTime = Math.floor(stats.totalVehicleTime);
            
            // Find favorite weapon
            let favoriteWeapon = 'None';
            let maxKills = 0;
            for (const [weapon, kills] of Object.entries(stats.weaponKills)) {
                if (kills > maxKills) {
                    maxKills = kills;
                    favoriteWeapon = weapon.charAt(0).toUpperCase() + weapon.slice(1);
                }
            }
            
            grid.innerHTML = `
                <div class="stat-card highlight">
                    <div class="stat-value">${highScore}</div>
                    <div class="stat-label">High Score</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgScore}</div>
                    <div class="stat-label">Average Score</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.totalKills}</div>
                    <div class="stat-label">Total Hunters Killed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${totalGames}</div>
                    <div class="stat-label">Games Played</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${Math.floor(totalTime / 60)}m ${totalTime % 60}s</div>
                    <div class="stat-label">Total Time Played</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${Math.floor(vehicleTime / 60)}m ${vehicleTime % 60}s</div>
                    <div class="stat-label">Time in Vehicles</div>
                </div>
                <div class="stat-card highlight">
                    <div class="stat-value">${favoriteWeapon}</div>
                    <div class="stat-label">Favorite Weapon</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${Math.round(totalTime / Math.max(totalGames, 1))}s</div>
                    <div class="stat-label">Avg Survival Time</div>
                </div>
            `;
        }
        
        // Initialize settings UI
        function initSettingsUI() {
            // Set active difficulty button
            document.querySelectorAll('.diff-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.diff === gameSettings.difficulty);
            });
            
            // Set active input button
            document.querySelectorAll('.input-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.input === gameSettings.inputMethod);
            });
            
            // Set active character button
            document.querySelectorAll('.char-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.char === gameSettings.character);
            });
            
            // Update character description
            const config = characterConfig[gameSettings.character];
            document.getElementById('char-description').textContent = config ? config.description : '';
        }
        
        // Menu button handlers
        document.getElementById('play-btn').addEventListener('click', () => {
            resetGame();
            startGame();
        });
        
        document.getElementById('settings-menu-btn').addEventListener('click', () => {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('settings-page').style.display = 'flex';
            initSettingsUI();
        });
        
        document.getElementById('stats-btn').addEventListener('click', () => {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('stats-page').style.display = 'flex';
            populateStats();
            setTimeout(drawScoreGraph, 50);
        });
        
        document.getElementById('settings-back-btn').addEventListener('click', showMenu);
        document.getElementById('stats-back-btn').addEventListener('click', showMenu);
        
        // Difficulty buttons
        document.querySelectorAll('.diff-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameSettings.difficulty = btn.dataset.diff;
                saveSettings();
            });
        });
        
        // Input method buttons
        document.querySelectorAll('.input-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.input-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameSettings.inputMethod = btn.dataset.input;
                saveSettings();
            });
        });
        
        // Character selection buttons
        document.querySelectorAll('.char-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.char-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameSettings.character = btn.dataset.char;
                const config = characterConfig[gameSettings.character];
                document.getElementById('char-description').textContent = config ? config.description : '';
                saveSettings();
            });
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            resetGame();
            startGame();
        });

        document.getElementById('quit-btn').addEventListener('click', () => {
            gameState.isPaused = true;
            
            // Reset game state without showing game over
            gameState.kills = 0;
            gameState.lives = 3;
            gameState.currentWeapon = 'fists';
            gameState.enemySpawnRate = 3000;
            player.position.set(8, 1, 0);
            player.velocity.set(0, 0, 0);
            player.isJumping = false;
            player.jumpsUsed = 0;
            player.bloodDripCounter = 0;
            
            // Reset player appearance
            player.mesh.userData.body.material.color.setHex(0xFFFF00);
            player.mesh.userData.head.material.color.setHex(0xFFFF00);
            player.mesh.rotation.x = 0;
            
            updatePlayerWeapon();
            
            enemies.forEach(e => scene.remove(e.mesh));
            enemies.length = 0;
            
            alligators.forEach(g => scene.remove(g.mesh));
            alligators.length = 0;
            
            vehicles.forEach(v => scene.remove(v.mesh));
            vehicles.length = 0;
            gameState.vehicle = null;
            lastTruckSpawnTime = 0;
            player.mesh.visible = true;
            
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles.length = 0;
            
            bloodParticles.forEach(p => scene.remove(p.mesh));
            bloodParticles.length = 0;
            
            windStreaks.forEach(w => scene.remove(w.mesh));
            windStreaks.length = 0;
            
            updateUI();
            showMenu();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==================== GAME LOOP ====================
        let lastTime = Date.now();

        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            const delta = now - lastTime;
            lastTime = now;
            
            if (!gameState.isPaused && !gameState.isGameOver) {
                gameState.gameTime = (now - gameState.gameStartTime) / 1000;
            }
            
            updateDayNight();
            updatePlayer(delta);
            updateAbilityState(delta);
            updateEnemies(delta);
            updateAlligators(delta);
            updateVehicles(delta);
            updateProjectiles(delta);
            updateBloodParticles(delta);
            updateWindStreaks(delta);
            updatePickups(delta);
            
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>