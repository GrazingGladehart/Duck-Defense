<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duck Defense 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            overflow: hidden;
            background: #87CEEB;
            cursor: crosshair;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 10;
        }

        #weapon-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.6);
            padding: 15px 25px;
            border-radius: 10px;
            color: white;
            font-size: 20px;
            text-shadow: 1px 1px 2px black;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 5;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 3px black;
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 40px;
            border-radius: 20px;
            color: white;
            text-align: center;
            display: none;
            z-index: 20;
        }

        #game-over h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff4444;
        }

        #game-over button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
        }

        #game-over button:hover {
            background: #45a049;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 40px;
            border-radius: 20px;
            color: white;
            text-align: center;
            z-index: 20;
        }

        #instructions h2 {
            margin-bottom: 20px;
            color: #FFD700;
        }

        #instructions ul {
            text-align: left;
            margin: 20px 0;
            list-style-position: inside;
        }

        #instructions li {
            margin: 10px 0;
        }

        #instructions button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
        }

        #quit-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 30px;
            font-size: 18px;
            background: rgba(220, 20, 60, 0.8);
            color: white;
            border: 2px solid white;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            pointer-events: auto;
            z-index: 15;
            display: none;
        }

        #quit-btn:hover {
            background: rgba(180, 20, 60, 0.9);
        }

        #settings-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 15px;
            color: white;
            text-align: center;
            display: none;
            z-index: 30;
            min-width: 300px;
        }

        #settings-menu h2 {
            color: #FFD700;
            margin-bottom: 20px;
        }

        .settings-option {
            margin: 15px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #2196F3;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        #settings-btn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(0,0,0,0.6);
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            cursor: pointer;
            z-index: 15;
        }

        #mobile-controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 20px;
            z-index: 10;
        }

        .mobile-btn {
            width: 80px;
            height: 80px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>Kills: <span id="kills">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Time: <span id="time">0</span>s</div>
    </div>
    
    <div id="weapon-display">
        Weapon: <span id="current-weapon">Fists</span>
    </div>

    <button id="settings-btn">SETTINGS</button>
    <button id="quit-btn">QUIT TO MENU</button>

    <div id="settings-menu">
        <h2>Settings</h2>
        <div class="settings-option">
            <span>Mobile Controls</span>
            <label class="toggle-switch">
                <input type="checkbox" id="mobile-toggle">
                <span class="slider"></span>
            </label>
        </div>
        <button id="close-settings" style="margin-top: 20px; padding: 10px 20px; cursor: pointer;">CLOSE</button>
    </div>

    <div id="mobile-controls">
        <div class="mobile-btn" id="mobile-jump">JUMP</div>
        <div class="mobile-btn" id="mobile-attack">ATTACK</div>
    </div>

    <div id="crosshair"></div>

    <div id="instructions">
        <h2>ðŸ¦† Duck Defense 3D ðŸ¦†</h2>
        <ul>
            <li><strong>W/A/S/D</strong> - Move forward/left/back/right</li>
            <li><strong>MOUSE</strong> - Aim direction</li>
            <li><strong>SPACE</strong> - Jump (Double Jump!)</li>
            <li><strong>LEFT CLICK</strong> - Attack/Shoot</li>
            <li><strong>E</strong> - Enter/Exit vehicles</li>
            <li><strong>Collect weapons</strong> to fight hunters!</li>
            <li><strong>Survive as long as you can!</strong></li>
        </ul>
        <button id="start-btn">START GAME</button>
    </div>

    <div id="game-over">
        <h1>GAME OVER!</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button id="restart-btn">PLAY AGAIN</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ==================== GAME STATE ====================
        const gameState = {
            kills: 0,
            lives: 3,
            currentWeapon: 'fists',
            isGameOver: false,
            isPaused: true,
            enemySpawnRate: 3000,
            lastSpawnTime: 0,
            gameStartTime: 0,
            gameTime: 0,
            vehicle: null
        };

        // ==================== WEAPONS CONFIG ====================
        const weapons = {
            fists: { damage: 10, range: 3, cooldown: 500, type: 'melee' },
            sword: { damage: 30, range: 5, cooldown: 400, type: 'melee' },
            hammer: { damage: 50, range: 4, cooldown: 800, type: 'melee' },
            rifle: { damage: 80, range: 100, cooldown: 600, type: 'projectile', speed: 1.2 },
            machineGun: { damage: 50, range: 20, cooldown: 150, type: 'projectile', speed: 1.0 },
            catapult: { damage: 60, range: 40, cooldown: 1500, type: 'arc', speed: 0.3 },
            cannon: { damage: 100, range: 50, cooldown: 2000, type: 'projectile', speed: 0.5, aoe: 5 }
        };

        // ==================== SCENE SETUP ====================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x6B8E7F); // Murky marsh sky
        scene.fog = new THREE.Fog(0x8B9A8E, 20, 70); // Humid marsh fog

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(20, 40, 20);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -60;
        directionalLight.shadow.camera.right = 60;
        directionalLight.shadow.camera.top = 60;
        directionalLight.shadow.camera.bottom = -60;
        scene.add(directionalLight);

        // ==================== TERRAIN ====================
        const terrainSize = 100;
        const terrainSegments = 50;
        const obstacles = [];
        
        function getTerrainHeight(x, z) {
            const scale = 0.05;
            return Math.sin(x * scale) * Math.cos(z * scale) * 3 + 
                   Math.sin(x * scale * 0.3) * 2;
        }

        const groundGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSegments, terrainSegments);
        const vertices = groundGeometry.attributes.position.array;
        
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 1];
            vertices[i + 2] = getTerrainHeight(x, z);
        }
        
        groundGeometry.computeVertexNormals();
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3D5A3D }); // Darker marsh ground
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Dark murky swamp water patches with enhanced aesthetics
        const waterZones = [];
        for (let i = 0; i < 40; i++) {
            const radius = Math.random() * 4 + 2;
            const waterGeom = new THREE.CircleGeometry(radius, 16);
            const waterMat = new THREE.MeshLambertMaterial({ color: 0x2F4538, transparent: true, opacity: 0.8 }); // Dark swamp water
            const water = new THREE.Mesh(waterGeom, waterMat);
            water.rotation.x = -Math.PI / 2;
            const x = (Math.random() - 0.5) * 90;
            const z = (Math.random() - 0.5) * 90;
            const terrainY = getTerrainHeight(x, z);
            water.position.set(x, terrainY + 0.05, z);
            scene.add(water);
            
            // Add lily pads floating on larger ponds
            if (radius > 3) {
                for (let j = 0; j < 3; j++) {
                    const lilyGeom = new THREE.CircleGeometry(0.4, 8);
                    const lilyMat = new THREE.MeshLambertMaterial({ color: 0x4A6741 });
                    const lily = new THREE.Mesh(lilyGeom, lilyMat);
                    lily.rotation.x = -Math.PI / 2;
                    const angle = (j / 3) * Math.PI * 2 + Math.random();
                    const dist = radius * 0.5 * Math.random();
                    lily.position.set(x + Math.cos(angle) * dist, terrainY + 0.1, z + Math.sin(angle) * dist);
                    scene.add(lily);
                }
            }
            
            // Add reeds/cattails around pond edges
            const reedCount = Math.floor(radius * 2);
            for (let j = 0; j < reedCount; j++) {
                const reedGeom = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 4);
                const reedMat = new THREE.MeshLambertMaterial({ color: 0x5C6F4E });
                const reed = new THREE.Mesh(reedGeom, reedMat);
                const angle = (j / reedCount) * Math.PI * 2;
                const edgeDist = radius + 0.3 + Math.random() * 0.3;
                reed.position.set(x + Math.cos(angle) * edgeDist, terrainY + 0.75, z + Math.sin(angle) * edgeDist);
                reed.rotation.z = (Math.random() - 0.5) * 0.2;
                scene.add(reed);
                
                // Cattail bulb on top
                const bulbGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.3, 6);
                const bulbMat = new THREE.MeshLambertMaterial({ color: 0x6B4423 });
                const bulb = new THREE.Mesh(bulbGeom, bulbMat);
                bulb.position.set(
                    x + Math.cos(angle) * edgeDist,
                    terrainY + 1.5,
                    z + Math.sin(angle) * edgeDist
                );
                scene.add(bulb);
            }
            
            waterZones.push({ position: new THREE.Vector3(x, 0, z), radius: radius });
        }

        // Cypress trees with spanish moss (collision obstacles)
        function createTree() {
            const tree = new THREE.Group();
            
            // Wider base, narrow top - cypress style
            const trunkGeom = new THREE.CylinderGeometry(0.25, 0.5, 5, 8);
            const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4A3C28 }); // Dark cypress bark
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // Sparse canopy
            const leavesGeom = new THREE.ConeGeometry(1.5, 3, 8);
            const leavesMat = new THREE.MeshLambertMaterial({ color: 0x4A6741 }); // Darker cypress green
            const leaves = new THREE.Mesh(leavesGeom, leavesMat);
            leaves.position.y = 5.5;
            leaves.castShadow = true;
            tree.add(leaves);
            
            // Spanish moss hanging down
            for (let i = 0; i < 3; i++) {
                const mossGeom = new THREE.BoxGeometry(0.1, 1.5, 0.1);
                const mossMat = new THREE.MeshLambertMaterial({ color: 0x8B9467 }); // Grayish-green moss
                const moss = new THREE.Mesh(mossGeom, mossMat);
                moss.position.set(
                    (Math.random() - 0.5) * 1.5,
                    4.2,
                    (Math.random() - 0.5) * 1.5
                );
                moss.rotation.z = (Math.random() - 0.5) * 0.3;
                tree.add(moss);
            }
            
            return tree;
        }

        for (let i = 0; i < 40; i++) {
            const tree = createTree();
            const x = (Math.random() - 0.5) * 80;
            const z = (Math.random() - 0.5) * 80;
            if (Math.abs(x) > 10 || Math.abs(z) > 10) {
                const terrainY = getTerrainHeight(x, z);
                tree.position.set(x, terrainY, z);
                scene.add(tree);
                obstacles.push({ 
                    position: new THREE.Vector3(x, 0, z), 
                    radius: 0.5, 
                    type: 'tree',
                    walkableHeight: terrainY + 5  // Top of trunk at y=5 from base
                });
            }
        }

        // Swamp vegetation - palmetto bushes (slow movement)
        const bushZones = [];
        function createBush() {
            const bushGeom = new THREE.SphereGeometry(1, 6, 6);
            const bushMat = new THREE.MeshLambertMaterial({ color: 0x3A4F3A }); // Darker swamp vegetation
            const bush = new THREE.Mesh(bushGeom, bushMat);
            bush.scale.set(1.2, 0.5, 1.2);
            bush.castShadow = true;
            return bush;
        }

        for (let i = 0; i < 60; i++) {
            const bush = createBush();
            const x = (Math.random() - 0.5) * 90;
            const z = (Math.random() - 0.5) * 90;
            bush.position.set(x, getTerrainHeight(x, z) + 0.3, z);
            scene.add(bush);
            bushZones.push({ position: new THREE.Vector3(x, 0, z), radius: 1.2 });
        }

        // Garbage piles - aesthetic swamp trash
        function createGarbagePile() {
            const pile = new THREE.Group();
            
            // Various junk pieces
            for (let i = 0; i < 5; i++) {
                const junkGeom = new THREE.BoxGeometry(
                    Math.random() * 0.5 + 0.2,
                    Math.random() * 0.4 + 0.1,
                    Math.random() * 0.5 + 0.2
                );
                const junkColors = [0x3A3A3A, 0x5C4033, 0x2F2F2F, 0x8B4513];
                const junkMat = new THREE.MeshLambertMaterial({ color: junkColors[Math.floor(Math.random() * junkColors.length)] });
                const junk = new THREE.Mesh(junkGeom, junkMat);
                junk.position.set(
                    (Math.random() - 0.5) * 0.8,
                    Math.random() * 0.3,
                    (Math.random() - 0.5) * 0.8
                );
                junk.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                pile.add(junk);
            }
            
            return pile;
        }

        for (let i = 0; i < 12; i++) {
            const garbagePile = createGarbagePile();
            const x = (Math.random() - 0.5) * 70;
            const z = (Math.random() - 0.5) * 70;
            garbagePile.position.set(x, getTerrainHeight(x, z), z);
            scene.add(garbagePile);
        }

        // Glowing lanterns - atmospheric marsh lighting
        function createLantern() {
            const lantern = new THREE.Group();
            
            // Pole
            const poleGeom = new THREE.CylinderGeometry(0.05, 0.05, 2.5, 6);
            const poleMat = new THREE.MeshLambertMaterial({ color: 0x2F2F2F });
            const pole = new THREE.Mesh(poleGeom, poleMat);
            pole.position.y = 1.25;
            lantern.add(pole);
            
            // Lantern cage
            const cageGeom = new THREE.BoxGeometry(0.3, 0.4, 0.3);
            const cageMat = new THREE.MeshLambertMaterial({ color: 0x1A1A1A });
            const cage = new THREE.Mesh(cageGeom, cageMat);
            cage.position.y = 2.6;
            lantern.add(cage);
            
            // Glowing light inside
            const lightGeom = new THREE.SphereGeometry(0.15, 8, 8);
            const lightMat = new THREE.MeshLambertMaterial({ 
                color: 0xFFAA00, 
                emissive: 0xFFAA00, 
                emissiveIntensity: 1 
            });
            const light = new THREE.Mesh(lightGeom, lightMat);
            light.position.y = 2.6;
            lantern.add(light);
            
            // Point light for glow
            const pointLight = new THREE.PointLight(0xFFAA00, 0.5, 8);
            pointLight.position.y = 2.6;
            lantern.add(pointLight);
            
            return lantern;
        }

        for (let i = 0; i < 10; i++) {
            const lantern = createLantern();
            const angle = (i / 10) * Math.PI * 2;
            const distance = 20 + Math.random() * 15;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            lantern.position.set(x, getTerrainHeight(x, z), z);
            scene.add(lantern);
        }

        // Hut (collision obstacle) - Complex marsh-blended design
        function createHut() {
            const hut = new THREE.Group();
            
            // Weathered wooden stilts/supports for swamp
            const stiltMat = new THREE.MeshLambertMaterial({ color: 0x3A2817 });
            for (let i = 0; i < 4; i++) {
                const stiltGeom = new THREE.CylinderGeometry(0.2, 0.25, 2, 6);
                const stilt = new THREE.Mesh(stiltGeom, stiltMat);
                const x = i < 2 ? -3 : 3;
                const z = i % 2 === 0 ? -3 : 3;
                stilt.position.set(x, 1, z);
                stilt.castShadow = true;
                hut.add(stilt);
            }
            
            // Main cabin - weathered wood planks
            const baseGeom = new THREE.BoxGeometry(8, 4, 8);
            const baseMat = new THREE.MeshLambertMaterial({ color: 0x5C4033 }); // Darker weathered wood
            const base = new THREE.Mesh(baseGeom, baseMat);
            base.position.y = 2;
            base.castShadow = true;
            hut.add(base);
            
            // Horizontal planks detail
            for (let i = 0; i < 5; i++) {
                const plankGeom = new THREE.BoxGeometry(8.1, 0.15, 8.1);
                const plankMat = new THREE.MeshLambertMaterial({ color: 0x4A3528 });
                const plank = new THREE.Mesh(plankGeom, plankMat);
                plank.position.y = 0.5 + i * 0.8;
                hut.add(plank);
            }
            
            // Mossy overgrowth on sides
            const mossMat = new THREE.MeshLambertMaterial({ color: 0x6B8E6B });
            for (let i = 0; i < 8; i++) {
                const mossGeom = new THREE.BoxGeometry(0.2, 1.2, 0.3);
                const moss = new THREE.Mesh(mossGeom, mossMat);
                const angle = (i / 8) * Math.PI * 2;
                moss.position.set(Math.cos(angle) * 4.1, 2 + Math.random(), Math.sin(angle) * 4.1);
                moss.rotation.y = angle;
                hut.add(moss);
            }
            
            // Thatched roof - darker swamp reeds
            const roofGeom = new THREE.ConeGeometry(6, 3, 4);
            const roofMat = new THREE.MeshLambertMaterial({ color: 0x6B5D4F }); // Dark thatch
            const roof = new THREE.Mesh(roofGeom, roofMat);
            roof.position.y = 5.5;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            hut.add(roof);
            
            // Roof moss patches
            for (let i = 0; i < 6; i++) {
                const roofMossGeom = new THREE.BoxGeometry(1, 0.1, 1);
                const roofMoss = new THREE.Mesh(roofMossGeom, mossMat);
                const angle = (i / 6) * Math.PI * 2;
                roofMoss.position.set(Math.cos(angle) * 2, 5.5 + Math.random() * 0.5, Math.sin(angle) * 2);
                roofMoss.rotation.y = angle;
                hut.add(roofMoss);
            }
            
            // Small door
            const doorGeom = new THREE.BoxGeometry(1.5, 2.5, 0.1);
            const doorMat = new THREE.MeshLambertMaterial({ color: 0x2F1F10 });
            const door = new THREE.Mesh(doorGeom, doorMat);
            door.position.set(0, 1.5, 4.05);
            hut.add(door);
            
            return hut;
        }

        const hut = createHut();
        scene.add(hut);
        obstacles.push({ 
            position: new THREE.Vector3(0, 0, 0), 
            radius: 4.5,
            type: 'hut',
            walkableHeight: 4  // Top of base at y=4
        });

        // ==================== DUCK PLAYER ====================
        function createDuck() {
            const duck = new THREE.Group();
            
            const bodyGeom = new THREE.SphereGeometry(0.6, 8, 8);
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.scale.y = 1.2;
            body.castShadow = true;
            duck.add(body);
            duck.userData.body = body;
            
            const headGeom = new THREE.SphereGeometry(0.4, 8, 8);
            const head = new THREE.Mesh(headGeom, bodyMat);
            head.position.y = 0.8;
            head.castShadow = true;
            duck.add(head);
            duck.userData.head = head;
            
            const beakGeom = new THREE.ConeGeometry(0.15, 0.3, 4);
            const beakMat = new THREE.MeshLambertMaterial({ color: 0xFFA500 });
            const beak = new THREE.Mesh(beakGeom, beakMat);
            beak.rotation.x = Math.PI / 2;
            beak.position.set(0, 0.8, 0.4);
            beak.castShadow = true;
            duck.add(beak);
            
            const eyeGeom = new THREE.SphereGeometry(0.08, 6, 6);
            const eyeMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
            leftEye.position.set(-0.15, 0.9, 0.3);
            const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
            rightEye.position.set(0.15, 0.9, 0.3);
            duck.add(leftEye, rightEye);
            
            // Wings
            const wingGeom = new THREE.BoxGeometry(0.8, 0.1, 0.5);
            const wingMat = new THREE.MeshLambertMaterial({ color: 0xFFDD00 });
            const leftWing = new THREE.Mesh(wingGeom, wingMat);
            leftWing.position.set(-0.5, 0.2, 0);
            leftWing.rotation.z = -Math.PI / 6;
            leftWing.castShadow = true;
            duck.add(leftWing);
            duck.userData.leftWing = leftWing;
            
            const rightWing = new THREE.Mesh(wingGeom, wingMat);
            rightWing.position.set(0.5, 0.2, 0);
            rightWing.rotation.z = Math.PI / 6;
            rightWing.castShadow = true;
            duck.add(rightWing);
            duck.userData.rightWing = rightWing;
            
            return duck;
        }

        function createWeaponModel(weaponType) {
            const weapon = new THREE.Group();
            
            switch(weaponType) {
                case 'sword':
                    const bladeGeom = new THREE.BoxGeometry(0.12, 2.0, 0.06);
                    const bladeMat = new THREE.MeshLambertMaterial({ color: 0xE0E0E0 });
                    const blade = new THREE.Mesh(bladeGeom, bladeMat);
                    blade.position.y = 1.0;
                    weapon.add(blade);
                    
                    // Blade edge highlight
                    const edgeGeom = new THREE.BoxGeometry(0.02, 2.0, 0.06);
                    const edgeMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                    const edge = new THREE.Mesh(edgeGeom, edgeMat);
                    edge.position.set(0.055, 1.0, 0);
                    weapon.add(edge);
                    
                    const handleGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 6);
                    const handleMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const handle = new THREE.Mesh(handleGeom, handleMat);
                    handle.position.y = -0.25;
                    weapon.add(handle);
                    
                    // Crossguard/Hilt
                    const guardGeom = new THREE.BoxGeometry(0.5, 0.08, 0.08);
                    const guardMat = new THREE.MeshLambertMaterial({ color: 0xDAA520 });
                    const guard = new THREE.Mesh(guardGeom, guardMat);
                    guard.position.y = 0;
                    weapon.add(guard);
                    
                    // Pommel
                    const pommelGeom = new THREE.SphereGeometry(0.12, 6, 6);
                    const pommel = new THREE.Mesh(pommelGeom, guardMat);
                    pommel.position.y = -0.5;
                    weapon.add(pommel);
                    break;
                    
                case 'hammer':
                    const hammerHeadGeom = new THREE.BoxGeometry(0.8, 0.8, 0.5);
                    const hammerHeadMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
                    const hammerHead = new THREE.Mesh(hammerHeadGeom, hammerHeadMat);
                    hammerHead.position.y = 1.5;
                    weapon.add(hammerHead);
                    
                    // Metal band on hammer head
                    const bandGeom = new THREE.BoxGeometry(0.82, 0.15, 0.52);
                    const bandMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
                    const band = new THREE.Mesh(bandGeom, bandMat);
                    band.position.y = 1.5;
                    weapon.add(band);
                    
                    const hammerHandleGeom = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6);
                    const hammerHandleMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
                    const hammerHandle = new THREE.Mesh(hammerHandleGeom, hammerHandleMat);
                    hammerHandle.position.y = 0.75;
                    weapon.add(hammerHandle);
                    
                    // Handle grip
                    const gripGeom = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
                    const gripMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const grip = new THREE.Mesh(gripGeom, gripMat);
                    grip.position.y = 0.3;
                    weapon.add(grip);
                    break;
                    
                case 'rifle':
                case 'machineGun':
                    const barrelGeom = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
                    const gunMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    const barrel = new THREE.Mesh(barrelGeom, gunMat);
                    barrel.rotation.z = Math.PI / 2;
                    barrel.position.x = 0.5;
                    weapon.add(barrel);
                    
                    const stockGeom = new THREE.BoxGeometry(0.3, 0.15, 0.1);
                    const stock = new THREE.Mesh(stockGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    stock.position.x = -0.1;
                    weapon.add(stock);
                    break;
                    
                case 'catapult':
                    const catapultBaseGeom = new THREE.BoxGeometry(0.8, 0.3, 0.6);
                    const catapultBase = new THREE.Mesh(catapultBaseGeom, new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                    catapultBase.position.y = 0.15;
                    weapon.add(catapultBase);
                    
                    const catapultArmGeom = new THREE.BoxGeometry(0.08, 1.0, 0.08);
                    const catapultArm = new THREE.Mesh(catapultArmGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    catapultArm.position.y = 0.65;
                    weapon.add(catapultArm);
                    
                    // Spoon/bucket
                    const spoonGeom = new THREE.BoxGeometry(0.3, 0.1, 0.3);
                    const spoon = new THREE.Mesh(spoonGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    spoon.position.y = 1.1;
                    weapon.add(spoon);
                    
                    // Support beams
                    const supportGeom = new THREE.BoxGeometry(0.1, 0.6, 0.1);
                    const support1 = new THREE.Mesh(supportGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    support1.position.set(-0.3, 0.45, 0);
                    support1.rotation.z = -0.3;
                    weapon.add(support1);
                    const support2 = new THREE.Mesh(supportGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    support2.position.set(0.3, 0.45, 0);
                    support2.rotation.z = 0.3;
                    weapon.add(support2);
                    break;
                    
                case 'cannon':
                    const cannonBarrelGeom = new THREE.CylinderGeometry(0.25, 0.2, 1.2, 8);
                    const cannonBarrel = new THREE.Mesh(cannonBarrelGeom, new THREE.MeshLambertMaterial({ color: 0x333333 }));
                    cannonBarrel.rotation.z = Math.PI / 2;
                    cannonBarrel.position.set(0.6, 0.3, 0);
                    weapon.add(cannonBarrel);
                    
                    // Cannon mouth rim
                    const rimGeom = new THREE.CylinderGeometry(0.26, 0.25, 0.1, 8);
                    const rim = new THREE.Mesh(rimGeom, new THREE.MeshLambertMaterial({ color: 0x666666 }));
                    rim.rotation.z = Math.PI / 2;
                    rim.position.set(1.15, 0.3, 0);
                    weapon.add(rim);
                    
                    // Carriage base
                    const carriageGeom = new THREE.BoxGeometry(0.6, 0.2, 0.5);
                    const carriage = new THREE.Mesh(carriageGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    carriage.position.y = 0.1;
                    weapon.add(carriage);
                    
                    const wheelGeom = new THREE.CylinderGeometry(0.15, 0.15, 0.08, 8);
                    const wheel1 = new THREE.Mesh(wheelGeom, new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                    wheel1.rotation.x = Math.PI / 2;
                    wheel1.position.set(0, 0.15, -0.3);
                    weapon.add(wheel1);
                    const wheel2 = new THREE.Mesh(wheelGeom, new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                    wheel2.rotation.x = Math.PI / 2;
                    wheel2.position.set(0, 0.15, 0.3);
                    weapon.add(wheel2);
                    break;
            }
            
            weapon.scale.set(0.8, 0.8, 0.8);
            return weapon;
        }

        const player = {
            mesh: createDuck(),
            velocity: new THREE.Vector3(),
            position: new THREE.Vector3(8, 1, 0), // Start outside hut
            lookAngle: 0,
            isJumping: false,
            jumpsUsed: 0,
            maxJumps: 2,
            canAttack: true,
            lastAttackTime: 0,
            weaponModel: null,
            wingFlapTime: 0,
            bloodDripCounter: 0
        };

        player.mesh.position.copy(player.position);
        scene.add(player.mesh);

        function updatePlayerWeapon() {
            if (player.weaponModel) {
                player.mesh.remove(player.weaponModel);
            }
            
            if (gameState.currentWeapon !== 'fists') {
                player.weaponModel = createWeaponModel(gameState.currentWeapon);
                player.weaponModel.position.set(0.5, 0.3, 0);
                player.weaponModel.rotation.z = -Math.PI / 4;
                player.mesh.add(player.weaponModel);
            } else {
                player.weaponModel = null;
            }
        }

        // ==================== MOUSE INPUT ====================
        let mouseX = 0;
        let mouseY = 0;

        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // ==================== ENEMIES ====================
        const enemies = [];
        const bloodParticles = [];

        function createHunter() {
            const hunter = new THREE.Group();
            
            const bodyGeom = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 6);
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 0.6;
            body.castShadow = true;
            hunter.add(body);
            
            const headGeom = new THREE.SphereGeometry(0.3, 8, 8);
            const headMat = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
            const head = new THREE.Mesh(headGeom, headMat);
            head.position.y = 1.5;
            head.castShadow = true;
            hunter.add(head);
            
            const hatGeom = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 8);
            const hatMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const hat = new THREE.Mesh(hatGeom, hatMat);
            hat.position.y = 1.9;
            hunter.add(hat);
            
            const gunGeom = new THREE.BoxGeometry(0.1, 0.1, 0.6);
            const gunMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const gun = new THREE.Mesh(gunGeom, gunMat);
            gun.position.set(0.4, 1.0, 0);
            gun.rotation.x = -Math.PI / 6;
            hunter.add(gun);
            
            return hunter;
        }

        function createAlligator() {
            const gator = new THREE.Group();
            
            // Body - long and low
            const bodyGeom = new THREE.BoxGeometry(2.5, 0.5, 0.8);
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0x3A5F3A }); // Dark green
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 0.25;
            body.castShadow = true;
            gator.add(body);
            
            // Head - wider at the front
            const headGeom = new THREE.BoxGeometry(0.8, 0.4, 0.9);
            const head = new THREE.Mesh(headGeom, bodyMat);
            head.position.set(1.5, 0.25, 0);
            head.castShadow = true;
            gator.add(head);
            
            // Snout
            const snoutGeom = new THREE.BoxGeometry(0.5, 0.2, 0.6);
            const snout = new THREE.Mesh(snoutGeom, new THREE.MeshLambertMaterial({ color: 0x2F4F2F }));
            snout.position.set(1.9, 0.2, 0);
            gator.add(snout);
            
            // Eyes
            const eyeGeom = new THREE.SphereGeometry(0.1, 6, 6);
            const eyeMat = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
            const eye1 = new THREE.Mesh(eyeGeom, eyeMat);
            eye1.position.set(1.7, 0.4, 0.3);
            gator.add(eye1);
            const eye2 = new THREE.Mesh(eyeGeom, eyeMat);
            eye2.position.set(1.7, 0.4, -0.3);
            gator.add(eye2);
            
            // Tail
            const tailGeom = new THREE.ConeGeometry(0.4, 1.2, 4);
            const tail = new THREE.Mesh(tailGeom, bodyMat);
            tail.rotation.z = -Math.PI / 2;
            tail.position.set(-1.8, 0.25, 0);
            tail.castShadow = true;
            gator.add(tail);
            
            // Spikes on back
            for (let i = 0; i < 6; i++) {
                const spikeGeom = new THREE.ConeGeometry(0.1, 0.3, 4);
                const spike = new THREE.Mesh(spikeGeom, new THREE.MeshLambertMaterial({ color: 0x2F4F2F }));
                spike.position.set(-0.8 + i * 0.5, 0.5, 0);
                gator.add(spike);
            }
            
            return gator;
        }

        // Alligators array
        const alligators = [];
        
        // Spawn alligators near water zones
        for (let i = 0; i < 8; i++) {
            const waterZone = waterZones[Math.floor(Math.random() * waterZones.length)];
            const angle = Math.random() * Math.PI * 2;
            const dist = waterZone.radius + 1;
            const x = waterZone.position.x + Math.cos(angle) * dist;
            const z = waterZone.position.z + Math.sin(angle) * dist;
            
            const gator = {
                mesh: createAlligator(),
                position: new THREE.Vector3(x, getTerrainHeight(x, z), z),
                angle: angle,
                homePosition: new THREE.Vector3(x, 0, z),
                patrolRadius: 5,
                lastBiteTime: 0,
                biteCooldown: 2000
            };
            
            gator.mesh.position.copy(gator.position);
            gator.mesh.rotation.y = angle;
            scene.add(gator.mesh);
            alligators.push(gator);
        }

        function createBloodParticle(position, type = 'normal') {
            // Different sizes and colors based on type
            let size = 0.1;
            let color = 0x8B0000;
            let lifetime = 60;
            
            if (type === 'large') {
                size = 0.2;
                color = 0xFF0000; // Brighter red for large chunks
                lifetime = 80;
            } else if (type === 'spray') {
                size = 0.08;
                color = 0x660000; // Darker spray
                lifetime = 40;
            }
            
            const geom = new THREE.SphereGeometry(size, 4, 4);
            const mat = new THREE.MeshLambertMaterial({ color: color });
            const particle = new THREE.Mesh(geom, mat);
            particle.position.copy(position);
            particle.castShadow = true;
            scene.add(particle);
            
            // Different velocity patterns based on type
            let vel;
            if (type === 'spray') {
                vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.15,
                    Math.random() * 0.15,
                    (Math.random() - 0.5) * 0.15
                );
            } else {
                vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.4,
                    Math.random() * 0.4 + 0.2,
                    (Math.random() - 0.5) * 0.4
                );
            }
            
            bloodParticles.push({
                mesh: particle,
                velocity: vel,
                lifetime: lifetime
            });
        }

        // Wind streak particles for weapon swings
        const windStreaks = [];
        
        function createWindStreak(position, direction, weaponType) {
            // Create elongated wind streak particles
            const geom = weaponType === 'sword' ? 
                new THREE.BoxGeometry(0.15, 0.05, 0.8) : // Sword - long thin streak
                new THREE.BoxGeometry(0.2, 0.2, 0.6);     // Hammer - thicker streak
            
            const mat = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF, 
                transparent: true, 
                opacity: 0.8 
            });
            const streak = new THREE.Mesh(geom, mat);
            streak.position.copy(position);
            
            // Orient streak along swing direction
            const angle = Math.atan2(direction.x, direction.z);
            streak.rotation.y = angle;
            
            scene.add(streak);
            
            windStreaks.push({
                mesh: streak,
                velocity: direction.clone().multiplyScalar(0.3),
                lifetime: 12,
                initialOpacity: 0.8
            });
        }

        function createTruck() {
            const truck = new THREE.Group();
            const bodyGeom = new THREE.BoxGeometry(3, 1.2, 5);
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0x5a4a3a });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 1;
            body.castShadow = true;
            truck.add(body);
            const cabinGeom = new THREE.BoxGeometry(2.5, 1.5, 2);
            const cabinMat = new THREE.MeshLambertMaterial({ color: 0x3d3d3d });
            const cabin = new THREE.Mesh(cabinGeom, cabinMat);
            cabin.position.set(0, 2.2, 1);
            cabin.castShadow = true;
            truck.add(cabin);
            const bedGeom = new THREE.BoxGeometry(2.8, 0.8, 2.5);
            const bedMat = new THREE.MeshLambertMaterial({ color: 0x4a3a2a });
            const bed = new THREE.Mesh(bedGeom, bedMat);
            bed.position.set(0, 1.2, -1.2);
            truck.add(bed);
            const wheelGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 12);
            const wheelMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
            [[-1.4, 0.5, 1.5], [1.4, 0.5, 1.5], [-1.4, 0.5, -1.5], [1.4, 0.5, -1.5]].forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(...pos);
                truck.add(wheel);
            });
            return truck;
        }

        const vehicles = [];
        let lastTruckSpawnTime = Date.now();

        function spawnTruckWithDriver() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 48;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            const terrainY = getTerrainHeight(x, z);
            
            const truck = createTruck();
            truck.position.set(x, terrainY, z);
            truck.rotation.y = angle + Math.PI;
            scene.add(truck);
            
            const driver = createHunter();
            driver.position.set(0, 2.5, 0.8);
            truck.add(driver);
            
            const vehicle = {
                mesh: truck,
                position: new THREE.Vector3(x, terrainY, z),
                rotation: angle + Math.PI,
                velocity: new THREE.Vector3(),
                hasDriver: true,
                driver: {
                    mesh: driver,
                    health: 80,
                    lastShootTime: 0,
                    shootCooldown: 1500
                }
            };
            vehicles.push(vehicle);
        }

        function spawnEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 45;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            
            const enemy = {
                mesh: createHunter(),
                position: new THREE.Vector3(x, getTerrainHeight(x, z) + 1, z),
                health: 50,
                lastShootTime: 0,
                shootCooldown: 2000
            };
            
            enemy.mesh.position.copy(enemy.position);
            scene.add(enemy.mesh);
            enemies.push(enemy);
        }

        // ==================== PROJECTILES ====================
        const projectiles = [];

        function createProjectile(start, direction, config, fromPlayer = true, weaponType = null) {
            // Make cannon and catapult projectiles much larger (player only)
            let projectileSize = 0.15;
            let canPierce = false;
            
            // Only apply special projectile properties for player weapons
            if (fromPlayer && weaponType) {
                if (weaponType === 'cannon') {
                    projectileSize = 0.5;
                    canPierce = true;
                } else if (weaponType === 'catapult') {
                    projectileSize = 0.4;
                    canPierce = true;
                }
            }
            
            const geom = new THREE.SphereGeometry(projectileSize, 8, 8);
            const mat = new THREE.MeshLambertMaterial({ 
                color: fromPlayer ? (canPierce ? 0xFF6600 : 0xFFFF00) : 0xFF0000 
            });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.copy(start);
            mesh.castShadow = true;
            scene.add(mesh);
            
            projectiles.push({
                mesh,
                velocity: direction.clone().multiplyScalar(config.speed || 0.5),
                damage: config.damage,
                lifetime: 200,
                isArc: config.type === 'arc',
                aoe: config.aoe || 0,
                fromPlayer,
                canPierce,
                hitEnemies: [],
                hitVehicles: [],
                weaponType: weaponType
            });
        }

        function createEnemyProjectile(start, direction) {
            const geom = new THREE.SphereGeometry(0.12, 6, 6);
            const mat = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.copy(start);
            mesh.castShadow = true;
            scene.add(mesh);
            
            projectiles.push({
                mesh,
                velocity: direction.clone().multiplyScalar(0.5),
                damage: 1,
                lifetime: 150,
                fromPlayer: false
            });
        }

        // ==================== WEAPON PICKUPS ====================
        const pickups = [];

        function createPickup(weaponType) {
            const geom = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const mat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.castShadow = true;
            
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 15 + 5;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            mesh.position.set(x, getTerrainHeight(x, z) + 0.5, z);
            
            scene.add(mesh);
            pickups.push({ mesh, weaponType, rotation: 0 });
        }

        const weaponTypes = ['sword', 'hammer', 'rifle', 'machineGun', 'catapult', 'cannon'];
        for (let i = 0; i < 5; i++) {
            createPickup(weaponTypes[Math.floor(Math.random() * weaponTypes.length)]);
        }

        // ==================== INPUT ====================
        const keys = {};
        let mouseDown = false;

        window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousedown', () => mouseDown = true);
        window.addEventListener('mouseup', () => mouseDown = false);

        // ==================== COLLISION DETECTION ====================
        function checkCollision(position, radius) {
            for (let obstacle of obstacles) {
                const dist = Math.sqrt(
                    Math.pow(position.x - obstacle.position.x, 2) +
                    Math.pow(position.z - obstacle.position.z, 2)
                );
                if (dist < radius + obstacle.radius) {
                    return true;
                }
            }
            return false;
        }

        function getSpeedModifier(position) {
            let modifier = 1.0;
            
            // Check water
            for (let water of waterZones) {
                const dist = Math.sqrt(
                    Math.pow(position.x - water.position.x, 2) +
                    Math.pow(position.z - water.position.z, 2)
                );
                if (dist < water.radius) {
                    modifier = Math.min(modifier, 0.4);
                }
            }
            
            // Check bushes
            for (let bush of bushZones) {
                const dist = Math.sqrt(
                    Math.pow(position.x - bush.position.x, 2) +
                    Math.pow(position.z - bush.position.z, 2)
                );
                if (dist < bush.radius) {
                    modifier = Math.min(modifier, 0.6);
                }
            }
            
            return modifier;
        }

        // ==================== DAY/NIGHT CYCLE ====================
        function updateDayNight() {
            if (gameState.isPaused || gameState.isGameOver) return;
            
            const timeInSeconds = gameState.gameTime;
            const cycleDuration = 180; // 3 minutes for full day-night cycle
            const cycleProgress = (timeInSeconds % cycleDuration) / cycleDuration;
            
            let skyColor, fogColor, ambientIntensity, directionalIntensity;
            
            if (cycleProgress < 0.5) {
                // Day to dusk (0 - 0.5) - Marsh colors
                const t = cycleProgress * 2;
                skyColor = new THREE.Color().lerpColors(
                    new THREE.Color(0x6B8E7F), // Murky marsh day
                    new THREE.Color(0x1a2618), // Dark swamp night
                    t
                );
                fogColor = new THREE.Color().lerpColors(
                    new THREE.Color(0x8B9A8E), // Marsh fog
                    new THREE.Color(0x2a3a2a), // Night marsh fog
                    t
                );
                ambientIntensity = 0.6 - (t * 0.4);
                directionalIntensity = 0.8 - (t * 0.6);
            } else {
                // Night to dawn (0.5 - 1.0) - Marsh colors
                const t = (cycleProgress - 0.5) * 2;
                skyColor = new THREE.Color().lerpColors(
                    new THREE.Color(0x1a2618), // Dark swamp night
                    new THREE.Color(0x6B8E7F), // Murky marsh day
                    t
                );
                fogColor = new THREE.Color().lerpColors(
                    new THREE.Color(0x2a3a2a), // Night marsh fog
                    new THREE.Color(0x8B9A8E), // Marsh fog
                    t
                );
                ambientIntensity = 0.2 + (t * 0.4);
                directionalIntensity = 0.2 + (t * 0.6);
            }
            
            scene.background = skyColor;
            scene.fog.color = fogColor;
            ambientLight.intensity = ambientIntensity;
            directionalLight.intensity = directionalIntensity;
        }

        // ==================== GAME LOGIC ====================
        function updatePlayer(delta) {
            if (gameState.isPaused || gameState.isGameOver) return;

            const baseSpeed = 0.04; // Slower base speed
            const jumpForce = 1.25; // Increased jump force
            const gravity = -0.04;

            // Get speed modifier based on terrain
            const speedModifier = getSpeedModifier(player.position);
            const moveSpeed = baseSpeed * speedModifier;

            // Store old position for collision rollback
            const oldPosition = player.position.clone();

            // Movement relative to look direction
            const forward = new THREE.Vector3(-Math.sin(player.lookAngle), 0, -Math.cos(player.lookAngle));
            const right = new THREE.Vector3(Math.cos(player.lookAngle), 0, -Math.sin(player.lookAngle));

            if (keys['w']) {
                player.velocity.add(forward.clone().multiplyScalar(moveSpeed));
            }
            if (keys['s']) {
                player.velocity.add(forward.clone().multiplyScalar(-moveSpeed));
            }
            if (keys['a']) {
                player.velocity.add(right.clone().multiplyScalar(-moveSpeed));
            }
            if (keys['d']) {
                player.velocity.add(right.clone().multiplyScalar(moveSpeed));
            }

            // Double Jump with wing flapping
            if (keys[' '] && player.jumpsUsed < player.maxJumps) {
                if (!player.lastJumpKey) {
                    player.velocity.y = jumpForce;
                    player.jumpsUsed++;
                    player.isJumping = true;
                    player.wingFlapTime = 10; // Wing flap duration
                    player.lastJumpKey = true;
                }
            } else {
                player.lastJumpKey = false;
            }

            // Wing flapping animation
            if (player.wingFlapTime > 0) {
                player.wingFlapTime--;
                const flapAngle = Math.sin(player.wingFlapTime * 0.8) * Math.PI / 3;
                player.mesh.userData.leftWing.rotation.z = -Math.PI / 6 - flapAngle;
                player.mesh.userData.rightWing.rotation.z = Math.PI / 6 + flapAngle;
            } else {
                player.mesh.userData.leftWing.rotation.z = -Math.PI / 6;
                player.mesh.userData.rightWing.rotation.z = Math.PI / 6;
            }

            // Apply velocity
            player.position.add(player.velocity);
            player.velocity.multiplyScalar(0.85);

            // Check collision and rollback if needed
            if (checkCollision(player.position, 0.6)) {
                player.position.copy(oldPosition);
                player.velocity.x *= -0.5;
                player.velocity.z *= -0.5;
            }

            // Gravity and terrain/structure collision
            player.velocity.y += gravity;
            const terrainY = getTerrainHeight(player.position.x, player.position.z);
            
            // Check if player is above a walkable structure (hut or tree)
            let groundY = terrainY;
            for (const obstacle of obstacles) {
                if (obstacle.walkableHeight) {
                    const dist2D = Math.sqrt(
                        Math.pow(player.position.x - obstacle.position.x, 2) +
                        Math.pow(player.position.z - obstacle.position.z, 2)
                    );
                    
                    // If player is within structure radius and above it, use structure height
                    if (dist2D < obstacle.radius && player.position.y >= obstacle.walkableHeight - 1) {
                        groundY = Math.max(groundY, obstacle.walkableHeight);
                    }
                }
            }
            
            if (player.position.y <= groundY + 1) {
                player.position.y = groundY + 1;
                player.velocity.y = 0;
                player.isJumping = false;
                player.jumpsUsed = 0; // Reset jumps when on ground
            }

            // Boundary
            const maxDist = 48;
            if (Math.abs(player.position.x) > maxDist) {
                player.position.x = Math.sign(player.position.x) * maxDist;
            }
            if (Math.abs(player.position.z) > maxDist) {
                player.position.z = Math.sign(player.position.z) * maxDist;
            }

            // Mouse look direction
            const lookDir = new THREE.Vector3(mouseX, 0, -mouseY).normalize();
            player.lookAngle = Math.atan2(lookDir.x, lookDir.z);

            // Update mesh
            player.mesh.position.copy(player.position);
            player.mesh.rotation.y = player.lookAngle;
            
            // Weapon swing animation
            if (player.weaponModel && player.weaponModel.userData.swingTime > 0) {
                player.weaponModel.userData.swingTime--;
                const t = player.weaponModel.userData.swingTime / 15;
                
                if (player.weaponModel.userData.swingType === 'arc') {
                    // Sword arc swing
                    const swingAngle = Math.sin((1 - t) * Math.PI) * Math.PI / 2;
                    player.weaponModel.rotation.z = -Math.PI / 4 + swingAngle;
                    player.weaponModel.rotation.y = Math.sin((1 - t) * Math.PI) * Math.PI / 3;
                } else if (player.weaponModel.userData.swingType === 'chop') {
                    // Hammer vertical chop
                    const chopAngle = Math.sin((1 - t) * Math.PI) * Math.PI / 1.5;
                    player.weaponModel.rotation.x = -chopAngle;
                }
            } else if (player.weaponModel) {
                // Reset to default position
                player.weaponModel.rotation.set(0, 0, -Math.PI / 4);
            }

            // Update injuries based on lives lost
            if (gameState.lives <= 2) {
                player.mesh.userData.body.material.color.setHex(0xFFCC00);
                
                // Blood trail when injured - drip every few frames
                player.bloodDripCounter++;
                const dripRate = gameState.lives === 1 ? 8 : 15; // More frequent when more injured
                if (player.bloodDripCounter >= dripRate) {
                    player.bloodDripCounter = 0;
                    const dripPos = player.position.clone();
                    dripPos.y += 0.3;
                    createBloodParticle(dripPos, 'spray');
                }
            }
            if (gameState.lives <= 1) {
                player.mesh.userData.head.material.color.setHex(0xFF8800);
                player.mesh.rotation.x = 0.1;
            }

            // Camera follow (third-person)
            const camDist = 12;
            const camHeight = 8;
            camera.position.x = player.position.x + Math.sin(player.lookAngle) * camDist;
            camera.position.y = player.position.y + camHeight;
            camera.position.z = player.position.z + Math.cos(player.lookAngle) * camDist;
            camera.lookAt(player.position);

            // Attack
            const weapon = weapons[gameState.currentWeapon];
            const now = Date.now();
            if (mouseDown && now - player.lastAttackTime > weapon.cooldown) {
                player.lastAttackTime = now;
                
                if (weapon.type === 'melee') {
                    meleeAttack();
                } else {
                    shootProjectile();
                }
            }
        }

        function meleeAttack() {
            const weapon = weapons[gameState.currentWeapon];
            const attackDir = new THREE.Vector3(
                -Math.sin(player.lookAngle),
                0,
                -Math.cos(player.lookAngle)
            );
            
            // Weapon swing animation
            if (player.weaponModel) {
                if (gameState.currentWeapon === 'sword') {
                    // Sword wide arc swing animation
                    player.weaponModel.userData.swingTime = 15;
                    player.weaponModel.userData.swingType = 'arc';
                } else if (gameState.currentWeapon === 'hammer') {
                    // Hammer vertical chop animation
                    player.weaponModel.userData.swingTime = 20;
                    player.weaponModel.userData.swingType = 'chop';
                }
            }
            
            // Create dramatic wind streak effects for melee weapons
            if (gameState.currentWeapon === 'sword' || gameState.currentWeapon === 'hammer') {
                const streakCount = gameState.currentWeapon === 'sword' ? 8 : 5;
                for (let i = 0; i < streakCount; i++) {
                    const offset = player.position.clone();
                    offset.y += 1 + (Math.random() - 0.5) * 0.4;
                    
                    // Spread streaks in arc for sword, forward for hammer
                    let dir = attackDir.clone();
                    if (gameState.currentWeapon === 'sword') {
                        const spread = (i / streakCount - 0.5) * 1.5;
                        dir = new THREE.Vector3(
                            -Math.sin(player.lookAngle + spread),
                            (Math.random() - 0.5) * 0.2,
                            -Math.cos(player.lookAngle + spread)
                        ).normalize();
                    }
                    
                    offset.add(dir.clone().multiplyScalar(1 + i * 0.3));
                    createWindStreak(offset, dir, gameState.currentWeapon);
                }
            }
            
            // Better hitbox detection - larger multipliers and more forgiving angles
            let hitboxMultiplier = 2.5; // Base multiplier for all melee
            if (gameState.currentWeapon === 'sword') hitboxMultiplier = 1.6;
            if (gameState.currentWeapon === 'hammer') hitboxMultiplier = 1.4;
            
            enemies.forEach((enemy, idx) => {
                const dist = player.position.distanceTo(enemy.position);
                if (dist < weapon.range * hitboxMultiplier) {
                    const toEnemy = enemy.position.clone().sub(player.position).normalize();
                    const angleThreshold = gameState.currentWeapon === 'sword' ? 0.2 : 0.4; // Lower = wider cone
                    if (attackDir.dot(toEnemy) > angleThreshold) {
                        enemy.health -= weapon.damage;
                        if (enemy.health <= 0) {
                            // Enhanced graphic gore effect
                            // Large splatter burst
                            for (let i = 0; i < 30; i++) {
                                createBloodParticle(enemy.position.clone(), Math.random() < 0.3 ? 'large' : 'normal');
                            }
                            // Blood spray in attack direction
                            for (let i = 0; i < 10; i++) {
                                const spray = enemy.position.clone();
                                spray.add(attackDir.clone().multiplyScalar(i * 0.3));
                                createBloodParticle(spray, 'spray');
                            }
                            scene.remove(enemy.mesh);
                            enemies.splice(idx, 1);
                            gameState.kills ++;
                            updateUI();
                        }
                    }
                }
            });
        }

        function shootProjectile() {
            const weapon = weapons[gameState.currentWeapon];
            const direction = new THREE.Vector3(
                -Math.sin(player.lookAngle),
                weapon.type === 'arc' ? 0.3 : 0,
                -Math.cos(player.lookAngle)
            ).normalize();
            
            const start = player.position.clone();
            start.y += 1;
            
            createProjectile(start, direction, weapon, true, gameState.currentWeapon);
        }

        function updateEnemies(delta) {
            if (gameState.isPaused || gameState.isGameOver) return;

            const now = Date.now();
            
            enemies.forEach((enemy, idx) => {
                // Move toward player
                const toPlayer = player.position.clone().sub(enemy.position);
                const dist = toPlayer.length();
                
                if (dist > 5) {
                    toPlayer.normalize().multiplyScalar(0.06);
                    enemy.position.add(toPlayer);
                    
                    // Keep on terrain
                    const terrainY = getTerrainHeight(enemy.position.x, enemy.position.z);
                    enemy.position.y = terrainY + 1;
                    
                    enemy.mesh.position.copy(enemy.position);
                    enemy.mesh.lookAt(player.position);
                }
                
                // Shoot at player with improved accuracy
                if (dist < 30 && now - enemy.lastShootTime > enemy.shootCooldown) {
                    enemy.lastShootTime = now;
                    const shootDir = toPlayer.normalize();
                    const start = enemy.position.clone();
                    start.y += 1;
                    createEnemyProjectile(start, shootDir);
                }
            });

            // Spawn enemies
            if (now - gameState.lastSpawnTime > gameState.enemySpawnRate) {
                gameState.lastSpawnTime = now;
                spawnEnemy();
                gameState.enemySpawnRate = Math.max(1000, gameState.enemySpawnRate - 50);
            }
            
            // Spawn trucks occasionally (every 15-25 seconds)
            if (now - lastTruckSpawnTime > 15000 + Math.random() * 10000 && vehicles.length < 3) {
                lastTruckSpawnTime = now;
                spawnTruckWithDriver();
            }
        }

        function updateVehicles(delta) {
            if (gameState.isPaused || gameState.isGameOver) return;
            
            const now = Date.now();
            
            vehicles.forEach((vehicle, vIdx) => {
                if (gameState.vehicle === vehicle) {
                    // Player is driving this vehicle
                    const driveSpeed = 0.15;
                    const turnSpeed = 0.03;
                    
                    if (keys['w']) {
                        vehicle.velocity.x -= Math.sin(vehicle.rotation) * driveSpeed;
                        vehicle.velocity.z -= Math.cos(vehicle.rotation) * driveSpeed;
                    }
                    if (keys['s']) {
                        vehicle.velocity.x += Math.sin(vehicle.rotation) * driveSpeed * 0.5;
                        vehicle.velocity.z += Math.cos(vehicle.rotation) * driveSpeed * 0.5;
                    }
                    if (keys['a']) vehicle.rotation += turnSpeed;
                    if (keys['d']) vehicle.rotation -= turnSpeed;
                    
                    vehicle.position.add(vehicle.velocity);
                    vehicle.velocity.multiplyScalar(0.92);
                    
                    const terrainY = getTerrainHeight(vehicle.position.x, vehicle.position.z);
                    vehicle.position.y = terrainY;
                    
                    vehicle.mesh.position.copy(vehicle.position);
                    vehicle.mesh.rotation.y = vehicle.rotation;
                    
                    // Player follows vehicle
                    player.position.copy(vehicle.position);
                    player.position.y += 3;
                    player.mesh.position.copy(player.position);
                    player.mesh.visible = false;
                    
                    // Run over enemies!
                    enemies.forEach((enemy, idx) => {
                        const dist = vehicle.position.distanceTo(enemy.position);
                        if (dist < 3) {
                            for (let i = 0; i < 20; i++) {
                                createBloodParticle(enemy.position.clone(), Math.random() < 0.3 ? 'large' : 'normal');
                            }
                            scene.remove(enemy.mesh);
                            enemies.splice(idx, 1);
                            gameState.kills++;
                            updateUI();
                        }
                    });
                    
                    // Exit vehicle with E
                    if (keys['e'] && !vehicle.exitCooldown) {
                        gameState.vehicle = null;
                        player.mesh.visible = true;
                        player.position.x = vehicle.position.x + 3;
                        player.position.z = vehicle.position.z;
                        player.position.y = getTerrainHeight(player.position.x, player.position.z) + 1;
                        player.mesh.position.copy(player.position);
                        vehicle.exitCooldown = true;
                        setTimeout(() => vehicle.exitCooldown = false, 500);
                    }
                } else if (vehicle.hasDriver) {
                    // AI drives toward player
                    const toPlayer = player.position.clone().sub(vehicle.position);
                    const dist = toPlayer.length();
                    
                    if (dist > 10) {
                        const targetAngle = Math.atan2(-toPlayer.x, -toPlayer.z);
                        let angleDiff = targetAngle - vehicle.rotation;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        vehicle.rotation += Math.sign(angleDiff) * Math.min(0.02, Math.abs(angleDiff));
                        
                        vehicle.velocity.x -= Math.sin(vehicle.rotation) * 0.08;
                        vehicle.velocity.z -= Math.cos(vehicle.rotation) * 0.08;
                    }
                    
                    vehicle.position.add(vehicle.velocity);
                    vehicle.velocity.multiplyScalar(0.95);
                    
                    const terrainY = getTerrainHeight(vehicle.position.x, vehicle.position.z);
                    vehicle.position.y = terrainY;
                    
                    vehicle.mesh.position.copy(vehicle.position);
                    vehicle.mesh.rotation.y = vehicle.rotation;
                    
                    // Driver shoots
                    if (dist < 35 && now - vehicle.driver.lastShootTime > vehicle.driver.shootCooldown) {
                        vehicle.driver.lastShootTime = now;
                        const shootDir = toPlayer.normalize();
                        const start = vehicle.position.clone();
                        start.y += 3;
                        createEnemyProjectile(start, shootDir);
                    }
                } else {
                    // Empty vehicle - player can enter with E
                    const dist = player.position.distanceTo(vehicle.position);
                    if (dist < 4 && keys['e'] && !gameState.vehicle && !vehicle.enterCooldown) {
                        gameState.vehicle = vehicle;
                        vehicle.enterCooldown = true;
                        setTimeout(() => vehicle.enterCooldown = false, 500);
                    }
                }
            });
        }

        function updateAlligators(delta) {
            if (gameState.isPaused || gameState.isGameOver) return;
            
            const now = Date.now();
            
            alligators.forEach(gator => {
                // Patrol around home position
                const toHome = gator.homePosition.clone().sub(new THREE.Vector3(gator.position.x, 0, gator.position.z));
                const homeDistance = toHome.length();
                
                // Wander if too far from home
                if (homeDistance > gator.patrolRadius) {
                    toHome.normalize().multiplyScalar(0.03);
                    gator.position.x += toHome.x;
                    gator.position.z += toHome.z;
                } else {
                    // Slow patrol
                    gator.angle += 0.01;
                    gator.position.x = gator.homePosition.x + Math.cos(gator.angle) * 2;
                    gator.position.z = gator.homePosition.z + Math.sin(gator.angle) * 2;
                }
                
                // Keep on terrain
                const terrainY = getTerrainHeight(gator.position.x, gator.position.z);
                gator.position.y = terrainY;
                
                // Update mesh
                gator.mesh.position.copy(gator.position);
                gator.mesh.rotation.y = gator.angle;
                
                // Check if player is close enough to bite
                const toPlayer = player.position.clone().sub(gator.position);
                const distToPlayer = toPlayer.length();
                
                if (distToPlayer < 2.5 && now - gator.lastBiteTime > gator.biteCooldown) {
                    gator.lastBiteTime = now;
                    gameState.lives--;
                    
                    // Blood splash when bitten
                    for (let i = 0; i < 10; i++) {
                        createBloodParticle(player.position.clone(), Math.random() < 0.5 ? 'large' : 'normal');
                    }
                    
                    updateUI();
                    if (gameState.lives <= 0) {
                        gameOver();
                    }
                }
            });
        }

        function updateProjectiles(delta) {

            /*if (proj.fromPlayer) {
            enemies.forEach((enemy, idx) => {
            const dist = proj.mesh.position.distanceTo(enemy.position);
            const alreadyHit = proj.hitEnemies && proj.hitEnemies.includes(enemy);


            // Adjustable hit radius by weapon type
            let hitRadius = 1.7;
            if (gameState.currentWeapon === 'rifle') hitRadius = 2.2;
            if (gameState.currentWeapon === 'machineGun') hitRadius = 1.5;


            if (dist < hitRadius && !alreadyHit) {
            enemy.health -= proj.damage;


            if (proj.canPierce) {
            proj.hitEnemies.push(enemy);
            }


            if (enemy.health <= 0) {
            for (let i = 0; i < 15; i++) {
            createBloodParticle(enemy.position.clone());
            }
            scene.remove(enemy.mesh);
            enemies.splice(idx, 1);
            gameState.kills++;
            updateUI();
            }


            if (!proj.canPierce) {
            proj.lifetime = 0;
            }
            }
            });
            }*/
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                if (proj.isArc) {
                    proj.velocity.y -= 0.015;
                }
                
                proj.mesh.position.add(proj.velocity);
                proj.lifetime--;
                
                // Keep on terrain for arc projectiles
                const terrainY = getTerrainHeight(proj.mesh.position.x, proj.mesh.position.z);
                
                // Check obstacle collisions (trees and hut)
                let hitObstacle = false;
                for (const obstacle of obstacles) {
                    const dist = new THREE.Vector2(
                        proj.mesh.position.x - obstacle.position.x,
                        proj.mesh.position.z - obstacle.position.z
                    ).length();
                    if (dist < obstacle.radius) {
                        hitObstacle = true;
                        break;
                    }
                }
                
                if (hitObstacle) {
                    proj.lifetime = 0;
                }
                
                // Check collisions
                if (proj.fromPlayer) {
                    // Larger hit radius for better accuracy
                    let hitRadius = 2.0;
                    if (proj.weaponType === 'rifle') hitRadius = 2.5;
                    if (proj.weaponType === 'machineGun') hitRadius = 1.8;
                    if (proj.weaponType === 'cannon') hitRadius = 3.0;
                    if (proj.weaponType === 'catapult') hitRadius = 2.5;
                    
                    enemies.forEach((enemy, idx) => {
                        const dist = proj.mesh.position.distanceTo(enemy.position);
                        const alreadyHit = proj.hitEnemies && proj.hitEnemies.includes(enemy);
                        
                        if (dist < hitRadius && !alreadyHit) {
                            enemy.health -= proj.damage;
                            
                            if (proj.canPierce) {
                                proj.hitEnemies.push(enemy);
                            }
                            
                            if (enemy.health <= 0) {
                                for (let i = 0; i < 15; i++) {
                                    createBloodParticle(enemy.position.clone());
                                }
                                scene.remove(enemy.mesh);
                                enemies.splice(idx, 1);
                                gameState.kills++;
                                updateUI();
                            }
                            
                            if (!proj.canPierce) {
                                proj.lifetime = 0;
                            }
                        }
                    });
                    
                    // Hit vehicle drivers
                    vehicles.forEach((vehicle, vIdx) => {
                        if (vehicle.hasDriver) {
                            const driverPos = vehicle.position.clone();
                            driverPos.y += 2.5;
                            const dist = proj.mesh.position.distanceTo(driverPos);
                            const alreadyHit = proj.hitVehicles && proj.hitVehicles.includes(vehicle);
                            
                            if (dist < hitRadius && !alreadyHit) {
                                vehicle.driver.health -= proj.damage;
                                
                                if (proj.canPierce) {
                                    if (!proj.hitVehicles) proj.hitVehicles = [];
                                    proj.hitVehicles.push(vehicle);
                                }
                                
                                if (vehicle.driver.health <= 0) {
                                    for (let i = 0; i < 20; i++) {
                                        createBloodParticle(driverPos, Math.random() < 0.3 ? 'large' : 'normal');
                                    }
                                    vehicle.mesh.remove(vehicle.driver.mesh);
                                    vehicle.hasDriver = false;
                                    gameState.kills++;
                                    updateUI();
                                }
                                
                                if (!proj.canPierce) {
                                    proj.lifetime = 0;
                                }
                            }
                        }
                    });
                } else {
                    // Enemy projectile hitting player
                    const distToPlayer = proj.mesh.position.distanceTo(player.position);
                    if (distToPlayer < 1.2) {
                        gameState.lives--;
                        updateUI();
                        proj.lifetime = 0;
                        
                        // Blood effect on player
                        for (let i = 0; i < 5; i++) {
                            createBloodParticle(player.position.clone());
                        }
                        
                        if (gameState.lives <= 0) {
                            gameOver();
                        }
                    }
                }
                
                // Catapult ground blast radius
                if (proj.weaponType === 'catapult' && proj.mesh.position.y <= terrainY + 0.5) {
                    const blastRadius = 6;
                    // Create explosion effect
                    for (let j = 0; j < 15; j++) {
                        const particle = new THREE.Mesh(
                            new THREE.SphereGeometry(0.3, 6, 6),
                            new THREE.MeshLambertMaterial({ color: 0xFF6600 })
                        );
                        particle.position.copy(proj.mesh.position);
                        scene.add(particle);
                        const vel = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.5,
                            Math.random() * 0.4,
                            (Math.random() - 0.5) * 0.5
                        );
                        bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 30 });
                    }
                    
                    // Damage all enemies in blast radius
                    enemies.forEach((enemy, idx) => {
                        const dist = proj.mesh.position.distanceTo(enemy.position);
                        if (dist < blastRadius) {
                            const damage = proj.damage * (1 - dist / blastRadius);
                            enemy.health -= damage;
                            if (enemy.health <= 0) {
                                for (let k = 0; k < 20; k++) {
                                    createBloodParticle(enemy.position.clone(), 'large');
                                }
                                scene.remove(enemy.mesh);
                                enemies.splice(idx, 1);
                                gameState.kills++;
                                updateUI();
                            }
                        }
                    });
                    proj.lifetime = 0;
                }
                
                if (proj.lifetime <= 0 || proj.mesh.position.y < terrainY) {
                    scene.remove(proj.mesh);
                    projectiles.splice(i, 1);
                }
            }
        }

        function updateBloodParticles(delta) {
            for (let i = bloodParticles.length - 1; i >= 0; i--) {
                const particle = bloodParticles[i];
                
                particle.velocity.y -= 0.02;
                particle.mesh.position.add(particle.velocity);
                particle.lifetime--;
                
                const terrainY = getTerrainHeight(particle.mesh.position.x, particle.mesh.position.z);
                if (particle.mesh.position.y <= terrainY) {
                    particle.mesh.position.y = terrainY + 0.05;
                    particle.velocity.multiplyScalar(0.3);
                    particle.mesh.scale.multiplyScalar(0.95);
                }
                
                if (particle.lifetime <= 0 || particle.mesh.scale.x < 0.1) {
                    scene.remove(particle.mesh);
                    bloodParticles.splice(i, 1);
                }
            }
        }

        function updateWindStreaks(delta) {
            for (let i = windStreaks.length - 1; i >= 0; i--) {
                const streak = windStreaks[i];
                
                // Move forward and fade out
                streak.mesh.position.add(streak.velocity);
                streak.lifetime--;
                
                // Fade out opacity and scale
                const fadeProgress = streak.lifetime / 12;
                streak.mesh.material.opacity = streak.initialOpacity * fadeProgress;
                streak.mesh.scale.multiplyScalar(0.92);
                
                if (streak.lifetime <= 0) {
                    scene.remove(streak.mesh);
                    windStreaks.splice(i, 1);
                }
            }
        }

        function updatePickups(delta) {
            pickups.forEach((pickup, idx) => {
                pickup.rotation += 0.02;
                pickup.mesh.rotation.y = pickup.rotation;
                pickup.mesh.position.y += Math.sin(pickup.rotation * 2) * 0.01;
                
                const dist = player.position.distanceTo(pickup.mesh.position);
                if (dist < 1.5) {
                    gameState.currentWeapon = pickup.weaponType;
                    updatePlayerWeapon();
                    updateUI();
                    scene.remove(pickup.mesh);
                    pickups.splice(idx, 1);
                    
                    // Spawn new pickup
                    setTimeout(() => {
                        createPickup(weaponTypes[Math.floor(Math.random() * weaponTypes.length)]);
                    }, 5000);
                }
            });
        }

        function updateUI() {
            document.getElementById('kills').textContent = gameState.kills;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('time').textContent = Math.floor(gameState.gameTime);
            document.getElementById('current-weapon').textContent = 
                gameState.currentWeapon.charAt(0).toUpperCase() + gameState.currentWeapon.slice(1);
        }

        function gameOver() {
            gameState.isGameOver = true;
            document.getElementById('final-score').textContent = gameState.kills*100+gameState.gameTime;
            document.getElementById('game-over').style.display = 'block';
        }

        function resetGame() {
            gameState.kills = 0;
            gameState.lives = 3;
            gameState.currentWeapon = 'fists';
            gameState.isGameOver = false;
            gameState.isPaused = false;
            gameState.enemySpawnRate = 3000;
            gameState.lastSpawnTime = Date.now();
            gameState.gameStartTime = Date.now();
            gameState.gameTime = 0;
            
            player.position.set(8, getTerrainHeight(8, 0) + 1, 0); // Start outside hut
            player.velocity.set(0, 0, 0);
            player.lookAngle = 0;
            
            // Reset player appearance
            player.mesh.userData.body.material.color.setHex(0xFFFF00);
            player.mesh.userData.head.material.color.setHex(0xFFFF00);
            player.mesh.rotation.x = 0;
            
            updatePlayerWeapon();
            
            enemies.forEach(e => scene.remove(e.mesh));
            enemies.length = 0;
            
            alligators.forEach(g => scene.remove(g.mesh));
            alligators.length = 0;
            
            vehicles.forEach(v => scene.remove(v.mesh));
            vehicles.length = 0;
            gameState.vehicle = null;
            lastTruckSpawnTime = Date.now();
            player.mesh.visible = true;
            
            // Respawn alligators
            for (let i = 0; i < 8; i++) {
                const waterZone = waterZones[Math.floor(Math.random() * waterZones.length)];
                const angle = Math.random() * Math.PI * 2;
                const dist = waterZone.radius + 1;
                const x = waterZone.position.x + Math.cos(angle) * dist;
                const z = waterZone.position.z + Math.sin(angle) * dist;
                
                const gator = {
                    mesh: createAlligator(),
                    position: new THREE.Vector3(x, getTerrainHeight(x, z), z),
                    angle: angle,
                    homePosition: new THREE.Vector3(x, 0, z),
                    patrolRadius: 5,
                    lastBiteTime: 0,
                    biteCooldown: 2000
                };
                
                gator.mesh.position.copy(gator.position);
                gator.mesh.rotation.y = angle;
                scene.add(gator.mesh);
                alligators.push(gator);
            }
            
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles.length = 0;
            
            bloodParticles.forEach(p => scene.remove(p.mesh));
            bloodParticles.length = 0;
            
            windStreaks.forEach(w => scene.remove(w.mesh));
            windStreaks.length = 0;
            
            document.getElementById('game-over').style.display = 'none';
            updateUI();
        }

        // ==================== EVENT LISTENERS ====================
        const settingsBtn = document.getElementById('settings-btn');
        const settingsMenu = document.getElementById('settings-menu');
        const mobileToggle = document.getElementById('mobile-toggle');
        const mobileControls = document.getElementById('mobile-controls');
        const closeSettings = document.getElementById('close-settings');

        settingsBtn.addEventListener('click', () => {
            settingsMenu.style.display = 'block';
            gameState.isPaused = true;
        });

        closeSettings.addEventListener('click', () => {
            settingsMenu.style.display = 'none';
            if (!document.getElementById('instructions').style.display || 
                document.getElementById('instructions').style.display === 'none') {
                gameState.isPaused = false;
            }
        });

        mobileToggle.addEventListener('change', (e) => {
            mobileControls.style.display = e.target.checked ? 'flex' : 'none';
        });

        // Mobile button logic
        document.getElementById('mobile-jump').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.isPaused && !gameState.isGameOver && player.jumpsUsed < 2) {
                player.velocity.y = 0.2;
                player.jumpsUsed++;
                player.isJumping = true;
            }
        });

        document.getElementById('mobile-attack').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.isPaused && !gameState.isGameOver) {
                const weapon = weapons[gameState.currentWeapon];
                if (weapon.type === 'melee') {
                    meleeAttack();
                } else {
                    shootProjectile();
                }
            }
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('quit-btn').style.display = 'block';
            gameState.isPaused = false;
            gameState.gameStartTime = Date.now();
            gameState.lastSpawnTime = Date.now();
            lastTruckSpawnTime = Date.now();
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            resetGame();
        });

        document.getElementById('quit-btn').addEventListener('click', () => {
            gameState.isPaused = true;
            document.getElementById('quit-btn').style.display = 'none';
            document.getElementById('instructions').style.display = 'block';
            
            // Reset game state without showing game over
            gameState.kills = 0;
            gameState.lives = 3;
            gameState.currentWeapon = 'fists';
            gameState.enemySpawnRate = 3000;
            player.position.set(8, 1, 0);
            player.velocity.set(0, 0, 0);
            player.isJumping = false;
            player.jumpsUsed = 0;
            player.bloodDripCounter = 0;
            
            // Reset player appearance
            player.mesh.userData.body.material.color.setHex(0xFFFF00);
            player.mesh.userData.head.material.color.setHex(0xFFFF00);
            player.mesh.rotation.x = 0;
            
            updatePlayerWeapon();
            
            enemies.forEach(e => scene.remove(e.mesh));
            enemies.length = 0;
            
            alligators.forEach(g => scene.remove(g.mesh));
            alligators.length = 0;
            
            vehicles.forEach(v => scene.remove(v.mesh));
            vehicles.length = 0;
            gameState.vehicle = null;
            lastTruckSpawnTime = 0;
            player.mesh.visible = true;
            
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles.length = 0;
            
            bloodParticles.forEach(p => scene.remove(p.mesh));
            bloodParticles.length = 0;
            
            windStreaks.forEach(w => scene.remove(w.mesh));
            windStreaks.length = 0;
            
            updateUI();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==================== GAME LOOP ====================
        let lastTime = Date.now();

        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            const delta = now - lastTime;
            lastTime = now;
            
            if (!gameState.isPaused && !gameState.isGameOver) {
                gameState.gameTime = (now - gameState.gameStartTime) / 1000;
            }
            
            updateDayNight();
            updatePlayer(delta);
            updateEnemies(delta);
            updateAlligators(delta);
            updateVehicles(delta);
            updateProjectiles(delta);
            updateBloodParticles(delta);
            updateWindStreaks(delta);
            updatePickups(delta);
            
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>