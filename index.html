<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duck Defense 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            background: #0d1f15;
            cursor: crosshair;
            color: #fff;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            z-index: 10;
            display: flex;
            gap: 20px;
        }

        #ui div {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #weapon-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 12px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 18px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #current-weapon {
            color: #FFD700;
            font-weight: bold;
            text-transform: uppercase;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 5;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 3px black;
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 40px;
            border-radius: 20px;
            color: white;
            text-align: center;
            display: none;
            z-index: 20;
        }

        #game-over h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff4444;
        }

        #game-over button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
        }

        #game-over button:hover {
            background: #45a049;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 40px;
            border-radius: 20px;
            color: white;
            text-align: center;
            z-index: 20;
        }

        #instructions h2 {
            margin-bottom: 20px;
            color: #FFD700;
        }

        #instructions ul {
            text-align: left;
            margin: 20px 0;
            list-style-position: inside;
        }

        #instructions li {
            margin: 10px 0;
        }

        #instructions button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
        }

        #quit-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            font-size: 16px;
            background: rgba(220, 20, 60, 0.2);
            backdrop-filter: blur(5px);
            color: #ff4d4d;
            border: 1px solid rgba(220, 20, 60, 0.4);
            border-radius: 12px;
            cursor: pointer;
            font-family: inherit;
            font-weight: 700;
            text-transform: uppercase;
            pointer-events: auto;
            z-index: 15;
            display: none;
            transition: all 0.3s ease;
        }

        #quit-btn:hover {
            background: rgba(220, 20, 60, 0.8);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(220, 20, 60, 0.4);
        }

        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 250px;
            display: none;
            z-index: 10;
            pointer-events: none;
        }

        #joystick-container {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 150px;
            height: 150px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
            pointer-events: auto;
            touch-action: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #joystick-thumb {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
        }

        .mobile-action-btns {
            position: absolute;
            bottom: 40px;
            right: 40px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            pointer-events: auto;
        }

        .mobile-btn {
            width: 85px;
            height: 85px;
            background: rgba(0,0,0,0.5);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            user-select: none;
            border: 2px solid rgba(255,255,255,0.3);
            touch-action: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        .mobile-btn .btn-icon {
            font-size: 24px;
            margin-bottom: 2px;
        }

        .mobile-btn:active {
            background: rgba(255,255,255,0.3);
            transform: scale(0.92);
            border-color: #fff;
        }

        #mobile-jump {
            background: rgba(30, 144, 255, 0.4);
            border-color: rgba(30, 144, 255, 0.6);
        }

        #mobile-attack {
            background: rgba(255, 69, 0, 0.4);
            border-color: rgba(255, 69, 0, 0.6);
            width: 100px;
            height: 100px;
        }
        
        #mobile-ability {
            background: rgba(50, 205, 50, 0.4);
            border-color: rgba(50, 205, 50, 0.6);
        }

        #mobile-special {
            background: rgba(148, 0, 211, 0.4);
            border-color: rgba(148, 0, 211, 0.6);
        }

        /* Main Menu Styles */
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #2a5a3a 0%, #0d1f15 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: auto;
            overflow: hidden;
        }

        #main-menu::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://www.transparenttextures.com/patterns/carbon-fibre.png');
            opacity: 0.1;
            pointer-events: none;
        }

        .menu-title {
            font-size: 96px;
            font-weight: 900;
            color: #fff;
            text-transform: uppercase;
            background: linear-gradient(to bottom, #FFD700 20%, #FFA500 50%, #8B4513 80%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 30px rgba(255, 215, 0, 0.4));
            margin-bottom: 10px;
            letter-spacing: -4px;
            animation: titlePulse 3s infinite ease-in-out;
            transform: perspective(1000px) rotateX(10deg);
        }

        .menu-subtitle {
            font-size: 20px;
            color: #A8E6CF;
            margin-bottom: 60px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 4px;
            opacity: 0.8;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        .menu-btn {
            padding: 18px 40px;
            font-size: 20px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: white;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        .menu-btn:hover {
            background: #4CAF50;
            border-color: #4CAF50;
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 30px rgba(76, 175, 80, 0.4);
        }

        .menu-btn.secondary {
            background: rgba(255, 255, 255, 0.05);
            font-size: 16px;
        }

        .menu-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 10px 20px rgba(255,255,255,0.1);
        }
            padding: 20px;
            font-size: 24px;
            background: linear-gradient(180deg, #4CAF50 0%, #2E7D32 100%);
            color: white;
            border: none;
            border-bottom: 4px solid #1B5E20;
            border-radius: 15px;
            cursor: pointer;
            font-family: 'Arial Black', sans-serif;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .menu-btn:hover {
            transform: translateY(-5px) scale(1.02);
            background: linear-gradient(180deg, #66BB6A 0%, #388E3C 100%);
            box-shadow: 0 15px 30px rgba(76, 175, 80, 0.4);
        }

        .menu-btn:active {
            transform: translateY(2px);
            border-bottom-width: 0;
            margin-top: 4px;
        }

        .menu-btn.secondary {
            background: linear-gradient(180deg, #455A64 0%, #263238 100%);
            border-color: #607D8B;
            border-radius: 12px;
            font-size: 18px;
            padding: 15px;
        }

        .menu-btn.secondary:hover {
            background: linear-gradient(180deg, #607D8B 0%, #37474F 100%);
        }

        /* Settings Page */
        #settings-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a3a2a 0%, #0d1f15 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .settings-panel {
            background: rgba(0,0,0,0.85);
            padding: 30px;
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            max-height: 85vh;
            overflow-y: auto;
            border: 2px solid #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
        }

        .settings-panel::-webkit-scrollbar {
            width: 8px;
        }

        .settings-panel::-webkit-scrollbar-thumb {
            background: #4CAF50;
            border-radius: 4px;
        }

        .settings-panel h2 {
            color: #FFD700;
            text-align: center;
            margin-bottom: 20px;
            font-size: 32px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .setting-row {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .setting-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .setting-label {
            font-size: 18px;
            color: #8FBC8F;
            font-weight: bold;
        }

        .character-btns, .mode-btns, .difficulty-btns, .input-btns {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            gap: 8px;
            width: 100%;
        }

        .char-btn, .mode-btn, .diff-btn, .input-btn {
            padding: 8px;
            font-size: 13px;
            background: rgba(0,0,0,0.3);
            border: 1px solid #444;
            color: #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .char-btn:hover, .mode-btn:hover, .diff-btn:hover, .input-btn:hover {
            background: rgba(76, 175, 80, 0.2);
            border-color: #4CAF50;
        }

        .char-btn.active, .mode-btn.active, .diff-btn.active, .input-btn.active {
            background: #4CAF50;
            color: white;
            border-color: #66BB6A;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .char-btn.locked {
            opacity: 0.5;
            cursor: not-allowed;
            background: #222;
        }

        .char-description {
            margin-top: 10px;
            font-style: italic;
            color: #aaa;
            font-size: 14px;
            text-align: center;
            min-height: 40px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .settings-footer {
            margin-top: 20px;
            display: flex;
            justify-content: center;
        }

        .difficulty-btns, .input-btns {
            display: flex;
            gap: 10px;
        }

        .input-btn {
            padding: 10px 20px;
            border: 2px solid #666;
            background: transparent;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .input-btn.active {
            background: #2196F3;
            border-color: #42A5F5;
        }

        .input-btn:hover {
            border-color: #2196F3;
        }

        .character-btns {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }

        .char-btn {
            padding: 10px 15px;
            border: 2px solid #666;
            background: transparent;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .char-btn.active {
            background: #FF6B00;
            border-color: #FF8C00;
        }

        .char-btn:hover {
            border-color: #FF6B00;
        }

        .char-btn.locked {
            opacity: 0.5;
            background: #333;
            border-color: #666;
        }

        .char-btn.locked:hover {
            border-color: #888;
        }

        .char-description {
            font-size: 12px;
            color: #aaa;
            font-style: italic;
        }

        .mode-btns {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .mode-btn {
            padding: 8px 16px;
            background: #2a2a4a;
            border: 2px solid #555;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .mode-btn.active {
            border-color: #00ff88;
            background: #3a3a6a;
        }

        .mode-btn:hover {
            border-color: #88ff88;
        }

        .player-stats-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            width: 100%;
        }

        .stat-item {
            font-size: 14px;
            color: #ddd;
        }

        .stat-item span {
            color: #00ff88;
            font-weight: bold;
        }

        #ability-bar {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            display: none;
            z-index: 10;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #ability-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF6B00, #FFD700);
            width: 100%;
            transition: width 0.1s;
            box-shadow: 0 0 20px rgba(255, 107, 0, 0.5);
        }

        #ability-text {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 13px;
            line-height: 30px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        #ability-prompt {
            position: absolute;
            bottom: 110px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
            display: none;
            z-index: 10;
        }

        #special-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4a0080, #9400D3);
            border: 3px solid #FFD700;
            cursor: pointer;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: all 0.2s;
            box-shadow: 0 0 20px rgba(148, 0, 211, 0.5);
        }

        #special-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(148, 0, 211, 0.8);
        }

        /* Shop Styles */
        #shop-btn {
            position: absolute;
            top: 20px;
            right: 140px;
            padding: 12px 24px;
            font-size: 18px;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #333;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-family: inherit;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 15;
            display: none;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #shop-btn:hover {
            background: linear-gradient(135deg, #FFEC8B, #FFD700);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.5);
        }

        #coins-display {
            position: absolute;
            top: 20px;
            right: 270px;
            padding: 10px 20px;
            font-size: 18px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: #FFD700;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: bold;
            z-index: 15;
            display: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #shop-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a3a2a 0%, #0d1f15 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 30px;
            z-index: 100;
            overflow-y: auto;
        }

        .shop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 800px;
            margin-bottom: 20px;
        }

        .shop-title {
            font-size: 48px;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
        }

        .shop-coins {
            font-size: 24px;
            color: #FFD700;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 10px;
        }

        .shop-section {
            width: 100%;
            max-width: 800px;
            margin-bottom: 25px;
        }

        .shop-section h3 {
            color: #4CAF50;
            font-size: 24px;
            margin-bottom: 15px;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 8px;
        }

        .shop-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .shop-item {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.2s;
            cursor: pointer;
        }

        .shop-item:hover {
            border-color: #FFD700;
            background: rgba(255,255,255,0.15);
            transform: translateY(-3px);
        }

        .shop-item.purchased {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #4CAF50;
        }

        .shop-item.locked {
            border-color: #666;
        }

        .shop-item-name {
            color: white;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .shop-item-desc {
            color: #aaa;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .shop-item-price {
            color: #FFD700;
            font-size: 20px;
            font-weight: bold;
        }

        .shop-item-price.affordable {
            color: #4CAF50;
        }

        .shop-back-btn {
            margin-top: 20px;
            padding: 15px 50px;
            font-size: 20px;
            background: #555;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
        }

        .shop-back-btn:hover {
            background: #666;
        }

        #special-btn:active {
            transform: scale(0.95);
        }

        #special-btn.disabled {
            background: linear-gradient(135deg, #333, #555);
            border-color: #666;
            cursor: not-allowed;
            box-shadow: none;
        }

        #special-icon {
            font-size: 24px;
            color: #FFD700;
        }

        #special-count {
            font-size: 18px;
            font-weight: bold;
            color: white;
        }

        #special-name {
            font-size: 10px;
            color: #ccc;
        }

        #special-btn.active {
            animation: pulse-special 0.5s infinite alternate;
        }

        @keyframes pulse-special {
            from { box-shadow: 0 0 20px rgba(148, 0, 211, 0.5); }
            to { box-shadow: 0 0 40px rgba(255, 215, 0, 0.8); }
        }

        /* Stats Page */
        #stats-page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a3a2a 0%, #0d1f15 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 100;
            overflow-y: auto;
            padding: 40px 20px;
        }

        .stats-container {
            background: rgba(0,0,0,0.7);
            padding: 30px;
            border-radius: 20px;
            max-width: 800px;
            width: 100%;
        }

        .stats-container h2 {
            color: #FFD700;
            text-align: center;
            margin-bottom: 30px;
            font-size: 36px;
        }

        .stats-graph {
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .stats-graph h3 {
            color: #8FBC8F;
            margin-bottom: 15px;
        }

        #score-graph {
            width: 100%;
            height: 200px;
            background: #1a1a1a;
            border-radius: 8px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-card {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-card .stat-value {
            font-size: 36px;
            color: #4CAF50;
            font-weight: bold;
        }

        .stat-card .stat-label {
            font-size: 14px;
            color: #aaa;
            margin-top: 5px;
        }

        .stat-card.highlight .stat-value {
            color: #FFD700;
        }

        .back-btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 18px;
            background: #455A64;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }

        .back-btn:hover {
            background: #607D8B;
        }

        .no-stats {
            text-align: center;
            color: #888;
            padding: 40px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>üíÄ Kills: <span id="kills">0</span></div>
        <div>‚ù§Ô∏è Lives: <span id="lives">3</span></div>
        <div>‚è±Ô∏è Time: <span id="time">0</span>s</div>
    </div>
    
    <div id="weapon-display">
        Weapon: <span id="current-weapon">Fists</span>
    </div>

    <button id="quit-btn">QUIT TO MENU</button>
    <div id="coins-display">Coins: <span id="coins-count">0</span></div>
    <button id="shop-btn">SHOP</button>

    <!-- Shop Page -->
    <div id="shop-page">
        <div class="shop-header">
            <h1 class="shop-title">Duck Mart</h1>
            <div class="shop-coins">Coins: <span id="shop-coins">0</span></div>
        </div>

        <div class="shop-section">
            <h3>Extra Lives</h3>
            <div class="shop-items" id="shop-lives"></div>
        </div>

        <div class="shop-section">
            <h3>Premium Bird Variants</h3>
            <div class="shop-items" id="shop-birds"></div>
        </div>

        <div class="shop-section">
            <h3>Weapons (This Game)</h3>
            <div class="shop-items" id="shop-weapons"></div>
        </div>

        <div class="shop-section">
            <h3>Extras</h3>
            <div class="shop-items" id="shop-extras"></div>
            <h3>Stat Upgrades (Permanent)</h3>
            <div class="shop-items" id="shop-stats"></div>
        </div>

        <button class="shop-back-btn" onclick="closeShop()">Back to Game</button>
    </div>
    
    <div id="ability-bar">
        <div id="ability-fill"></div>
        <div id="ability-text">ABILITY READY - Press Q</div>
    </div>
    <div id="ability-prompt">Press Q for Special Ability!</div>
    
    <button id="special-btn">
        <span id="special-icon">‚òÖ</span>
        <span id="special-count">0</span>
        <span id="special-name">Special</span>
    </button>

    <div id="mobile-controls">
        <div id="joystick-container">
            <div id="joystick-thumb"></div>
        </div>
        <div class="mobile-action-btns">
            <div class="mobile-btn" id="mobile-ability">
                <span class="btn-icon">‚ö°</span>
                <span>ABILITY</span>
            </div>
            <div class="mobile-btn" id="mobile-jump">
                <span class="btn-icon">‚Üë</span>
                <span>JUMP</span>
            </div>
            <div class="mobile-btn" id="mobile-special">
                <span class="btn-icon">‚òÖ</span>
                <span>SPECIAL</span>
            </div>
            <div class="mobile-btn" id="mobile-attack">
                <span class="btn-icon">‚öîÔ∏è</span>
                <span>ATTACK</span>
            </div>
        </div>
    </div>

    <div id="crosshair"></div>

    <!-- Main Menu -->
    <div id="main-menu">
        <div class="menu-title">Duck Defense 3D</div>
        <div class="menu-subtitle">Survive the hunter invasion!</div>
        <div class="menu-buttons">
            <button class="menu-btn" id="play-btn">PLAY GAME</button>
            <button class="menu-btn secondary" id="settings-menu-btn">SETTINGS</button>
            <button class="menu-btn secondary" id="stats-btn">STATISTICS</button>
        </div>
    </div>

    <!-- Settings Page -->
    <div id="settings-page">
        <div class="settings-panel">
            <h2>Game Settings</h2>
            
            <div class="setting-row">
                <div class="setting-header">
                    <span class="setting-label">Difficulty</span>
                </div>
                <div class="difficulty-btns">
                    <button class="diff-btn" data-diff="easy">Easy</button>
                    <button class="diff-btn active" data-diff="normal">Normal</button>
                    <button class="diff-btn" data-diff="hard">Hard</button>
                </div>
            </div>

            <div class="setting-row">
                <div class="setting-header">
                    <span class="setting-label">Input Method</span>
                </div>
                <div class="input-btns">
                    <button class="input-btn active" data-input="computer">Computer</button>
                    <button class="input-btn" data-input="mobile">Mobile</button>
                </div>
            </div>

            <div class="setting-row">
                <div class="setting-header">
                    <span class="setting-label">Game Mode</span>
                </div>
                <div class="mode-btns">
                    <button class="mode-btn active" data-mode="survival">Survival</button>
                    <button class="mode-btn" data-mode="endless">Endless</button>
                    <button class="mode-btn" data-mode="bossRush">Boss Rush</button>
                    <button class="mode-btn" data-mode="timeAttack">Time Attack</button>
                </div>
            </div>

            <div class="setting-row">
                <div class="setting-header">
                    <span class="setting-label">Character Selection</span>
                </div>
                <div class="character-btns">
                    <button class="char-btn active" data-char="duck">Duck</button>
                    <button class="char-btn" data-char="titanTurkey">Turkey Trotter</button>
                    <button class="char-btn" data-char="kungPowChicken">Kung Pow Chicken</button>
                    <button class="char-btn" data-char="mericaMallard">Merica Mallard</button>
                    <button class="char-btn" data-char="chick7">Chick 7</button>
                    <button class="char-btn" data-char="loonatic">Loonatic</button>
                    <button class="char-btn" data-char="eggySurprise">Eggy Surprise</button>
                    <button class="char-btn locked" data-char="goldenDuck">Golden Duck</button>
                    <button class="char-btn locked" data-char="phoenixFowl">Phoenix Fowl</button>
                    <button class="char-btn locked" data-char="robotRooster">Robot Rooster</button>
                    <button class="char-btn locked" data-char="poultrygeist">Poultrygeist</button>
                    <button class="char-btn locked" data-char="duckNorris">Duck Norris</button>
                    <button class="char-btn locked" data-char="quackula">Quackula</button>
                    <button class="char-btn locked" data-char="frickinChickin">Frickin Chickin</button>
                </div>
                <div class="char-description" id="char-description">Classic yellow duck - balanced gameplay</div>
            </div>

            <div class="setting-row">
                <div class="setting-header">
                    <span class="setting-label">Companion Upgrades</span>
                </div>
                <div class="upgrade-toggles" id="upgrade-toggles" style="display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap;">
                    <!-- Toggles will be injected here -->
                </div>
            </div>

            <div class="settings-footer">
                <button class="back-btn" id="settings-back-btn">BACK TO MENU</button>
            </div>
        </div>
    </div>
                    <button class="mode-btn" data-mode="endless">Endless Horde</button>
                    <button class="mode-btn" data-mode="bossRush">Boss Rush</button>
                    <button class="mode-btn" data-mode="timeAttack">Time Attack</button>
                </div>
            </div>
            <div class="setting-row" style="flex-direction: column; align-items: flex-start;">
                <span class="setting-label" style="margin-bottom: 10px;">Your Stats (from Shop Upgrades)</span>
                <div class="player-stats-display" id="player-stats-display">
                    <div class="stat-item">Speed: <span id="stat-speed">100%</span></div>
                    <div class="stat-item">Attack Speed: <span id="stat-attack">100%</span></div>
                    <div class="stat-item">Jump Height: <span id="stat-jump">100%</span></div>
                    <div class="stat-item">Luck: <span id="stat-luck">100%</span></div>
                </div>
            </div>
            <button class="back-btn" id="settings-back-btn">BACK TO MENU</button>
        </div>
    </div>

    <!-- Stats Page -->
    <div id="stats-page">
        <div class="stats-container">
            <h2>Your Statistics</h2>
            <div class="stats-graph">
                <h3>Score History</h3>
                <canvas id="score-graph"></canvas>
            </div>
            <div class="stats-grid" id="stats-grid">
                <!-- Stats will be populated dynamically -->
            </div>
            <button class="back-btn" id="stats-back-btn">BACK TO MENU</button>
        </div>
    </div>

    <div id="game-over">
        <h1>GAME OVER!</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <div style="display: flex; flex-direction: column; gap: 10px; align-items: center;">
            <button id="restart-btn">PLAY AGAIN</button>
            <button id="shop-continue-btn" style="background: #FFD700; color: #333;">VISIT SHOP TO CONTINUE</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ==================== GAME SETTINGS (persisted) ====================
        const defaultSettings = {
            difficulty: 'normal',
            inputMethod: 'computer',
            gameMode: 'survival',
            character: 'duck'
        };
        
        // Character configurations
        // Primary ability = Q key (cooldown-based, always available)
        // Special ability = Orb-powered (collect orbs from enemies)
        const characterConfig = {
            duck: {
                name: 'Duck',
                description: 'Classic yellow duck - balanced gameplay',
                colors: { body: 0xFFFF00, head: 0xFFFF00, beak: 0xFFA500, wing: 0xFFDD00 },
                ability: null,
                abilityCooldown: 0,
                special: null,
                specialName: 'None',
                orbColor: 0xFFFF00,
                maxJumps: 2
            },
            titanTurkey: {
                name: 'Turkey Trotter',
                description: 'Helmet Charge (Q) + Turkey Stomp special! Heavy - 1 jump only.',
                colors: { body: 0x8B4513, head: 0xCC3333, beak: 0xFFAA00, wing: 0x6B3513 },
                ability: 'helmetCharge',
                abilityCooldown: 15000,
                abilityDuration: 10000,
                special: 'turkeyStomp',
                specialName: 'Turkey Stomp',
                orbColor: 0xFF6600,
                maxJumps: 1
            },
            kungPowChicken: {
                name: 'Kung Pow Chicken',
                description: 'Quack Fu (spinning kicks & wing chops) with every attack! Agile - 4 jumps!',
                colors: { body: 0xFFFFFF, head: 0xFFFFFF, beak: 0xFFCC00, wing: 0xEEEEEE },
                ability: 'martialArts',
                abilityCooldown: 8000,
                abilityDuration: 5000,
                special: 'ninjaVanish',
                specialName: 'Ninja Vanish',
                orbColor: 0x9400D3,
                maxJumps: 4
            },
            mericaMallard: {
                name: 'Merica Mallard',
                description: 'Eagle Strike (Q) + Freedom Bombs special!',
                colors: { body: 0x002868, head: 0x002868, beak: 0xBF0A30, wing: 0xFFFFFF },
                ability: 'eagleStrike',
                abilityCooldown: 12000,
                abilityDuration: 0,
                special: 'freedomBombs',
                specialName: 'Freedom Bombs',
                orbColor: 0xFFD700,
                maxJumps: 2
            },
            chick7: {
                name: 'Chick 7',
                description: '67 Windy Wing tornado attack! Invulnerable during special! 3 jumps!',
                colors: { body: 0xFFEB3B, head: 0xFFEB3B, beak: 0xFF9800, wing: 0xFFC107 },
                ability: null,
                abilityCooldown: 0,
                special: 'windyWing67',
                specialName: '67 Windy Wing',
                orbColor: 0x00BCD4,
                maxJumps: 3
            },
            loonatic: {
                name: 'Loonatic',
                description: 'Berserker Rage - 80% faster weapon recharge for 10s!',
                colors: { body: 0x1A1A2E, head: 0x2D2D44, beak: 0xFF4444, wing: 0x16213E },
                ability: null,
                abilityCooldown: 0,
                special: 'berserkerRage',
                specialName: 'Berserker Rage',
                orbColor: 0xFF0000,
                maxJumps: 2
            },
            eggySurprise: {
                name: 'Eggy Surprise',
                description: 'Roll around as an egg! Eggsplosion on death transforms you!',
                colors: { body: 0xFFFACD, head: 0xFFFACD, beak: 0xFFD700, wing: 0xFFF8DC },
                ability: null,
                abilityCooldown: 0,
                special: null,
                specialName: 'Eggsplosion',
                orbColor: 0xFFD700,
                isEgg: true,
                maxJumps: 1
            },
            goldenDuck: {
                name: 'Golden Duck',
                description: 'Shiny golden duck - earn 2x coins from kills!',
                colors: { body: 0xFFD700, head: 0xFFD700, beak: 0xFF8C00, wing: 0xFFC125 },
                ability: null,
                abilityCooldown: 0,
                special: null,
                specialName: 'None',
                orbColor: 0xFFD700,
                maxJumps: 2,
                coinMultiplier: 2
            },
            phoenixFowl: {
                name: 'Phoenix Fowl',
                description: 'Fiery bird - immune to explosions! Burn aura damages nearby enemies!',
                colors: { body: 0xFF4500, head: 0xFF6347, beak: 0xFFD700, wing: 0xFF0000 },
                ability: 'fireAura',
                abilityCooldown: 10000,
                abilityDuration: 5000,
                special: 'phoenixRebirth',
                specialName: 'Phoenix Rebirth',
                orbColor: 0xFF4500,
                maxJumps: 3,
                explosionImmune: true
            },
            robotRooster: {
                name: 'Robot Rooster',
                description: 'Mechanical menace - 50% faster attack speed! Laser eyes!',
                colors: { body: 0x708090, head: 0x778899, beak: 0xB0C4DE, wing: 0x4682B4 },
                ability: 'laserEyes',
                abilityCooldown: 6000,
                abilityDuration: 0,
                special: 'overcharge',
                specialName: 'Overcharge',
                orbColor: 0x00FFFF,
                maxJumps: 2,
                attackSpeedMultiplier: 0.5
            },
            poultrygeist: {
                name: 'Poultrygeist',
                description: 'Spectral chicken - summon a doppelganger clone!',
                colors: { body: 0x88AACC, head: 0x99BBDD, beak: 0xAADDFF, wing: 0x7799BB },
                ability: 'haunt',
                abilityCooldown: 8000,
                abilityDuration: 0,
                special: 'doppelgangerDuo',
                specialName: 'Doppelganger Duo',
                orbColor: 0x88FFFF,
                maxJumps: 3,
                isGhost: true
            },
            duckNorris: {
                name: 'Duck Norris',
                description: 'Martial arts legend - devastating roundhouse kicks!',
                colors: { body: 0xD2691E, head: 0xDEB887, beak: 0xFF8C00, wing: 0x8B4513 },
                ability: 'roundhouseKick',
                abilityCooldown: 5000,
                abilityDuration: 0,
                special: 'chuckFlurry',
                specialName: 'Chuck Flurry',
                orbColor: 0xFF4500,
                maxJumps: 3,
                meleeDamageBonus: 1.5
            },
            quackula: {
                name: 'Quackula',
                description: 'Vampire duck - drain life from your enemies!',
                colors: { body: 0x1a1a2e, head: 0x16213e, beak: 0x8B0000, wing: 0x0f3460 },
                ability: 'bloodDrain',
                abilityCooldown: 10000,
                abilityDuration: 5000,
                special: 'batSwarm',
                specialName: 'Bat Swarm',
                orbColor: 0x8B0000,
                maxJumps: 3,
                lifesteal: 0.15
            },
            frickinChickin: {
                name: 'Frickin Chickin',
                description: 'Egg Bomber (Q) drops explosive eggs from butt while airborne! Special: turns into giant egg!',
                colors: { body: 0xFF5500, head: 0xFF5500, beak: 0xFFCC00, wing: 0xFF8800 },
                ability: 'eggBomber',
                abilityCooldown: 3000,
                abilityDuration: 0,
                special: 'giantEggTransform',
                specialName: 'Giant Egg',
                orbColor: 0xFFFFFF,
                maxJumps: 3
            }
        };
        
        function loadSettings() {
            const saved = localStorage.getItem('duckDefenseSettings');
            return saved ? JSON.parse(saved) : { ...defaultSettings };
        }
        
        function saveSettings() {
            localStorage.setItem('duckDefenseSettings', JSON.stringify(gameSettings));
        }
        
        const gameSettings = loadSettings();
        
        // Difficulty multipliers
        const difficultyConfig = {
            easy: { spawnRate: 4000, enemyHealth: 0.7, enemyDamage: 0.5, enemySpeed: 0.7 },
            normal: { spawnRate: 3000, enemyHealth: 1.0, enemyDamage: 1.0, enemySpeed: 1.0 },
            hard: { spawnRate: 2000, enemyHealth: 1.5, enemyDamage: 1.5, enemySpeed: 1.3 }
        };

        // ==================== STATS SYSTEM ====================
        function loadAllStats() {
            const saved = localStorage.getItem('duckDefenseStats');
            const defaultStats = {
                highScore: 0,
                totalKills: 0,
                totalTime: 0,
                totalVehicleTime: 0,
                weaponKills: {},
                games: [],
                coins: 0,
                unlockedCharacters: ['duck', 'titanTurkey', 'kungPowChicken', 'mericaMallard', 'chick7', 'loonatic', 'eggySurprise'],
                unlockedWeapons: ['pistol'],
                upgrades: {
                    speed: 0,
                    attackSpeed: 0,
                    jumpHeight: 0,
                    luck: 0
                }
            };
            if (!saved) return defaultStats;
            const stats = JSON.parse(saved);
            if (!stats.unlockedWeapons) stats.unlockedWeapons = ['pistol'];
            if (!stats.unlockedCharacters) stats.unlockedCharacters = defaultStats.unlockedCharacters;
            if (!stats.upgrades) stats.upgrades = defaultStats.upgrades;
            return { ...defaultStats, ...stats };
        }
        
        function saveAllStats() {
            localStorage.setItem('duckDefenseStats', JSON.stringify(allTimeStats));
        }
        
        const allTimeStats = loadAllStats();
        
        // Current session stats
        const sessionStats = {
            kills: 0,
            timeAlive: 0,
            vehicleTime: 0,
            vehicleKills: 0,
            weaponKills: {},
            weaponsUsed: new Set()
        };
        
        function resetSessionStats() {
            sessionStats.kills = 0;
            sessionStats.timeAlive = 0;
            sessionStats.vehicleTime = 0;
            sessionStats.vehicleKills = 0;
            sessionStats.weaponKills = {};
            sessionStats.weaponsUsed = new Set();
        }
        
        function trackKill(weaponOrType) {
            sessionStats.kills++;
            sessionStats.weaponKills[weaponOrType] = (sessionStats.weaponKills[weaponOrType] || 0) + 1;
            sessionStats.weaponsUsed.add(weaponOrType);
        }
        
        function recordGameEnd(score, timeAlive) {
            allTimeStats.games.push({
                score: score,
                time: timeAlive,
                date: Date.now(),
                difficulty: gameSettings.difficulty
            });
            allTimeStats.totalKills += sessionStats.kills;
            allTimeStats.totalTime += timeAlive;
            allTimeStats.totalVehicleTime += sessionStats.vehicleTime;
            
            for (const [weapon, kills] of Object.entries(sessionStats.weaponKills)) {
                allTimeStats.weaponKills[weapon] = (allTimeStats.weaponKills[weapon] || 0) + kills;
            }
            
            // Keep only last 50 games for graph
            if (allTimeStats.games.length > 50) {
                allTimeStats.games = allTimeStats.games.slice(-50);
            }
            
            saveAllStats();
        }

        // ==================== GAME STATE ====================
        const gameState = {
            kills: 0,
            lives: 3,
            currentWeapon: 'pistol',
            isGameOver: false,
            isPaused: true,
            playing: false,
            enemySpawnRate: 3000,
            lastSpawnTime: 0,
            gameStartTime: 0,
            gameTime: 0,
            vehicle: null,
            coins: 0
        };
        
        // Load saved coins from localStorage
        const savedCoins = localStorage.getItem('duckDefenseCoins');
        if (savedCoins) gameState.coins = parseInt(savedCoins) || 0;
        
        // Shop items configuration
        const shopItems = {
            lives: [
                { id: 'extraLife', name: 'Extra Life', description: '+1 life during this game', price: 50, type: 'consumable' },
                { id: 'fullHeal', name: 'Full Heal', description: 'Restore all 3 lives', price: 100, type: 'consumable' },
                { id: 'shield', name: 'Shield', description: 'Block the next hit (stacks up to 3)', price: 75, type: 'shield' }
            ],
            birds: [
                { id: 'goldenDuck', name: 'Golden Duck', description: 'Shiny golden duck - earn 2x coins!', price: 500, type: 'character', unlockId: 'goldenDuck' },
                { id: 'phoenixFowl', name: 'Phoenix Fowl', description: 'Fiery bird - immune to explosions!', price: 750, type: 'character', unlockId: 'phoenixFowl' },
                { id: 'frickinChickin', name: 'Frickin Chickin', description: 'Aerial egg bomber - drop explosions from above!', price: 800, type: 'character', unlockId: 'frickinChickin' },
                { id: 'robotRooster', name: 'Robot Rooster', description: 'Mechanical menace - faster attack speed!', price: 1000, type: 'character', unlockId: 'robotRooster' },
                { id: 'poultrygeist', name: 'Poultrygeist', description: 'Spectral ghost bird - summon a clone!', price: 850, type: 'character', unlockId: 'poultrygeist' },
                { id: 'duckNorris', name: 'Duck Norris', description: 'Martial arts master - roundhouse kicks!', price: 900, type: 'character', unlockId: 'duckNorris' },
                { id: 'quackula', name: 'Quackula', description: 'Vampire duck - lifesteal on hits!', price: 1200, type: 'character', unlockId: 'quackula' }
            ],
            weapons: [
                { id: 'buySword', name: 'Sword', description: 'Unlock sword for this game', price: 30, type: 'weapon', weaponId: 'sword' },
                { id: 'buyHammer', name: 'Hammer', description: 'Unlock hammer for this game', price: 40, type: 'weapon', weaponId: 'hammer' },
                { id: 'buyRifle', name: 'Rifle', description: 'Unlock rifle for this game', price: 60, type: 'weapon', weaponId: 'rifle' },
                { id: 'buyMachineGun', name: 'Machine Gun', description: 'Unlock machine gun for this game', price: 80, type: 'weapon', weaponId: 'machineGun' },
                { id: 'buyCatapult', name: 'Catapult', description: 'Unlock catapult for this game', price: 100, type: 'weapon', weaponId: 'catapult' },
                { id: 'buyCannon', name: 'Cannon', description: 'Unlock cannon for this game', price: 150, type: 'weapon', weaponId: 'cannon' },
                { id: 'buyFlamethrower', name: 'Flamethrower', description: 'Continuous fire stream that ignites enemies', price: 200, type: 'weapon', weaponId: 'flamethrower' },
                { id: 'buyLightning', name: 'Tesla Coil', description: 'Chain lightning that jumps between enemies', price: 250, type: 'weapon', weaponId: 'lightning' },
                { id: 'buyBoomerang', name: 'Boomerang', description: 'Returns to you, hitting enemies twice', price: 120, type: 'weapon', weaponId: 'boomerang' }
            ],
            extras: [
                { id: 'sideChick', name: 'Side Chick', description: 'A tiny pistol-wielding companion that fights at your side!', price: 200, type: 'companion', permanent: true }
            ],
            statBuffs: [
                { id: 'speedUp', name: 'Speed Boost', description: '+10% movement speed (permanent)', price: 300, type: 'statBuff', stat: 'speed', amount: 0.1 },
                { id: 'attackSpeedUp', name: 'Quick Draw', description: '+10% attack speed (permanent)', price: 350, type: 'statBuff', stat: 'attackSpeed', amount: 0.1 },
                { id: 'jumpUp', name: 'Spring Legs', description: '+15% jump height (permanent)', price: 250, type: 'statBuff', stat: 'jumpHeight', amount: 0.15 },
                { id: 'luckUp', name: 'Lucky Feather', description: '+10% better drop rates (permanent)', price: 400, type: 'statBuff', stat: 'luck', amount: 0.1 }
            ]
        };
        
        // Persistent stat buffs
        let playerStats = {
            speed: 1.0,
            attackSpeed: 1.0,
            jumpHeight: 1.0,
            luck: 1.0
        };
        const savedStats = localStorage.getItem('duckDefensePlayerStats');
        if (savedStats) playerStats = JSON.parse(savedStats);
        
        function savePlayerStats() {
            localStorage.setItem('duckDefensePlayerStats', JSON.stringify(playerStats));
        }
        
        // Companion state
        let sideChick = null;
        let doppelganger = null;
        
        // Unlocked characters (persists across sessions)
        let unlockedCharacters = ['duck', 'titanTurkey', 'kungPowChicken', 'mericaMallard', 'chick7', 'loonatic', 'eggySurprise'];
        const savedUnlocks = localStorage.getItem('duckDefenseUnlocks');
        if (savedUnlocks) unlockedCharacters = JSON.parse(savedUnlocks);
        
        // Permanent upgrades (Side Chick, etc)
        let permanentUpgrades = {
            sideChick: false
        };
        const savedPermUpgrades = localStorage.getItem('duckDefensePermUpgrades');
        if (savedPermUpgrades) permanentUpgrades = JSON.parse(savedPermUpgrades);

        // Upgrade settings (toggles)
        let upgradeSettings = {
            sideChick: true
        };
        const savedUpgradeSettings = localStorage.getItem('duckDefenseUpgradeSettings');
        if (savedUpgradeSettings) upgradeSettings = JSON.parse(savedUpgradeSettings);

        function savePermanentUpgrades() {
            localStorage.setItem('duckDefensePermUpgrades', JSON.stringify(permanentUpgrades));
            localStorage.setItem('duckDefenseUpgradeSettings', JSON.stringify(upgradeSettings));
        }
        
        // Weapons unlocked this game session (pistol is always available)
        let sessionWeapons = ['pistol'];

        // ==================== WEAPONS CONFIG ====================
        const weapons = {
            pistol: { damage: 15, range: 25, cooldown: 800, type: 'projectile', speed: 0.8 },
            fists: { damage: 10, range: 3, cooldown: 500, type: 'melee' },
            sword: { damage: 30, range: 5, cooldown: 400, type: 'melee' },
            hammer: { damage: 50, range: 4, cooldown: 800, type: 'melee' },
            rifle: { damage: 80, range: 100, cooldown: 600, type: 'projectile', speed: 1.2 },
            machineGun: { damage: 50, range: 20, cooldown: 150, type: 'projectile', speed: 1.0 },
            catapult: { damage: 60, range: 40, cooldown: 1500, type: 'arc', speed: 0.3 },
            cannon: { damage: 100, range: 50, cooldown: 2000, type: 'projectile', speed: 0.5, aoe: 5 },
            flamethrower: { damage: 8, range: 12, cooldown: 50, type: 'stream', speed: 0.4, burnDamage: 5 },
            'lightning': { damage: 45, range: 30, cooldown: 1000, type: 'chain', speed: 0.6, chainCount: 4 },
            boomerang: { damage: 35, range: 25, cooldown: 1200, type: 'returning', speed: 0.5 }
        };

        // ==================== SCENE SETUP ====================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x6B8E7F); // Murky marsh sky
        scene.fog = new THREE.Fog(0x8B9A8E, 20, 70); // Humid marsh fog

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.left = '0';
        renderer.domElement.style.zIndex = '0';
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(20, 40, 20);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -60;
        directionalLight.shadow.camera.right = 60;
        directionalLight.shadow.camera.top = 60;
        directionalLight.shadow.camera.bottom = -60;
        scene.add(directionalLight);

        // ==================== TERRAIN ====================
        const terrainSize = 100;
        const terrainSegments = 50;
        const obstacles = [];
        
        function getTerrainHeight(x, z) {
            const scale = 0.05;
            return Math.sin(x * scale) * Math.cos(z * scale) * 3 + 
                   Math.sin(x * scale * 0.3) * 2;
        }

        const groundGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSegments, terrainSegments);
        const vertices = groundGeometry.attributes.position.array;
        
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 1];
            vertices[i + 2] = getTerrainHeight(x, z);
        }
        
        groundGeometry.computeVertexNormals();
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3D5A3D }); // Darker marsh ground
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Dark murky swamp water patches with enhanced aesthetics
        const waterZones = [];
        for (let i = 0; i < 40; i++) {
            const radius = Math.random() * 4 + 2;
            const waterGeom = new THREE.CircleGeometry(radius, 16);
            const waterMat = new THREE.MeshLambertMaterial({ color: 0x2F4538, transparent: true, opacity: 0.8 }); // Dark swamp water
            const water = new THREE.Mesh(waterGeom, waterMat);
            water.rotation.x = -Math.PI / 2;
            const x = (Math.random() - 0.5) * 90;
            const z = (Math.random() - 0.5) * 90;
            const terrainY = getTerrainHeight(x, z);
            water.position.set(x, terrainY + 0.05, z);
            scene.add(water);
            
            // Add lily pads floating on larger ponds
            if (radius > 3) {
                for (let j = 0; j < 3; j++) {
                    const lilyGeom = new THREE.CircleGeometry(0.4, 8);
                    const lilyMat = new THREE.MeshLambertMaterial({ color: 0x4A6741 });
                    const lily = new THREE.Mesh(lilyGeom, lilyMat);
                    lily.rotation.x = -Math.PI / 2;
                    const angle = (j / 3) * Math.PI * 2 + Math.random();
                    const dist = radius * 0.5 * Math.random();
                    lily.position.set(x + Math.cos(angle) * dist, terrainY + 0.1, z + Math.sin(angle) * dist);
                    scene.add(lily);
                }
            }
            
            // Add reeds/cattails around pond edges
            const reedCount = Math.floor(radius * 2);
            for (let j = 0; j < reedCount; j++) {
                const reedGeom = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 4);
                const reedMat = new THREE.MeshLambertMaterial({ color: 0x5C6F4E });
                const reed = new THREE.Mesh(reedGeom, reedMat);
                const angle = (j / reedCount) * Math.PI * 2;
                const edgeDist = radius + 0.3 + Math.random() * 0.3;
                reed.position.set(x + Math.cos(angle) * edgeDist, terrainY + 0.75, z + Math.sin(angle) * edgeDist);
                reed.rotation.z = (Math.random() - 0.5) * 0.2;
                scene.add(reed);
                
                // Cattail bulb on top
                const bulbGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.3, 6);
                const bulbMat = new THREE.MeshLambertMaterial({ color: 0x6B4423 });
                const bulb = new THREE.Mesh(bulbGeom, bulbMat);
                bulb.position.set(
                    x + Math.cos(angle) * edgeDist,
                    terrainY + 1.5,
                    z + Math.sin(angle) * edgeDist
                );
                scene.add(bulb);
            }
            
            waterZones.push({ position: new THREE.Vector3(x, 0, z), radius: radius });
        }

        // Cypress trees with spanish moss (collision obstacles)
        function createTree() {
            const tree = new THREE.Group();
            
            // Wider base, narrow top - cypress style
            const trunkGeom = new THREE.CylinderGeometry(0.25, 0.5, 5, 8);
            const trunkMat = new THREE.MeshLambertMaterial({ color: 0x4A3C28 }); // Dark cypress bark
            const trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // Sparse canopy
            const leavesGeom = new THREE.ConeGeometry(1.5, 3, 8);
            const leavesMat = new THREE.MeshLambertMaterial({ color: 0x4A6741 }); // Darker cypress green
            const leaves = new THREE.Mesh(leavesGeom, leavesMat);
            leaves.position.y = 5.5;
            leaves.castShadow = true;
            tree.add(leaves);
            
            // Spanish moss hanging down
            for (let i = 0; i < 3; i++) {
                const mossGeom = new THREE.BoxGeometry(0.1, 1.5, 0.1);
                const mossMat = new THREE.MeshLambertMaterial({ color: 0x8B9467 }); // Grayish-green moss
                const moss = new THREE.Mesh(mossGeom, mossMat);
                moss.position.set(
                    (Math.random() - 0.5) * 1.5,
                    4.2,
                    (Math.random() - 0.5) * 1.5
                );
                moss.rotation.z = (Math.random() - 0.5) * 0.3;
                tree.add(moss);
            }
            
            return tree;
        }

        for (let i = 0; i < 40; i++) {
            const tree = createTree();
            const x = (Math.random() - 0.5) * 80;
            const z = (Math.random() - 0.5) * 80;
            if (Math.abs(x) > 10 || Math.abs(z) > 10) {
                const terrainY = getTerrainHeight(x, z);
                tree.position.set(x, terrainY, z);
                scene.add(tree);
                obstacles.push({ 
                    position: new THREE.Vector3(x, 0, z), 
                    radius: 0.5, 
                    type: 'tree',
                    walkableHeight: terrainY + 5  // Top of trunk at y=5 from base
                });
            }
        }

        // Swamp vegetation - palmetto bushes (slow movement)
        const bushZones = [];
        function createBush() {
            const bushGeom = new THREE.SphereGeometry(1, 6, 6);
            const bushMat = new THREE.MeshLambertMaterial({ color: 0x3A4F3A }); // Darker swamp vegetation
            const bush = new THREE.Mesh(bushGeom, bushMat);
            bush.scale.set(1.2, 0.5, 1.2);
            bush.castShadow = true;
            return bush;
        }

        for (let i = 0; i < 60; i++) {
            const bush = createBush();
            const x = (Math.random() - 0.5) * 90;
            const z = (Math.random() - 0.5) * 90;
            bush.position.set(x, getTerrainHeight(x, z) + 0.3, z);
            scene.add(bush);
            bushZones.push({ position: new THREE.Vector3(x, 0, z), radius: 1.2 });
        }

        // Garbage piles - aesthetic swamp trash
        function createGarbagePile() {
            const pile = new THREE.Group();
            
            // Various junk pieces
            for (let i = 0; i < 5; i++) {
                const junkGeom = new THREE.BoxGeometry(
                    Math.random() * 0.5 + 0.2,
                    Math.random() * 0.4 + 0.1,
                    Math.random() * 0.5 + 0.2
                );
                const junkColors = [0x3A3A3A, 0x5C4033, 0x2F2F2F, 0x8B4513];
                const junkMat = new THREE.MeshLambertMaterial({ color: junkColors[Math.floor(Math.random() * junkColors.length)] });
                const junk = new THREE.Mesh(junkGeom, junkMat);
                junk.position.set(
                    (Math.random() - 0.5) * 0.8,
                    Math.random() * 0.3,
                    (Math.random() - 0.5) * 0.8
                );
                junk.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                pile.add(junk);
            }
            
            return pile;
        }

        for (let i = 0; i < 12; i++) {
            const garbagePile = createGarbagePile();
            const x = (Math.random() - 0.5) * 70;
            const z = (Math.random() - 0.5) * 70;
            garbagePile.position.set(x, getTerrainHeight(x, z), z);
            scene.add(garbagePile);
        }

        // Glowing lanterns - atmospheric marsh lighting
        function createLantern() {
            const lantern = new THREE.Group();
            
            // Pole
            const poleGeom = new THREE.CylinderGeometry(0.05, 0.05, 2.5, 6);
            const poleMat = new THREE.MeshLambertMaterial({ color: 0x2F2F2F });
            const pole = new THREE.Mesh(poleGeom, poleMat);
            pole.position.y = 1.25;
            lantern.add(pole);
            
            // Lantern cage
            const cageGeom = new THREE.BoxGeometry(0.3, 0.4, 0.3);
            const cageMat = new THREE.MeshLambertMaterial({ color: 0x1A1A1A });
            const cage = new THREE.Mesh(cageGeom, cageMat);
            cage.position.y = 2.6;
            lantern.add(cage);
            
            // Glowing light inside
            const lightGeom = new THREE.SphereGeometry(0.15, 8, 8);
            const lightMat = new THREE.MeshLambertMaterial({ 
                color: 0xFFAA00, 
                emissive: 0xFFAA00, 
                emissiveIntensity: 1 
            });
            const light = new THREE.Mesh(lightGeom, lightMat);
            light.position.y = 2.6;
            lantern.add(light);
            
            // Point light for glow
            const pointLight = new THREE.PointLight(0xFFAA00, 0.5, 8);
            pointLight.position.y = 2.6;
            lantern.add(pointLight);
            
            return lantern;
        }

        for (let i = 0; i < 10; i++) {
            const lantern = createLantern();
            const angle = (i / 10) * Math.PI * 2;
            const distance = 20 + Math.random() * 15;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            lantern.position.set(x, getTerrainHeight(x, z), z);
            scene.add(lantern);
        }

        // Hut (collision obstacle) - Complex marsh-blended design
        function createHut() {
            const hut = new THREE.Group();
            
            // Weathered wooden stilts/supports for swamp
            const stiltMat = new THREE.MeshLambertMaterial({ color: 0x3A2817 });
            for (let i = 0; i < 4; i++) {
                const stiltGeom = new THREE.CylinderGeometry(0.2, 0.25, 2, 6);
                const stilt = new THREE.Mesh(stiltGeom, stiltMat);
                const x = i < 2 ? -3 : 3;
                const z = i % 2 === 0 ? -3 : 3;
                stilt.position.set(x, 1, z);
                stilt.castShadow = true;
                hut.add(stilt);
            }
            
            // Main cabin - weathered wood planks
            const baseGeom = new THREE.BoxGeometry(8, 4, 8);
            const baseMat = new THREE.MeshLambertMaterial({ color: 0x5C4033 }); // Darker weathered wood
            const base = new THREE.Mesh(baseGeom, baseMat);
            base.position.y = 2;
            base.castShadow = true;
            hut.add(base);
            
            // Horizontal planks detail
            for (let i = 0; i < 5; i++) {
                const plankGeom = new THREE.BoxGeometry(8.1, 0.15, 8.1);
                const plankMat = new THREE.MeshLambertMaterial({ color: 0x4A3528 });
                const plank = new THREE.Mesh(plankGeom, plankMat);
                plank.position.y = 0.5 + i * 0.8;
                hut.add(plank);
            }
            
            // Mossy overgrowth on sides
            const mossMat = new THREE.MeshLambertMaterial({ color: 0x6B8E6B });
            for (let i = 0; i < 8; i++) {
                const mossGeom = new THREE.BoxGeometry(0.2, 1.2, 0.3);
                const moss = new THREE.Mesh(mossGeom, mossMat);
                const angle = (i / 8) * Math.PI * 2;
                moss.position.set(Math.cos(angle) * 4.1, 2 + Math.random(), Math.sin(angle) * 4.1);
                moss.rotation.y = angle;
                hut.add(moss);
            }
            
            // Thatched roof - darker swamp reeds
            const roofGeom = new THREE.ConeGeometry(6, 3, 4);
            const roofMat = new THREE.MeshLambertMaterial({ color: 0x6B5D4F }); // Dark thatch
            const roof = new THREE.Mesh(roofGeom, roofMat);
            roof.position.y = 5.5;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            hut.add(roof);
            
            // Roof moss patches
            for (let i = 0; i < 6; i++) {
                const roofMossGeom = new THREE.BoxGeometry(1, 0.1, 1);
                const roofMoss = new THREE.Mesh(roofMossGeom, mossMat);
                const angle = (i / 6) * Math.PI * 2;
                roofMoss.position.set(Math.cos(angle) * 2, 5.5 + Math.random() * 0.5, Math.sin(angle) * 2);
                roofMoss.rotation.y = angle;
                hut.add(roofMoss);
            }
            
            // Small door
            const doorGeom = new THREE.BoxGeometry(1.5, 2.5, 0.1);
            const doorMat = new THREE.MeshLambertMaterial({ color: 0x2F1F10 });
            const door = new THREE.Mesh(doorGeom, doorMat);
            door.position.set(0, 1.5, 4.05);
            hut.add(door);
            
            return hut;
        }

        const hut = createHut();
        scene.add(hut);
        obstacles.push({ 
            position: new THREE.Vector3(0, 0, 0), 
            radius: 4.5,
            type: 'hut',
            walkableHeight: 4  // Top of base at y=4
        });

        // ==================== DUCK PLAYER ====================
        function createDuck() {
            return createCharacter('duck');
        }
        
        function createCharacter(charType) {
            const config = characterConfig[charType] || characterConfig.duck;
            const bird = new THREE.Group();
            bird.userData.charType = charType;
            
            const bodyGeom = new THREE.SphereGeometry(0.6, 8, 8);
            const bodyMat = new THREE.MeshLambertMaterial({ color: config.colors.body });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.scale.y = 1.2;
            body.castShadow = true;
            bird.add(body);
            bird.userData.body = body;
            
            const headGeom = new THREE.SphereGeometry(0.4, 8, 8);
            const headMat = new THREE.MeshLambertMaterial({ color: config.colors.head });
            const head = new THREE.Mesh(headGeom, headMat);
            head.position.y = 0.8;
            head.castShadow = true;
            bird.add(head);
            bird.userData.head = head;
            
            const beakGeom = new THREE.ConeGeometry(0.15, 0.3, 4);
            const beakMat = new THREE.MeshLambertMaterial({ color: config.colors.beak });
            const beak = new THREE.Mesh(beakGeom, beakMat);
            beak.rotation.x = Math.PI / 2;
            beak.position.set(0, 0.8, 0.4);
            beak.castShadow = true;
            bird.add(beak);
            
            const eyeGeom = new THREE.SphereGeometry(0.08, 6, 6);
            const eyeMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
            leftEye.position.set(-0.15, 0.9, 0.3);
            const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
            rightEye.position.set(0.15, 0.9, 0.3);
            bird.add(leftEye, rightEye);
            
            // Wings
            const wingGeom = new THREE.BoxGeometry(0.8, 0.1, 0.5);
            const wingMat = new THREE.MeshLambertMaterial({ color: config.colors.wing });
            const leftWing = new THREE.Mesh(wingGeom, wingMat);
            leftWing.position.set(-0.5, 0.2, 0);
            leftWing.rotation.z = -Math.PI / 6;
            leftWing.castShadow = true;
            bird.add(leftWing);
            bird.userData.leftWing = leftWing;
            
            const rightWing = new THREE.Mesh(wingGeom, wingMat);
            rightWing.position.set(0.5, 0.2, 0);
            rightWing.rotation.z = Math.PI / 6;
            rightWing.castShadow = true;
            bird.add(rightWing);
            bird.userData.rightWing = rightWing;
            
            // Character-specific features
            if (charType === 'titanTurkey') {
                // Bigger, more muscular body
                body.scale.set(1.2, 1.3, 1.2);
                
                // Turkey wattle (larger and more prominent)
                const wattleGeom = new THREE.SphereGeometry(0.2, 6, 6);
                const wattleMat = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                const wattle = new THREE.Mesh(wattleGeom, wattleMat);
                wattle.scale.y = 2;
                wattle.position.set(0, 0.55, 0.4);
                bird.add(wattle);
                
                // Turkey snood (red dangly bit on beak)
                const snoodGeom = new THREE.CylinderGeometry(0.05, 0.02, 0.2, 6);
                const snood = new THREE.Mesh(snoodGeom, wattleMat);
                snood.position.set(0, 0.7, 0.5);
                snood.rotation.x = 0.3;
                bird.add(snood);
                
                // Tail fan feathers
                const tailMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                for (let i = -2; i <= 2; i++) {
                    const featherGeom = new THREE.BoxGeometry(0.15, 0.5, 0.03);
                    const feather = new THREE.Mesh(featherGeom, tailMat);
                    feather.position.set(i * 0.12, 0.3, -0.5);
                    feather.rotation.x = -0.4;
                    feather.rotation.z = i * 0.15;
                    bird.add(feather);
                }
                
                // Shoulder pads (football style, always visible)
                const padMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                const padGeom = new THREE.BoxGeometry(0.3, 0.15, 0.2);
                const leftPad = new THREE.Mesh(padGeom, padMat);
                leftPad.position.set(-0.55, 0.4, 0);
                leftPad.rotation.z = -0.3;
                bird.add(leftPad);
                const rightPad = new THREE.Mesh(padGeom, padMat);
                rightPad.position.set(0.55, 0.4, 0);
                rightPad.rotation.z = 0.3;
                bird.add(rightPad);
                
                // Football helmet (hidden until ability active)
                const helmetGeom = new THREE.SphereGeometry(0.48, 8, 8);
                const helmetMat = new THREE.MeshLambertMaterial({ color: 0x1E90FF });
                const helmet = new THREE.Mesh(helmetGeom, helmetMat);
                helmet.position.y = 0.85;
                helmet.scale.set(1.1, 0.9, 1.1);
                helmet.visible = false;
                bird.add(helmet);
                bird.userData.helmet = helmet;
                
                // Facemask
                const maskGeom = new THREE.TorusGeometry(0.22, 0.025, 4, 8);
                const maskMat = new THREE.MeshLambertMaterial({ color: 0xCCCCCC });
                const mask = new THREE.Mesh(maskGeom, maskMat);
                mask.position.set(0, 0.85, 0.42);
                mask.rotation.x = Math.PI / 2;
                mask.visible = false;
                bird.add(mask);
                bird.userData.facemask = mask;
            }
            
            if (charType === 'kungPowChicken') {
                // Large red headband wrapped around head
                const bandGeom = new THREE.TorusGeometry(0.42, 0.06, 6, 16);
                const bandMat = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                const band = new THREE.Mesh(bandGeom, bandMat);
                band.position.y = 0.95;
                band.rotation.x = Math.PI / 2;
                bird.add(band);
                
                // Long tail ribbons flowing behind
                const ribbonGeom = new THREE.BoxGeometry(0.06, 0.5, 0.02);
                const ribbon1 = new THREE.Mesh(ribbonGeom, bandMat);
                ribbon1.position.set(-0.25, 0.75, -0.35);
                ribbon1.rotation.z = 0.4;
                ribbon1.rotation.x = -0.2;
                const ribbon2 = new THREE.Mesh(ribbonGeom, bandMat);
                ribbon2.position.set(-0.35, 0.65, -0.35);
                ribbon2.rotation.z = 0.6;
                ribbon2.rotation.x = -0.3;
                bird.add(ribbon1, ribbon2);
                
                // White Gi (martial arts uniform) - body wrap
                const giMat = new THREE.MeshLambertMaterial({ color: 0xFAFAFA });
                
                // Gi jacket front panels (v-neck style)
                const giPanelGeom = new THREE.BoxGeometry(0.35, 0.6, 0.1);
                const giLeft = new THREE.Mesh(giPanelGeom, giMat);
                giLeft.position.set(-0.2, 0.1, 0.45);
                giLeft.rotation.y = 0.3;
                bird.add(giLeft);
                const giRight = new THREE.Mesh(giPanelGeom, giMat);
                giRight.position.set(0.2, 0.1, 0.45);
                giRight.rotation.y = -0.3;
                bird.add(giRight);
                
                // Gi collar
                const collarGeom = new THREE.BoxGeometry(0.12, 0.5, 0.08);
                const collarLeft = new THREE.Mesh(collarGeom, giMat);
                collarLeft.position.set(-0.15, 0.3, 0.5);
                collarLeft.rotation.z = 0.2;
                bird.add(collarLeft);
                const collarRight = new THREE.Mesh(collarGeom, giMat);
                collarRight.position.set(0.15, 0.3, 0.5);
                collarRight.rotation.z = -0.2;
                bird.add(collarRight);
                
                // Black belt around waist
                const beltGeom = new THREE.TorusGeometry(0.55, 0.05, 4, 16);
                const beltMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
                const belt = new THREE.Mesh(beltGeom, beltMat);
                belt.position.y = -0.15;
                belt.rotation.x = Math.PI / 2;
                bird.add(belt);
                
                // Belt knot in front
                const knotGeom = new THREE.BoxGeometry(0.15, 0.08, 0.1);
                const knot = new THREE.Mesh(knotGeom, beltMat);
                knot.position.set(0, -0.15, 0.55);
                bird.add(knot);
                
                // Belt tails hanging down
                const tailGeom = new THREE.BoxGeometry(0.06, 0.25, 0.03);
                const beltTail1 = new THREE.Mesh(tailGeom, beltMat);
                beltTail1.position.set(-0.08, -0.35, 0.55);
                beltTail1.rotation.z = 0.15;
                bird.add(beltTail1);
                const beltTail2 = new THREE.Mesh(tailGeom, beltMat);
                beltTail2.position.set(0.08, -0.35, 0.55);
                beltTail2.rotation.z = -0.15;
                bird.add(beltTail2);
            }
            
            if (charType === 'mericaMallard') {
                // Uncle Sam top hat with stripes
                const hatBrimGeom = new THREE.CylinderGeometry(0.45, 0.45, 0.06, 16);
                const hatBrimMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const hatBrim = new THREE.Mesh(hatBrimGeom, hatBrimMat);
                hatBrim.position.y = 1.15;
                bird.add(hatBrim);
                
                // Hat body with red and white stripes
                const redMat = new THREE.MeshLambertMaterial({ color: 0xBF0A30 });
                const whiteMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                for (let i = 0; i < 5; i++) {
                    const stripeGeom = new THREE.CylinderGeometry(0.28, 0.28, 0.1, 16);
                    const stripe = new THREE.Mesh(stripeGeom, i % 2 === 0 ? redMat : whiteMat);
                    stripe.position.y = 1.23 + i * 0.1;
                    bird.add(stripe);
                }
                
                // Blue band with stars at top
                const blueBandGeom = new THREE.CylinderGeometry(0.29, 0.29, 0.15, 16);
                const blueMat = new THREE.MeshLambertMaterial({ color: 0x002868 });
                const blueBand = new THREE.Mesh(blueBandGeom, blueMat);
                blueBand.position.y = 1.65;
                bird.add(blueBand);
                
                // Stars around the blue band
                const starMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                for (let i = 0; i < 5; i++) {
                    const starGeom = new THREE.SphereGeometry(0.04, 4, 4);
                    const star = new THREE.Mesh(starGeom, starMat);
                    const angle = (i / 5) * Math.PI * 2;
                    star.position.set(Math.sin(angle) * 0.3, 1.65, Math.cos(angle) * 0.3);
                    bird.add(star);
                }
                
                // American flag cape
                const capeMat = new THREE.MeshLambertMaterial({ color: 0xBF0A30, side: THREE.DoubleSide });
                const capeGeom = new THREE.PlaneGeometry(0.8, 0.6);
                const cape = new THREE.Mesh(capeGeom, capeMat);
                cape.position.set(0, 0.1, -0.5);
                cape.rotation.x = 0.2;
                bird.add(cape);
                
                // Blue corner on cape
                const capeBlueGeom = new THREE.PlaneGeometry(0.3, 0.25);
                const capeBlue = new THREE.Mesh(capeBlueGeom, blueMat);
                capeBlue.position.set(-0.25, 0.25, -0.49);
                capeBlue.rotation.x = 0.2;
                bird.add(capeBlue);
                
                // Bow tie
                const bowMat = new THREE.MeshLambertMaterial({ color: 0xBF0A30 });
                const bowGeom = new THREE.BoxGeometry(0.25, 0.1, 0.08);
                const bow = new THREE.Mesh(bowGeom, bowMat);
                bow.position.set(0, 0.5, 0.5);
                bird.add(bow);
                const bowKnot = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 6), blueMat);
                bowKnot.position.set(0, 0.5, 0.55);
                bird.add(bowKnot);
            }
            
            if (charType === 'chick7') {
                // Baby chick with "67" marking and fluffy appearance
                // Fluffy feathers on top
                const fluffGeom = new THREE.SphereGeometry(0.15, 6, 6);
                const fluffMat = new THREE.MeshLambertMaterial({ color: 0xFFEB3B });
                for (let i = 0; i < 5; i++) {
                    const fluff = new THREE.Mesh(fluffGeom, fluffMat);
                    fluff.position.set(
                        (Math.random() - 0.5) * 0.3,
                        1.1 + Math.random() * 0.15,
                        (Math.random() - 0.5) * 0.2
                    );
                    bird.add(fluff);
                }
                
                // Wings stored for 67 animation
                bird.userData.wing67Phase = 0;
            }
            
            if (charType === 'loonatic') {
                // Crazy eyes (red and different sizes)
                leftEye.material = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                rightEye.material = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                leftEye.scale.set(1.2, 1.5, 1);
                rightEye.scale.set(0.8, 1.2, 1);
                
                // Spiky crest like a mohawk
                const spikeMat = new THREE.MeshLambertMaterial({ color: 0x4A0000 });
                for (let i = 0; i < 5; i++) {
                    const spike = new THREE.Mesh(
                        new THREE.ConeGeometry(0.06, 0.25, 4),
                        spikeMat
                    );
                    spike.position.set(0, 1.1 + i * 0.08, -0.1 - i * 0.05);
                    spike.rotation.x = -0.3;
                    bird.add(spike);
                }
                
                // Rage aura (hidden until active)
                const auraGeom = new THREE.SphereGeometry(1.2, 8, 8);
                const auraMat = new THREE.MeshBasicMaterial({ 
                    color: 0xFF0000, 
                    transparent: true, 
                    opacity: 0.2,
                    visible: false
                });
                const aura = new THREE.Mesh(auraGeom, auraMat);
                bird.add(aura);
                bird.userData.rageAura = aura;
            }
            
            if (charType === 'eggySurprise') {
                // Replace the bird with an egg shape
                body.geometry = new THREE.SphereGeometry(0.7, 12, 12);
                body.scale.set(0.9, 1.3, 0.9);
                body.material.color.setHex(0xFFFACD);
                
                // Hide normal head and features
                head.visible = false;
                beak.visible = false;
                leftEye.position.set(-0.15, 0.4, 0.5);
                rightEye.position.set(0.15, 0.4, 0.5);
                leftWing.visible = false;
                rightWing.visible = false;
                
                // Add egg spots/specks
                const speckMat = new THREE.MeshLambertMaterial({ color: 0xD4A574 });
                for (let i = 0; i < 8; i++) {
                    const speck = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 4, 4),
                        speckMat
                    );
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI - Math.PI / 2;
                    speck.position.set(
                        Math.cos(theta) * Math.cos(phi) * 0.65,
                        Math.sin(phi) * 0.85,
                        Math.sin(theta) * Math.cos(phi) * 0.65
                    );
                    bird.add(speck);
                }
                
                // Crack overlays (hidden until damaged)
                const crackGroup = new THREE.Group();
                crackGroup.visible = false;
                bird.add(crackGroup);
                bird.userData.cracks = crackGroup;
                bird.userData.crackLevel = 0;
                
                // Yolk drip (hidden until heavily damaged)
                const yolkGeom = new THREE.SphereGeometry(0.2, 8, 8);
                const yolkMat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
                const yolk = new THREE.Mesh(yolkGeom, yolkMat);
                yolk.position.set(0, -0.8, 0.3);
                yolk.scale.y = 1.5;
                yolk.visible = false;
                bird.add(yolk);
                bird.userData.yolkDrip = yolk;
            }
            
            if (charType === 'goldenDuck') {
                // Shiny golden appearance with sparkles
                const shineMat = new THREE.MeshLambertMaterial({ 
                    color: 0xFFD700,
                    emissive: 0x996600,
                    emissiveIntensity: 0.2
                });
                body.material = shineMat;
                head.material = shineMat.clone();
                
                // Crown
                const crownMat = new THREE.MeshLambertMaterial({ color: 0xFFD700, emissive: 0xCC9900, emissiveIntensity: 0.3 });
                const crownBase = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.3, 0.1, 8), crownMat);
                crownBase.position.y = 1.15;
                bird.add(crownBase);
                
                // Crown points
                for (let i = 0; i < 5; i++) {
                    const point = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.2, 4), crownMat);
                    const angle = (i / 5) * Math.PI * 2;
                    point.position.set(Math.sin(angle) * 0.2, 1.3, Math.cos(angle) * 0.2);
                    bird.add(point);
                }
                
                // Gem on crown
                const gem = new THREE.Mesh(
                    new THREE.OctahedronGeometry(0.08),
                    new THREE.MeshBasicMaterial({ color: 0xFF0000 })
                );
                gem.position.set(0, 1.35, 0.2);
                bird.add(gem);
            }
            
            if (charType === 'phoenixFowl') {
                // Fiery appearance with flame particles
                const flameMat = new THREE.MeshLambertMaterial({ 
                    color: 0xFF4500,
                    emissive: 0xFF2200,
                    emissiveIntensity: 0.4
                });
                
                // Flame crest on head
                for (let i = 0; i < 7; i++) {
                    const flame = new THREE.Mesh(
                        new THREE.ConeGeometry(0.08, 0.3 + Math.random() * 0.2, 4),
                        new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? 0xFF4500 : 0xFFD700 })
                    );
                    flame.position.set((i - 3) * 0.08, 1.2 + Math.random() * 0.1, -0.1);
                    flame.rotation.z = (Math.random() - 0.5) * 0.3;
                    bird.add(flame);
                }
                
                // Fire tail feathers
                for (let i = -2; i <= 2; i++) {
                    const tailFlame = new THREE.Mesh(
                        new THREE.ConeGeometry(0.1, 0.6, 4),
                        new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? 0xFF0000 : 0xFF8C00 })
                    );
                    tailFlame.position.set(i * 0.12, 0.2, -0.55);
                    tailFlame.rotation.x = -0.5;
                    tailFlame.rotation.z = i * 0.1;
                    bird.add(tailFlame);
                }
                
                // Fire aura (always visible but subtle)
                const fireAura = new THREE.Mesh(
                    new THREE.SphereGeometry(1.0, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xFF4500, transparent: true, opacity: 0.15 })
                );
                bird.add(fireAura);
                bird.userData.fireAura = fireAura;
            }
            
            if (charType === 'robotRooster') {
                // Metallic body with mechanical features
                const metalMat = new THREE.MeshLambertMaterial({ color: 0x708090 });
                
                // Antenna on head
                const antenna = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.02, 0.4, 6),
                    metalMat
                );
                antenna.position.set(0, 1.3, 0);
                bird.add(antenna);
                
                // Antenna ball
                const antennaBall = new THREE.Mesh(
                    new THREE.SphereGeometry(0.06, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0x00FFFF })
                );
                antennaBall.position.set(0, 1.5, 0);
                bird.add(antennaBall);
                bird.userData.antennaBall = antennaBall;
                
                // Mechanical eyes (glowing cyan)
                leftEye.material = new THREE.MeshBasicMaterial({ color: 0x00FFFF });
                rightEye.material = new THREE.MeshBasicMaterial({ color: 0x00FFFF });
                leftEye.scale.set(1, 1, 0.5);
                rightEye.scale.set(1, 1, 0.5);
                
                // Chest panel
                const panel = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 0.3, 0.05),
                    new THREE.MeshLambertMaterial({ color: 0x333333 })
                );
                panel.position.set(0, 0.2, 0.55);
                bird.add(panel);
                
                // LED lights on panel
                for (let i = 0; i < 3; i++) {
                    const led = new THREE.Mesh(
                        new THREE.SphereGeometry(0.03, 6, 6),
                        new THREE.MeshBasicMaterial({ color: [0xFF0000, 0x00FF00, 0x0000FF][i] })
                    );
                    led.position.set((i - 1) * 0.1, 0.2, 0.6);
                    bird.add(led);
                }
                
                // Mechanical wings (visible joints)
                const jointMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const leftJoint = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), jointMat);
                leftJoint.position.set(-0.5, 0.2, 0);
                bird.add(leftJoint);
                const rightJoint = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), jointMat);
                rightJoint.position.set(0.5, 0.2, 0);
                bird.add(rightJoint);
            }
            
            if (charType === 'poultrygeist') {
                // Spectral ghost appearance - make body semi-transparent
                body.material = new THREE.MeshLambertMaterial({ 
                    color: 0x88AACC, 
                    transparent: true, 
                    opacity: 0.7 
                });
                head.material = new THREE.MeshLambertMaterial({ 
                    color: 0x99BBDD, 
                    transparent: true, 
                    opacity: 0.75 
                });
                leftWing.material = new THREE.MeshLambertMaterial({ 
                    color: 0x7799BB, 
                    transparent: true, 
                    opacity: 0.6 
                });
                rightWing.material = new THREE.MeshLambertMaterial({ 
                    color: 0x7799BB, 
                    transparent: true, 
                    opacity: 0.6 
                });
                
                // Glowing ghost eyes
                leftEye.material = new THREE.MeshBasicMaterial({ color: 0x88FFFF });
                rightEye.material = new THREE.MeshBasicMaterial({ color: 0x88FFFF });
                
                // Wispy tail instead of normal body shape
                const tailGeom = new THREE.ConeGeometry(0.4, 1.2, 8);
                const tailMat = new THREE.MeshLambertMaterial({ 
                    color: 0x6688AA, 
                    transparent: true, 
                    opacity: 0.5 
                });
                const tail = new THREE.Mesh(tailGeom, tailMat);
                tail.position.set(0, -0.8, 0);
                tail.rotation.x = Math.PI;
                bird.add(tail);
                bird.userData.ghostTail = tail;
                
                // Ethereal glow aura
                const auraGeom = new THREE.SphereGeometry(0.9, 12, 12);
                const auraMat = new THREE.MeshBasicMaterial({ 
                    color: 0x88FFFF, 
                    transparent: true, 
                    opacity: 0.15 
                });
                const aura = new THREE.Mesh(auraGeom, auraMat);
                bird.add(aura);
                bird.userData.ghostAura = aura;
                
                // Floating chains (ghostly touch)
                const chainMat = new THREE.MeshLambertMaterial({ 
                    color: 0x556677, 
                    transparent: true, 
                    opacity: 0.4 
                });
                for (let i = 0; i < 3; i++) {
                    const link = new THREE.Mesh(
                        new THREE.TorusGeometry(0.08, 0.02, 4, 8),
                        chainMat
                    );
                    link.position.set(-0.3, -0.5 - i * 0.15, 0);
                    link.rotation.y = Math.PI / 2;
                    bird.add(link);
                }
            }
            
            if (charType === 'duckNorris') {
                // Muscular martial artist duck
                body.scale.set(1.1, 1.2, 1.1);
                
                // Red headband
                const headbandGeom = new THREE.TorusGeometry(0.35, 0.04, 6, 16);
                const headbandMat = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                const headband = new THREE.Mesh(headbandGeom, headbandMat);
                headband.position.set(0, 1.0, 0);
                headband.rotation.x = Math.PI / 2;
                bird.add(headband);
                
                // Headband tails
                const tailMat = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                [-0.3, -0.35].forEach((y, i) => {
                    const tail = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.25, 0.02),
                        tailMat
                    );
                    tail.position.set(-0.35, 0.9 + y, -0.1 - i * 0.05);
                    tail.rotation.z = 0.3;
                    bird.add(tail);
                });
                
                // Muscular arms (bigger wings)
                leftWing.scale.set(1.3, 1.5, 1.2);
                rightWing.scale.set(1.3, 1.5, 1.2);
                
                // Tough expression - thicker brow
                const browGeom = new THREE.BoxGeometry(0.35, 0.06, 0.1);
                const browMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const brow = new THREE.Mesh(browGeom, browMat);
                brow.position.set(0, 1.0, 0.32);
                bird.add(brow);
            }
            
            if (charType === 'quackula') {
                // Vampire duck - dark and mysterious
                leftEye.material = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                rightEye.material = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                
                // Vampire cape
                const capeGeom = new THREE.ConeGeometry(0.8, 1.5, 8, 1, true);
                const capeMat = new THREE.MeshLambertMaterial({ 
                    color: 0x1a0a2e, 
                    side: THREE.DoubleSide 
                });
                const cape = new THREE.Mesh(capeGeom, capeMat);
                cape.position.set(0, 0, -0.3);
                cape.rotation.x = -0.2;
                bird.add(cape);
                
                // Cape collar (high collar)
                const collarGeom = new THREE.BoxGeometry(0.8, 0.4, 0.1);
                const collarMat = new THREE.MeshLambertMaterial({ color: 0x4a0a4e });
                const collar = new THREE.Mesh(collarGeom, collarMat);
                collar.position.set(0, 0.5, -0.35);
                collar.rotation.x = -0.4;
                bird.add(collar);
                
                // Fangs
                const fangMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                [-0.06, 0.06].forEach(x => {
                    const fang = new THREE.Mesh(
                        new THREE.ConeGeometry(0.03, 0.1, 4),
                        fangMat
                    );
                    fang.position.set(x, 0.65, 0.35);
                    fang.rotation.x = Math.PI;
                    bird.add(fang);
                });
                
                // Slicked back hair/feathers
                const hairMat = new THREE.MeshLambertMaterial({ color: 0x0a0a1e });
                const hair = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 8, 8),
                    hairMat
                );
                hair.position.set(0, 1.0, -0.15);
                hair.scale.set(1.2, 0.6, 1.5);
                bird.add(hair);
            }
            
            return bird;
        }

        function createWeaponModel(weaponType) {
            const weapon = new THREE.Group();
            
            switch(weaponType) {
                case 'pistol':
                    // Simple pistol model
                    const pistolBarrel = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 6);
                    const pistolMat = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
                    const pBarrel = new THREE.Mesh(pistolBarrel, pistolMat);
                    pBarrel.rotation.z = Math.PI / 2;
                    pBarrel.position.x = 0.3;
                    weapon.add(pBarrel);
                    
                    const pistolBody = new THREE.BoxGeometry(0.2, 0.15, 0.08);
                    const pBody = new THREE.Mesh(pistolBody, pistolMat);
                    pBody.position.set(0.05, 0, 0);
                    weapon.add(pBody);
                    
                    const pistolGrip = new THREE.BoxGeometry(0.08, 0.2, 0.06);
                    const gripMat = new THREE.MeshLambertMaterial({ color: 0x4a3520 });
                    const pGrip = new THREE.Mesh(pistolGrip, gripMat);
                    pGrip.position.set(-0.02, -0.15, 0);
                    pGrip.rotation.z = 0.2;
                    weapon.add(pGrip);
                    break;
                    
                case 'sword':
                    const bladeGeom = new THREE.BoxGeometry(0.12, 2.0, 0.06);
                    const bladeMat = new THREE.MeshLambertMaterial({ color: 0xE0E0E0 });
                    const blade = new THREE.Mesh(bladeGeom, bladeMat);
                    blade.position.y = 1.0;
                    weapon.add(blade);
                    
                    // Blade edge highlight
                    const edgeGeom = new THREE.BoxGeometry(0.02, 2.0, 0.06);
                    const edgeMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                    const edge = new THREE.Mesh(edgeGeom, edgeMat);
                    edge.position.set(0.055, 1.0, 0);
                    weapon.add(edge);
                    
                    const handleGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 6);
                    const handleMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const handle = new THREE.Mesh(handleGeom, handleMat);
                    handle.position.y = -0.25;
                    weapon.add(handle);
                    
                    // Crossguard/Hilt
                    const guardGeom = new THREE.BoxGeometry(0.5, 0.08, 0.08);
                    const guardMat = new THREE.MeshLambertMaterial({ color: 0xDAA520 });
                    const guard = new THREE.Mesh(guardGeom, guardMat);
                    guard.position.y = 0;
                    weapon.add(guard);
                    
                    // Pommel
                    const pommelGeom = new THREE.SphereGeometry(0.12, 6, 6);
                    const pommel = new THREE.Mesh(pommelGeom, guardMat);
                    pommel.position.y = -0.5;
                    weapon.add(pommel);
                    break;
                    
                case 'hammer':
                    const hammerHeadGeom = new THREE.BoxGeometry(0.8, 0.8, 0.5);
                    const hammerHeadMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
                    const hammerHead = new THREE.Mesh(hammerHeadGeom, hammerHeadMat);
                    hammerHead.position.y = 1.5;
                    weapon.add(hammerHead);
                    
                    // Metal band on hammer head
                    const bandGeom = new THREE.BoxGeometry(0.82, 0.15, 0.52);
                    const bandMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
                    const band = new THREE.Mesh(bandGeom, bandMat);
                    band.position.y = 1.5;
                    weapon.add(band);
                    
                    const hammerHandleGeom = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 6);
                    const hammerHandleMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
                    const hammerHandle = new THREE.Mesh(hammerHandleGeom, hammerHandleMat);
                    hammerHandle.position.y = 0.75;
                    weapon.add(hammerHandle);
                    
                    // Handle grip
                    const gripGeom = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
                    const hammerGripMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const grip = new THREE.Mesh(gripGeom, hammerGripMat);
                    grip.position.y = 0.3;
                    weapon.add(grip);
                    break;
                    
                case 'rifle':
                case 'machineGun':
                    const barrelGeom = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
                    const gunMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    const barrel = new THREE.Mesh(barrelGeom, gunMat);
                    barrel.rotation.z = Math.PI / 2;
                    barrel.position.x = 0.5;
                    weapon.add(barrel);
                    
                    const stockGeom = new THREE.BoxGeometry(0.3, 0.15, 0.1);
                    const stock = new THREE.Mesh(stockGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    stock.position.x = -0.1;
                    weapon.add(stock);
                    break;
                    
                case 'catapult':
                    const catapultBaseGeom = new THREE.BoxGeometry(0.8, 0.3, 0.6);
                    const catapultBase = new THREE.Mesh(catapultBaseGeom, new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                    catapultBase.position.y = 0.15;
                    weapon.add(catapultBase);
                    
                    const catapultArmGeom = new THREE.BoxGeometry(0.08, 1.0, 0.08);
                    const catapultArm = new THREE.Mesh(catapultArmGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    catapultArm.position.y = 0.65;
                    weapon.add(catapultArm);
                    
                    // Spoon/bucket
                    const spoonGeom = new THREE.BoxGeometry(0.3, 0.1, 0.3);
                    const spoon = new THREE.Mesh(spoonGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    spoon.position.y = 1.1;
                    weapon.add(spoon);
                    
                    // Support beams
                    const supportGeom = new THREE.BoxGeometry(0.1, 0.6, 0.1);
                    const support1 = new THREE.Mesh(supportGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    support1.position.set(-0.3, 0.45, 0);
                    support1.rotation.z = -0.3;
                    weapon.add(support1);
                    const support2 = new THREE.Mesh(supportGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    support2.position.set(0.3, 0.45, 0);
                    support2.rotation.z = 0.3;
                    weapon.add(support2);
                    break;
                    
                case 'cannon':
                    const cannonBarrelGeom = new THREE.CylinderGeometry(0.25, 0.2, 1.2, 8);
                    const cannonBarrel = new THREE.Mesh(cannonBarrelGeom, new THREE.MeshLambertMaterial({ color: 0x333333 }));
                    cannonBarrel.rotation.z = Math.PI / 2;
                    cannonBarrel.position.set(0.6, 0.3, 0);
                    weapon.add(cannonBarrel);
                    
                    // Cannon mouth rim
                    const rimGeom = new THREE.CylinderGeometry(0.26, 0.25, 0.1, 8);
                    const rim = new THREE.Mesh(rimGeom, new THREE.MeshLambertMaterial({ color: 0x666666 }));
                    rim.rotation.z = Math.PI / 2;
                    rim.position.set(1.15, 0.3, 0);
                    weapon.add(rim);
                    
                    // Carriage base
                    const carriageGeom = new THREE.BoxGeometry(0.6, 0.2, 0.5);
                    const carriage = new THREE.Mesh(carriageGeom, new THREE.MeshLambertMaterial({ color: 0x654321 }));
                    carriage.position.y = 0.1;
                    weapon.add(carriage);
                    
                    const wheelGeom = new THREE.CylinderGeometry(0.15, 0.15, 0.08, 8);
                    const wheel1 = new THREE.Mesh(wheelGeom, new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                    wheel1.rotation.x = Math.PI / 2;
                    wheel1.position.set(0, 0.15, -0.3);
                    weapon.add(wheel1);
                    const wheel2 = new THREE.Mesh(wheelGeom, new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                    wheel2.rotation.x = Math.PI / 2;
                    wheel2.position.set(0, 0.15, 0.3);
                    weapon.add(wheel2);
                    break;
            }
            
            weapon.scale.set(0.8, 0.8, 0.8);
            return weapon;
        }

        const player = {
            mesh: createCharacter(gameSettings.character),
            velocity: new THREE.Vector3(),
            position: new THREE.Vector3(8, 1, 0), // Start outside hut
            lookAngle: 0,
            isJumping: false,
            jumpsUsed: 0,
            maxJumps: characterConfig[gameSettings.character].maxJumps || 2,
            canAttack: true,
            lastAttackTime: 0,
            weaponModel: null,
            wingFlapTime: 0,
            wing67Time: 0,
            isGliding: false,
            bloodDripCounter: 0,
            // Ability system (Q key - cooldown based)
            abilityActive: false,
            abilityEndTime: 0,
            abilityCooldownEnd: 0,
            comboCount: 0,
            lastComboTime: 0,
            // Special system (orb powered)
            specialCharges: 0,
            specialActive: false,
            specialEndTime: 0,
            isInvisible: false,
            isInvulnerable: false,
            // Shield system
            shields: 0,
            berserkerRage: false
        };

        player.mesh.position.copy(player.position);
        scene.add(player.mesh);

        function updatePlayerWeapon() {
            if (player.weaponModel) {
                player.mesh.remove(player.weaponModel);
            }
            
            if (gameState.currentWeapon !== 'fists') {
                player.weaponModel = createWeaponModel(gameState.currentWeapon);
                player.weaponModel.position.set(0.5, 0.3, 0);
                player.weaponModel.rotation.z = -Math.PI / 4;
                player.mesh.add(player.weaponModel);
            } else {
                player.weaponModel = null;
            }
        }

        // ==================== MOUSE INPUT ====================
        let mouseX = 0;
        let mouseY = 0;

        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // ==================== ENEMIES ====================
        const enemies = [];
        const bloodParticles = [];

        function createHunter(type = 'basic') {
            const hunter = new THREE.Group();
            hunter.userData.type = type;
            
            if (type === 'hulk') {
                // Hulk Hunter - Huge, green, carries a club
                const bodyGeom = new THREE.CylinderGeometry(0.8, 0.9, 2.5, 8);
                const bodyMat = new THREE.MeshLambertMaterial({ color: 0x556B2F }); // Olive green
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.position.y = 1.25;
                body.castShadow = true;
                hunter.add(body);
                
                // Massive head
                const headGeom = new THREE.SphereGeometry(0.6, 8, 8);
                const headMat = new THREE.MeshLambertMaterial({ color: 0x8FBC8F }); // Dark sea green
                const head = new THREE.Mesh(headGeom, headMat);
                head.position.y = 3.0;
                head.castShadow = true;
                hunter.add(head);
                
                // Angry eyes
                const eyeGeom = new THREE.SphereGeometry(0.12, 6, 6);
                const eyeMat = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
                leftEye.position.set(-0.2, 3.1, 0.5);
                const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
                rightEye.position.set(0.2, 3.1, 0.5);
                hunter.add(leftEye, rightEye);
                
                // Big muscular arms
                const armGeom = new THREE.CylinderGeometry(0.25, 0.3, 1.5, 6);
                const armMat = new THREE.MeshLambertMaterial({ color: 0x556B2F });
                const leftArm = new THREE.Mesh(armGeom, armMat);
                leftArm.position.set(-1.0, 1.8, 0);
                leftArm.rotation.z = Math.PI / 4;
                const rightArm = new THREE.Mesh(armGeom, armMat);
                rightArm.position.set(1.0, 1.8, 0);
                rightArm.rotation.z = -Math.PI / 4;
                hunter.add(leftArm, rightArm);
                
                // Giant club
                const clubHandleGeom = new THREE.CylinderGeometry(0.15, 0.12, 2.0, 6);
                const clubMat = new THREE.MeshLambertMaterial({ color: 0x4A3728 });
                const clubHandle = new THREE.Mesh(clubHandleGeom, clubMat);
                clubHandle.position.set(1.5, 2.0, 0);
                clubHandle.rotation.z = -Math.PI / 3;
                hunter.add(clubHandle);
                
                const clubHeadGeom = new THREE.SphereGeometry(0.5, 8, 8);
                const clubHead = new THREE.Mesh(clubHeadGeom, clubMat);
                clubHead.position.set(2.2, 2.8, 0);
                clubHead.scale.set(1.2, 0.8, 0.8);
                hunter.add(clubHead);
                
                // Spikes on club
                for (let i = 0; i < 6; i++) {
                    const spikeGeom = new THREE.ConeGeometry(0.1, 0.3, 4);
                    const spikeMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    const spike = new THREE.Mesh(spikeGeom, spikeMat);
                    const angle = (i / 6) * Math.PI * 2;
                    spike.position.set(
                        2.2 + Math.cos(angle) * 0.4,
                        2.8 + Math.sin(angle) * 0.3,
                        Math.sin(angle) * 0.4
                    );
                    spike.rotation.z = angle;
                    hunter.add(spike);
                }
                
                return hunter;
            }
            
            if (type === 'catapult') {
                // Catapult Hunter - Carries a portable catapult
                const bodyGeom = new THREE.CylinderGeometry(0.35, 0.35, 1.4, 6);
                const bodyMat = new THREE.MeshLambertMaterial({ color: 0x8B0000 }); // Dark red
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.position.y = 0.7;
                body.castShadow = true;
                hunter.add(body);
                
                const headGeom = new THREE.SphereGeometry(0.3, 8, 8);
                const headMat = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
                const head = new THREE.Mesh(headGeom, headMat);
                head.position.y = 1.6;
                head.castShadow = true;
                hunter.add(head);
                
                // Military helmet
                const helmetGeom = new THREE.SphereGeometry(0.35, 8, 8);
                const helmetMat = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
                const helmet = new THREE.Mesh(helmetGeom, helmetMat);
                helmet.position.y = 1.75;
                helmet.scale.y = 0.6;
                hunter.add(helmet);
                
                // Portable catapult on back
                const catBaseGeom = new THREE.BoxGeometry(0.6, 0.2, 0.4);
                const catMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
                const catBase = new THREE.Mesh(catBaseGeom, catMat);
                catBase.position.set(0, 1.2, -0.4);
                hunter.add(catBase);
                
                const catArmGeom = new THREE.BoxGeometry(0.1, 0.8, 0.1);
                const catArm = new THREE.Mesh(catArmGeom, catMat);
                catArm.position.set(0, 1.6, -0.4);
                catArm.rotation.x = -0.3;
                hunter.add(catArm);
                hunter.userData.catapultArm = catArm;
                
                // Ammo pouch
                const pouchGeom = new THREE.SphereGeometry(0.2, 6, 6);
                const pouchMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const pouch = new THREE.Mesh(pouchGeom, pouchMat);
                pouch.position.set(0.5, 0.5, 0);
                hunter.add(pouch);
                
                return hunter;
            }
            
            // Basic hunter (default)
            const bodyGeom = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 6);
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 0.6;
            body.castShadow = true;
            hunter.add(body);
            
            const headGeom = new THREE.SphereGeometry(0.3, 8, 8);
            const headMat = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
            const head = new THREE.Mesh(headGeom, headMat);
            head.position.y = 1.5;
            head.castShadow = true;
            hunter.add(head);
            
            const hatGeom = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 8);
            const hatMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const hat = new THREE.Mesh(hatGeom, hatMat);
            hat.position.y = 1.9;
            hunter.add(hat);
            
            const gunGeom = new THREE.BoxGeometry(0.1, 0.1, 0.6);
            const gunMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const gun = new THREE.Mesh(gunGeom, gunMat);
            gun.position.set(0.4, 1.0, 0);
            gun.rotation.x = -Math.PI / 6;
            hunter.add(gun);
            
            return hunter;
        }

        function createAlligator() {
            const gator = new THREE.Group();
            
            // Body - long and low
            const bodyGeom = new THREE.BoxGeometry(2.5, 0.5, 0.8);
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0x3A5F3A }); // Dark green
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 0.25;
            body.castShadow = true;
            gator.add(body);
            
            // Head - wider at the front
            const headGeom = new THREE.BoxGeometry(0.8, 0.4, 0.9);
            const head = new THREE.Mesh(headGeom, bodyMat);
            head.position.set(1.5, 0.25, 0);
            head.castShadow = true;
            gator.add(head);
            
            // Snout
            const snoutGeom = new THREE.BoxGeometry(0.5, 0.2, 0.6);
            const snout = new THREE.Mesh(snoutGeom, new THREE.MeshLambertMaterial({ color: 0x2F4F2F }));
            snout.position.set(1.9, 0.2, 0);
            gator.add(snout);
            
            // Eyes
            const eyeGeom = new THREE.SphereGeometry(0.1, 6, 6);
            const eyeMat = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
            const eye1 = new THREE.Mesh(eyeGeom, eyeMat);
            eye1.position.set(1.7, 0.4, 0.3);
            gator.add(eye1);
            const eye2 = new THREE.Mesh(eyeGeom, eyeMat);
            eye2.position.set(1.7, 0.4, -0.3);
            gator.add(eye2);
            
            // Tail
            const tailGeom = new THREE.ConeGeometry(0.4, 1.2, 4);
            const tail = new THREE.Mesh(tailGeom, bodyMat);
            tail.rotation.z = -Math.PI / 2;
            tail.position.set(-1.8, 0.25, 0);
            tail.castShadow = true;
            gator.add(tail);
            
            // Spikes on back
            for (let i = 0; i < 6; i++) {
                const spikeGeom = new THREE.ConeGeometry(0.1, 0.3, 4);
                const spike = new THREE.Mesh(spikeGeom, new THREE.MeshLambertMaterial({ color: 0x2F4F2F }));
                spike.position.set(-0.8 + i * 0.5, 0.5, 0);
                gator.add(spike);
            }
            
            return gator;
        }

        // Alligators array
        const alligators = [];
        
        // Spawn alligators near water zones
        for (let i = 0; i < 8; i++) {
            const waterZone = waterZones[Math.floor(Math.random() * waterZones.length)];
            const angle = Math.random() * Math.PI * 2;
            const dist = waterZone.radius + 1;
            const x = waterZone.position.x + Math.cos(angle) * dist;
            const z = waterZone.position.z + Math.sin(angle) * dist;
            
            const gator = {
                mesh: createAlligator(),
                position: new THREE.Vector3(x, getTerrainHeight(x, z), z),
                angle: angle,
                homePosition: new THREE.Vector3(x, 0, z),
                patrolRadius: 5,
                lastBiteTime: 0,
                biteCooldown: 2000
            };
            
            gator.mesh.position.copy(gator.position);
            gator.mesh.rotation.y = angle;
            scene.add(gator.mesh);
            alligators.push(gator);
        }

        function createBloodParticle(position, type = 'normal') {
            // Different sizes and colors based on type
            let size = 0.1;
            let color = 0x8B0000;
            let lifetime = 60;
            
            if (type === 'large') {
                size = 0.2;
                color = 0xFF0000; // Brighter red for large chunks
                lifetime = 80;
            } else if (type === 'spray') {
                size = 0.08;
                color = 0x660000; // Darker spray
                lifetime = 40;
            }
            
            const geom = new THREE.SphereGeometry(size, 4, 4);
            const mat = new THREE.MeshLambertMaterial({ color: color });
            const particle = new THREE.Mesh(geom, mat);
            particle.position.copy(position);
            particle.castShadow = true;
            scene.add(particle);
            
            // Different velocity patterns based on type
            let vel;
            if (type === 'spray') {
                vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.15,
                    Math.random() * 0.15,
                    (Math.random() - 0.5) * 0.15
                );
            } else {
                vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.4,
                    Math.random() * 0.4 + 0.2,
                    (Math.random() - 0.5) * 0.4
                );
            }
            
            bloodParticles.push({
                mesh: particle,
                velocity: vel,
                lifetime: lifetime
            });
        }

        // Wind streak particles for weapon swings
        const windStreaks = [];
        
        function createWindStreak(position, direction, weaponType) {
            // Create elongated wind streak particles
            const geom = weaponType === 'sword' ? 
                new THREE.BoxGeometry(0.15, 0.05, 0.8) : // Sword - long thin streak
                new THREE.BoxGeometry(0.2, 0.2, 0.6);     // Hammer - thicker streak
            
            const mat = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF, 
                transparent: true, 
                opacity: 0.8 
            });
            const streak = new THREE.Mesh(geom, mat);
            streak.position.copy(position);
            
            // Orient streak along swing direction
            const angle = Math.atan2(direction.x, direction.z);
            streak.rotation.y = angle;
            
            scene.add(streak);
            
            windStreaks.push({
                mesh: streak,
                velocity: direction.clone().multiplyScalar(0.3),
                lifetime: 12,
                initialOpacity: 0.8
            });
        }

        function createTruck() {
            const truck = new THREE.Group();
            const bodyGeom = new THREE.BoxGeometry(3, 1.2, 5);
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0x5a4a3a });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 1;
            body.castShadow = true;
            truck.add(body);
            const cabinGeom = new THREE.BoxGeometry(2.5, 1.5, 2);
            const cabinMat = new THREE.MeshLambertMaterial({ color: 0x3d3d3d });
            const cabin = new THREE.Mesh(cabinGeom, cabinMat);
            cabin.position.set(0, 2.2, 1);
            cabin.castShadow = true;
            truck.add(cabin);
            const bedGeom = new THREE.BoxGeometry(2.8, 0.8, 2.5);
            const bedMat = new THREE.MeshLambertMaterial({ color: 0x4a3a2a });
            const bed = new THREE.Mesh(bedGeom, bedMat);
            bed.position.set(0, 1.2, -1.2);
            truck.add(bed);
            const wheelGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 12);
            const wheelMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
            [[-1.4, 0.5, 1.5], [1.4, 0.5, 1.5], [-1.4, 0.5, -1.5], [1.4, 0.5, -1.5]].forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(...pos);
                truck.add(wheel);
            });
            return truck;
        }

        function createTank() {
            const tank = new THREE.Group();
            
            // Tank body - lower, wider, armored
            const hullGeom = new THREE.BoxGeometry(4, 1.5, 6);
            const hullMat = new THREE.MeshLambertMaterial({ color: 0x3d4a3d });
            const hull = new THREE.Mesh(hullGeom, hullMat);
            hull.position.y = 1.2;
            hull.castShadow = true;
            tank.add(hull);
            
            // Armor plating on sides
            const armorGeom = new THREE.BoxGeometry(0.3, 1.2, 5);
            const armorMat = new THREE.MeshLambertMaterial({ color: 0x2a352a });
            [-2.1, 2.1].forEach(x => {
                const armor = new THREE.Mesh(armorGeom, armorMat);
                armor.position.set(x, 1.2, 0);
                tank.add(armor);
            });
            
            // Turret base
            const turretBaseGeom = new THREE.CylinderGeometry(1.5, 1.8, 1, 12);
            const turretMat = new THREE.MeshLambertMaterial({ color: 0x4a5a4a });
            const turretBase = new THREE.Mesh(turretBaseGeom, turretMat);
            turretBase.position.set(0, 2.5, -0.5);
            turretBase.castShadow = true;
            tank.add(turretBase);
            tank.turretBase = turretBase;
            
            // Cannon barrel
            const barrelGeom = new THREE.CylinderGeometry(0.25, 0.3, 4, 8);
            const barrelMat = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
            const barrel = new THREE.Mesh(barrelGeom, barrelMat);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 2.5, -3);
            tank.add(barrel);
            tank.barrel = barrel;
            
            // Tracks (wide treads)
            const trackGeom = new THREE.BoxGeometry(0.8, 0.8, 6.5);
            const trackMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
            [-2.2, 2.2].forEach(x => {
                const track = new THREE.Mesh(trackGeom, trackMat);
                track.position.set(x, 0.5, 0);
                tank.add(track);
            });
            
            // Track wheels
            const wheelGeom = new THREE.CylinderGeometry(0.4, 0.4, 0.9, 8);
            const wheelMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
            [-2.2, 2.2].forEach(x => {
                [-2.5, -1, 0.5, 2].forEach(z => {
                    const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(x, 0.5, z);
                    tank.add(wheel);
                });
            });
            
            // Hatch on top
            const hatchGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 8);
            const hatchMat = new THREE.MeshLambertMaterial({ color: 0x3a3a3a });
            const hatch = new THREE.Mesh(hatchGeom, hatchMat);
            hatch.position.set(0, 3.1, -0.5);
            tank.add(hatch);
            
            return tank;
        }

        const vehicles = [];
        let lastTruckSpawnTime = Date.now();
        let lastTankSpawnTime = Date.now();

        function spawnTruckWithDriver() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 48;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            const terrainY = getTerrainHeight(x, z);
            
            const truck = createTruck();
            truck.position.set(x, terrainY, z);
            truck.rotation.y = angle + Math.PI;
            scene.add(truck);
            
            const driver = createHunter();
            driver.position.set(0, 2.5, 0.8);
            truck.add(driver);
            
            const vehicle = {
                mesh: truck,
                position: new THREE.Vector3(x, terrainY, z),
                rotation: angle + Math.PI,
                velocity: new THREE.Vector3(),
                hasDriver: true,
                driver: {
                    mesh: driver,
                    health: 80,
                    lastShootTime: 0,
                    shootCooldown: 1500
                }
            };
            vehicles.push(vehicle);
        }

        function spawnTankWithDriver() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 50;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            const terrainY = getTerrainHeight(x, z);
            
            const tank = createTank();
            tank.position.set(x, terrainY, z);
            tank.rotation.y = angle + Math.PI;
            scene.add(tank);
            
            const driver = createHunter();
            driver.position.set(0, 3.5, -0.5);
            driver.scale.set(0.8, 0.8, 0.8);
            tank.add(driver);
            
            const vehicle = {
                mesh: tank,
                position: new THREE.Vector3(x, terrainY, z),
                rotation: angle + Math.PI,
                velocity: new THREE.Vector3(),
                hasDriver: true,
                isTank: true,
                health: 300,
                maxHealth: 300,
                turretAngle: 0,
                driver: {
                    mesh: driver,
                    health: 150,
                    lastShootTime: 0,
                    shootCooldown: 2500
                }
            };
            vehicles.push(vehicle);
        }

        // Grenade system
        const grenades = [];
        let lastGrenadeTime = 0;
        const grenadeCooldown = 3000;
        
        function throwGrenade() {
            const now = Date.now();
            if (now - lastGrenadeTime < grenadeCooldown) return;
            if (gameState.vehicle) return; // Can't throw from vehicle
            
            lastGrenadeTime = now;
            
            // Create grenade mesh
            const grenadeGeom = new THREE.SphereGeometry(0.2, 8, 8);
            const grenadeMat = new THREE.MeshLambertMaterial({ color: 0x3a4a3a });
            const grenade = new THREE.Mesh(grenadeGeom, grenadeMat);
            
            // Add pin/handle detail
            const handleGeom = new THREE.BoxGeometry(0.05, 0.15, 0.05);
            const handleMat = new THREE.MeshLambertMaterial({ color: 0x8a8a8a });
            const handle = new THREE.Mesh(handleGeom, handleMat);
            handle.position.y = 0.2;
            grenade.add(handle);
            
            // Start position (player's offhand)
            const startPos = player.position.clone();
            startPos.y += 1.5;
            grenade.position.copy(startPos);
            scene.add(grenade);
            
            // Calculate throw direction (where player is looking)
            const throwDir = new THREE.Vector3(0, 0, -1);
            throwDir.applyQuaternion(player.mesh.quaternion);
            throwDir.y = 0.4; // Arc upward
            throwDir.normalize();
            
            grenades.push({
                mesh: grenade,
                position: startPos.clone(),
                velocity: throwDir.multiplyScalar(0.5),
                lifetime: 90,
                bounces: 0
            });
        }
        
        function updateGrenades() {
            for (let i = grenades.length - 1; i >= 0; i--) {
                const gren = grenades[i];
                
                // Apply gravity
                gren.velocity.y -= 0.015;
                
                // Update position
                gren.position.add(gren.velocity);
                gren.mesh.position.copy(gren.position);
                gren.mesh.rotation.x += 0.2;
                gren.mesh.rotation.z += 0.1;
                
                // Check terrain collision (bounce)
                const terrainY = getTerrainHeight(gren.position.x, gren.position.z);
                if (gren.position.y < terrainY + 0.2) {
                    gren.position.y = terrainY + 0.2;
                    gren.velocity.y = Math.abs(gren.velocity.y) * 0.4;
                    gren.velocity.x *= 0.7;
                    gren.velocity.z *= 0.7;
                    gren.bounces++;
                }
                
                gren.lifetime--;
                
                // Explode after timer or enough bounces
                if (gren.lifetime <= 0 || gren.bounces >= 3) {
                    explodeGrenade(gren);
                    scene.remove(gren.mesh);
                    grenades.splice(i, 1);
                }
            }
        }
        
        function explodeGrenade(gren) {
            const explosionRadius = 8;
            const damage = 80;
            
            // Explosion particles
            for (let j = 0; j < 20; j++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 6, 6),
                    new THREE.MeshLambertMaterial({ color: j % 2 === 0 ? 0xff6600 : 0x8B0000 })
                );
                particle.position.copy(gren.position);
                scene.add(particle);
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.4,
                    (Math.random() - 0.5) * 0.5
                );
                bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 30 });
            }
            
            // Damage enemies in radius
            for (let eIdx = enemies.length - 1; eIdx >= 0; eIdx--) {
                const enemy = enemies[eIdx];
                const dist = gren.position.distanceTo(enemy.position);
                if (dist < explosionRadius) {
                    const dmg = Math.ceil(damage * (1 - dist / explosionRadius));
                    enemy.health -= dmg;
                    
                    // Knockback
                    const knockDir = enemy.position.clone().sub(gren.position).normalize();
                    enemy.position.add(knockDir.multiplyScalar(2));
                    
                    if (enemy.health <= 0) {
                        handleEnemyDeath(enemy, eIdx, 'grenade');
                    } else {
                        // Blood splash
                        for (let b = 0; b < 5; b++) {
                            createBloodParticle(enemy.position.clone());
                        }
                    }
                }
            }
            
            // Damage vehicles in radius
            vehicles.forEach(vehicle => {
                if (vehicle.isTank && vehicle.hasDriver) {
                    const dist = gren.position.distanceTo(vehicle.position);
                    if (dist < explosionRadius) {
                        vehicle.health -= Math.ceil(damage * 0.5 * (1 - dist / explosionRadius));
                    }
                }
            });
        }

        // Side Chick companion system
        function createSideChickMesh() {
            const chick = new THREE.Group();
            
            // Tiny fluffy body (smaller than regular chick)
            const bodyGeom = new THREE.SphereGeometry(0.25, 8, 8);
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0xffee88 });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            chick.add(body);
            
            // Fluffy head tuft
            const tuftGeom = new THREE.ConeGeometry(0.08, 0.15, 4);
            const tuftMat = new THREE.MeshLambertMaterial({ color: 0xffdd66 });
            const tuft = new THREE.Mesh(tuftGeom, tuftMat);
            tuft.position.set(0, 0.3, 0);
            chick.add(tuft);
            
            // Tiny beak
            const beakGeom = new THREE.ConeGeometry(0.05, 0.1, 4);
            const beakMat = new THREE.MeshLambertMaterial({ color: 0xff8800 });
            const beak = new THREE.Mesh(beakGeom, beakMat);
            beak.rotation.x = Math.PI / 2;
            beak.position.set(0, 0.05, 0.25);
            chick.add(beak);
            
            // Beady eyes
            const eyeGeom = new THREE.SphereGeometry(0.04, 6, 6);
            const eyeMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
            [-0.08, 0.08].forEach(x => {
                const eye = new THREE.Mesh(eyeGeom, eyeMat);
                eye.position.set(x, 0.12, 0.18);
                chick.add(eye);
            });
            
            // Tiny pistol in wing
            const gunGeom = new THREE.CylinderGeometry(0.02, 0.02, 0.15, 4);
            const gunMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const gun = new THREE.Mesh(gunGeom, gunMat);
            gun.rotation.z = Math.PI / 2;
            gun.position.set(0.2, 0, 0.1);
            chick.add(gun);
            chick.gun = gun;
            
            return chick;
        }
        
        function spawnSideChick() {
            if (sideChick) return;
            
            const mesh = createSideChickMesh();
            const startPos = player.position.clone();
            startPos.x += 2;
            mesh.position.copy(startPos);
            mesh.position.y = getTerrainHeight(startPos.x, startPos.z) + 0.3;
            scene.add(mesh);
            
            sideChick = {
                mesh: mesh,
                position: startPos.clone(),
                lastShootTime: 0,
                shootCooldown: 1200,
                targetEnemy: null
            };
        }
        
        function updateSideChick(delta) {
            if (!sideChick) return;
            
            const now = Date.now();
            
            // Follow player at offset
            const targetPos = player.position.clone();
            targetPos.x += Math.cos(gameState.gameTime * 0.5) * 2;
            targetPos.z += Math.sin(gameState.gameTime * 0.5) * 2;
            
            const toTarget = targetPos.clone().sub(sideChick.position);
            const dist = toTarget.length();
            
            if (dist > 0.5) {
                toTarget.normalize().multiplyScalar(0.15);
                sideChick.position.add(toTarget);
            }
            
            // Hop animation
            const terrainY = getTerrainHeight(sideChick.position.x, sideChick.position.z);
            sideChick.position.y = terrainY + 0.3 + Math.abs(Math.sin(now * 0.008)) * 0.2;
            
            sideChick.mesh.position.copy(sideChick.position);
            
            // Find nearest enemy and shoot
            let nearestEnemy = null;
            let nearestDist = 15;
            
            enemies.forEach(enemy => {
                const d = sideChick.position.distanceTo(enemy.position);
                if (d < nearestDist) {
                    nearestDist = d;
                    nearestEnemy = enemy;
                }
            });
            
            if (nearestEnemy) {
                // Face enemy
                const toEnemy = nearestEnemy.position.clone().sub(sideChick.position);
                sideChick.mesh.rotation.y = Math.atan2(toEnemy.x, toEnemy.z);
                
                // Shoot at enemy
                if (now - sideChick.lastShootTime > sideChick.shootCooldown) {
                    sideChick.lastShootTime = now;
                    
                    const shootDir = toEnemy.normalize();
                    const start = sideChick.position.clone();
                    start.y += 0.1;
                    
                    // Create tiny projectile
                    const projGeom = new THREE.SphereGeometry(0.06, 4, 4);
                    const projMat = new THREE.MeshLambertMaterial({ color: 0xffff00 });
                    const projMesh = new THREE.Mesh(projGeom, projMat);
                    projMesh.position.copy(start);
                    scene.add(projMesh);
                    
                    projectiles.push({
                        mesh: projMesh,
                        velocity: shootDir.clone().multiplyScalar(0.6),
                        damage: 10,
                        lifetime: 100,
                        fromPlayer: true,
                        weaponType: 'sideChick'
                    });
                }
            }
        }

        function spawnEnemy() {
            const angle = Math.random() * Math.PI * 2;
            const distance = 45;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            
            // Determine enemy type based on game time and mode
            let enemyType = 'basic';
            const gameMinutes = gameState.gameTime / 60;
            
            // Boss Rush mode: mostly hulks
            if (gameSettings.gameMode === 'bossRush') {
                const roll = Math.random();
                if (roll < 0.5) {
                    enemyType = 'hulk';
                } else if (roll < 0.8) {
                    enemyType = 'catapult';
                }
            } else if (gameMinutes >= 4) {
                // After 4 minutes: can spawn hulk hunters (20% chance)
                const roll = Math.random();
                if (roll < 0.2) {
                    enemyType = 'hulk';
                } else if (roll < 0.5) {
                    enemyType = 'catapult';
                }
            } else if (gameMinutes >= 2) {
                // After 2 minutes: can spawn catapult hunters (30% chance)
                if (Math.random() < 0.3) {
                    enemyType = 'catapult';
                }
            }
            
            // Configure enemy stats based on type
            let health, shootCooldown, lives, yOffset;
            switch (enemyType) {
                case 'hulk':
                    health = 200;
                    shootCooldown = 0; // Melee only
                    lives = 3;
                    yOffset = 1.5;
                    break;
                case 'catapult':
                    health = 80;
                    shootCooldown = 3500; // Slower but more powerful
                    lives = 1;
                    yOffset = 1;
                    break;
                default: // basic
                    health = 50;
                    shootCooldown = 2000;
                    lives = 1;
                    yOffset = 1;
            }
            
            const enemy = {
                mesh: createHunter(enemyType),
                position: new THREE.Vector3(x, getTerrainHeight(x, z) + yOffset, z),
                health: health,
                maxHealth: health,
                lastShootTime: 0,
                shootCooldown: shootCooldown,
                type: enemyType,
                lives: lives,
                lastMeleeTime: 0
            };
            
            enemy.mesh.position.copy(enemy.position);
            scene.add(enemy.mesh);
            enemies.push(enemy);
        }

        // ==================== PROJECTILES ====================
        const projectiles = [];

        function createProjectile(start, direction, config, fromPlayer = true, weaponType = null) {
            // Make cannon and catapult projectiles much larger (player only)
            let projectileSize = 0.15;
            let canPierce = false;
            
            // Only apply special projectile properties for player weapons
            if (fromPlayer && weaponType) {
                if (weaponType === 'cannon') {
                    projectileSize = 0.5;
                    canPierce = true;
                } else if (weaponType === 'catapult') {
                    projectileSize = 0.4;
                    canPierce = true;
                } else if (weaponType === 'pistol') {
                    projectileSize = 0.25; // Increased from 0.15 for better hitbox
                }
            }
            
            const geom = new THREE.SphereGeometry(projectileSize, 8, 8);
            const mat = new THREE.MeshLambertMaterial({ 
                color: fromPlayer ? (canPierce ? 0xFF6600 : 0xFFFF00) : 0xFF0000 
            });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.copy(start);
            mesh.castShadow = true;
            scene.add(mesh);
            
            projectiles.push({
                mesh,
                velocity: direction.clone().multiplyScalar(config.speed || 0.5),
                damage: config.damage,
                lifetime: 200,
                isArc: config.type === 'arc',
                aoe: config.aoe || 0,
                fromPlayer,
                canPierce,
                hitEnemies: [],
                hitVehicles: [],
                weaponType: weaponType
            });
        }

        function handleEnemyDeath(enemy, idx, killSource) {
            if (enemy.type === 'hulk' && enemy.lives > 1) {
                // Hulk loses a life but keeps fighting
                enemy.lives--;
                enemy.health = enemy.maxHealth;
                
                // Rage effect - flash red
                enemy.mesh.traverse(child => {
                    if (child.material) {
                        child.material.emissive = new THREE.Color(0xFF0000);
                        setTimeout(() => {
                            if (child.material) child.material.emissive = new THREE.Color(0x000000);
                        }, 200);
                    }
                });
                
                // Roar particles
                for (let i = 0; i < 15; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15),
                        new THREE.MeshBasicMaterial({ color: 0xFF4500 })
                    );
                    particle.position.copy(enemy.position);
                    particle.position.y += 2;
                    scene.add(particle);
                    const vel = new THREE.Vector3((Math.random() - 0.5) * 0.3, 0.2, (Math.random() - 0.5) * 0.3);
                    bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 20 });
                }
                
                return false; // Enemy not fully dead
            }
            
            // Normal death
            for (let i = 0; i < (enemy.type === 'hulk' ? 40 : 15); i++) {
                createBloodParticle(enemy.position.clone(), enemy.type === 'hulk' ? 'large' : 'normal');
            }
            scene.remove(enemy.mesh);
            enemies.splice(idx, 1);
            gameState.kills++;
            trackKill(killSource);
            createSpecialOrb(enemy.position.clone());
            
            // Award coins based on enemy type
            const coinReward = enemy.type === 'hulk' ? 15 : (enemy.type === 'catapult' ? 10 : 5);
            awardCoins(coinReward);
            
            // Drop chance based on luck stat (25% base * luck multiplier)
            if (Math.random() < 0.25 * playerStats.luck) {
                // Drop only from weapons already unlocked/bought in the shop
                const possibleDrops = allTimeStats.unlockedWeapons.filter(w => w !== 'pistol' && w !== gameState.currentWeapon);
                if (possibleDrops.length > 0) {
                    const droppedWeapon = possibleDrops[Math.floor(Math.random() * possibleDrops.length)];
                    createPickup(droppedWeapon, enemy.position.clone());
                }
            }
            
            updateUI();
            return true; // Enemy fully dead
        }

        function createEnemyProjectile(start, direction) {
            const geom = new THREE.SphereGeometry(0.12, 6, 6);
            const mat = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.copy(start);
            mesh.castShadow = true;
            scene.add(mesh);
            
            projectiles.push({
                mesh,
                velocity: direction.clone().multiplyScalar(0.5),
                damage: 1,
                lifetime: 150,
                fromPlayer: false
            });
        }
        
        function createTankShell(start, direction, vehicle) {
            const geom = new THREE.CylinderGeometry(0.15, 0.2, 0.8, 8);
            const mat = new THREE.MeshLambertMaterial({ color: 0x4a4a4a });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.rotation.x = Math.PI / 2;
            mesh.position.copy(start);
            mesh.castShadow = true;
            scene.add(mesh);
            
            // Add glowing tip
            const tipGeom = new THREE.SphereGeometry(0.12, 6, 6);
            const tipMat = new THREE.MeshBasicMaterial({ color: 0xff4400 });
            const tip = new THREE.Mesh(tipGeom, tipMat);
            tip.position.z = 0.5;
            mesh.add(tip);
            
            projectiles.push({
                mesh,
                velocity: direction.clone().multiplyScalar(0.6),
                damage: 3,
                lifetime: 180,
                fromPlayer: false,
                isExplosive: true,
                explosionRadius: 6
            });
        }
        
        function createPlayerTankShell(start, direction) {
            const geom = new THREE.CylinderGeometry(0.2, 0.25, 1, 8);
            const mat = new THREE.MeshLambertMaterial({ color: 0x6a6a6a });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.rotation.x = Math.PI / 2;
            mesh.position.copy(start);
            mesh.castShadow = true;
            scene.add(mesh);
            
            // Add glowing tip
            const tipGeom = new THREE.SphereGeometry(0.15, 6, 6);
            const tipMat = new THREE.MeshBasicMaterial({ color: 0x00aaff });
            const tip = new THREE.Mesh(tipGeom, tipMat);
            tip.position.z = 0.6;
            mesh.add(tip);
            
            projectiles.push({
                mesh,
                velocity: direction.clone().multiplyScalar(0.7),
                damage: 100,
                lifetime: 200,
                fromPlayer: true,
                isExplosive: true,
                explosionRadius: 8,
                weaponType: 'tankCannon'
            });
        }
        
        function createCatapultProjectile(start, direction, fromPlayer = true) {
            const geom = new THREE.SphereGeometry(0.35, 8, 8);
            const mat = new THREE.MeshLambertMaterial({ color: fromPlayer ? 0xFF6600 : 0x8B0000 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.copy(start);
            mesh.castShadow = true;
            scene.add(mesh);
            
            // Add trailing fire effect
            const trailGeom = new THREE.SphereGeometry(0.2, 6, 6);
            const trailMat = new THREE.MeshBasicMaterial({ color: 0xFF4500, transparent: true, opacity: 0.7 });
            const trail = new THREE.Mesh(trailGeom, trailMat);
            trail.position.set(-0.3, 0, 0);
            mesh.add(trail);
            
            // Arc trajectory for catapult
            const vel = direction.clone().multiplyScalar(fromPlayer ? 0.6 : 0.4);
            vel.y = 0.35; // Arc upward
            
            projectiles.push({
                mesh,
                velocity: vel,
                damage: fromPlayer ? 60 : 25,
                lifetime: 200,
                fromPlayer: fromPlayer,
                isExplosive: true,
                isArc: true,
                explosionRadius: fromPlayer ? 6 : 4.5,
                weaponType: 'catapult'
            });
        }

        // ==================== WEAPON PICKUPS ====================
        const pickups = [];
        const specialOrbs = [];

        function createSpecialOrb(position) {
            const charType = gameSettings.character;
            const config = characterConfig[charType];
            if (!config.special) return; // Duck doesn't get orbs
            
            // 25% chance to drop orb
            if (Math.random() > 0.25) return;
            
            const orb = new THREE.Group();
            
            // Core orb
            const coreGeom = new THREE.SphereGeometry(0.3, 16, 16);
            const coreMat = new THREE.MeshBasicMaterial({ 
                color: config.orbColor,
                transparent: true,
                opacity: 0.8
            });
            const core = new THREE.Mesh(coreGeom, coreMat);
            orb.add(core);
            
            // Outer glow ring
            const ringGeom = new THREE.TorusGeometry(0.4, 0.05, 8, 16);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.6
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            orb.add(ring);
            
            // Star inside
            const starGeom = new THREE.OctahedronGeometry(0.15, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            const star = new THREE.Mesh(starGeom, starMat);
            orb.add(star);
            orb.userData.star = star;
            
            orb.position.copy(position);
            orb.position.y += 1;
            scene.add(orb);
            
            specialOrbs.push({
                mesh: orb,
                position: orb.position.clone(),
                rotation: 0,
                bobPhase: Math.random() * Math.PI * 2,
                lifetime: 600 // 10 seconds at 60fps
            });
        }

        function updateSpecialOrbs(delta) {
            for (let i = specialOrbs.length - 1; i >= 0; i--) {
                const orb = specialOrbs[i];
                
                // Animate
                orb.rotation += 0.03;
                orb.mesh.rotation.y = orb.rotation;
                orb.mesh.rotation.x = Math.sin(orb.rotation * 0.5) * 0.3;
                orb.bobPhase += 0.05;
                orb.mesh.position.y = orb.position.y + Math.sin(orb.bobPhase) * 0.3;
                
                // Star spins faster
                if (orb.mesh.userData.star) {
                    orb.mesh.userData.star.rotation.y = orb.rotation * 3;
                    orb.mesh.userData.star.rotation.x = orb.rotation * 2;
                }
                
                // Check pickup
                const dist = player.position.distanceTo(orb.mesh.position);
                if (dist < 2) {
                    player.specialCharges++;
                    updateSpecialUI();
                    
                    // Pickup effect
                    for (let j = 0; j < 10; j++) {
                        const particle = new THREE.Mesh(
                            new THREE.SphereGeometry(0.1),
                            new THREE.MeshBasicMaterial({ color: characterConfig[gameSettings.character].orbColor })
                        );
                        particle.position.copy(orb.mesh.position);
                        scene.add(particle);
                        const vel = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.3,
                            Math.random() * 0.3,
                            (Math.random() - 0.5) * 0.3
                        );
                        bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 20 });
                    }
                    
                    scene.remove(orb.mesh);
                    specialOrbs.splice(i, 1);
                    continue;
                }
                
                // Lifetime
                orb.lifetime--;
                if (orb.lifetime <= 0) {
                    scene.remove(orb.mesh);
                    specialOrbs.splice(i, 1);
                }
            }
        }

        function updateSpecialUI() {
            const charType = gameSettings.character;
            const config = characterConfig[charType];
            const btn = document.getElementById('special-btn');
            
            if (!config.special || !gameState.playing) {
                btn.style.display = 'none';
                return;
            }
            
            btn.style.display = 'flex';
            document.getElementById('special-count').textContent = player.specialCharges;
            document.getElementById('special-name').textContent = config.specialName;
            
            if (player.specialCharges > 0 && !player.specialActive) {
                btn.classList.remove('disabled');
                btn.classList.add('active');
            } else {
                btn.classList.add('disabled');
                btn.classList.remove('active');
            }
        }

        function activateSpecial() {
            const charType = gameSettings.character;
            const config = characterConfig[charType];
            if (!config.special) return;
            if (player.specialCharges <= 0) return;
            if (player.specialActive) return;
            
            player.specialCharges--;
            updateSpecialUI();
            
            switch (config.special) {
                case 'turkeyStomp':
                    executeTurkeyStomp();
                    break;
                case 'ninjaVanish':
                    executeNinjaVanish();
                    break;
                case 'freedomBombs':
                    executeFreedomBombs();
                    break;
                case 'windyWing67':
                    executeWindyWing67();
                    break;
                case 'berserkerRage':
                    executeBerserkerRage();
                    break;
                case 'doppelgangerDuo':
                    executeDoppelgangerDuo();
                    break;
                case 'chuckFlurry':
                    executeChuckFlurry();
                    break;
                case 'eggEncasement':
                    executeEggEncasement();
                    break;
                case 'giantEggTransform':
                    executeGiantEggTransform();
                    break;
                case 'batSwarm':
                    executeBatSwarm();
                    break;
            }
        }
        
        function executeEggBomber() {
            // Drop an exploding egg beneath the bird - only while airborne
            if (player.position.y <= getTerrainHeight(player.position.x, player.position.z) + 0.5) return;

            const eggGeom = new THREE.SphereGeometry(0.3, 8, 8);
            const eggMat = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
            const egg = new THREE.Mesh(eggGeom, eggMat);
            
            const start = player.position.clone();
            start.y -= 0.5;
            egg.position.copy(start);
            scene.add(egg);
            
            projectiles.push({
                mesh: egg,
                velocity: new THREE.Vector3(0, -0.2, 0),
                damage: 50,
                lifetime: 100,
                fromPlayer: true,
                isExplosive: true,
                explosionRadius: 5,
                weaponType: 'eggBomb'
            });
            
            // Visual "drop" puff
            for (let i = 0; i < 5; i++) {
                const puff = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15),
                    new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.5 })
                );
                puff.position.copy(start);
                scene.add(puff);
                bloodParticles.push({
                    mesh: puff,
                    velocity: new THREE.Vector3((Math.random()-0.5)*0.1, 0.1, (Math.random()-0.5)*0.1),
                    lifetime: 15
                });
            }
        }

        function executeGiantEggTransform() {
            // Similar to eggy surprise but as a special ability
            player.specialActive = true;
            player.isInvulnerable = true;
            player.specialEndTime = Date.now() + 10000; // Lasts 10 seconds
            
            // Visual transformation
            player.mesh.visible = false;
            
            const eggGeom = new THREE.SphereGeometry(1.5, 16, 16);
            eggGeom.scale(0.8, 1, 0.8);
            const eggMat = new THREE.MeshLambertMaterial({ color: 0xFFFACD });
            const eggMesh = new THREE.Mesh(eggGeom, eggMat);
            eggMesh.position.copy(player.position);
            scene.add(eggMesh);
            
            const transformInterval = setInterval(() => {
                eggMesh.position.copy(player.position);
                eggMesh.rotation.x += 0.1;
                eggMesh.rotation.z += 0.05;
                
                // Damage enemies we roll over
                enemies.forEach((enemy, idx) => {
                    if (eggMesh.position.distanceTo(enemy.position) < 2.5) {
                        enemy.health -= 50;
                        if (enemy.health <= 0) {
                            handleEnemyDeath(enemy, idx, 'giantEgg');
                        }
                    }
                });
                
                if (Date.now() >= player.specialEndTime || gameState.isGameOver) {
                    clearInterval(transformInterval);
                    scene.remove(eggMesh);
                    player.mesh.visible = true;
                    player.specialActive = false;
                    player.isInvulnerable = false;
                    
                    // Transformation back effect
                    for (let i = 0; i < 15; i++) {
                        const puff = new THREE.Mesh(
                            new THREE.SphereGeometry(0.2),
                            new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 })
                        );
                        puff.position.copy(player.position);
                        scene.add(puff);
                        bloodParticles.push({
                            mesh: puff,
                            velocity: new THREE.Vector3((Math.random()-0.5)*0.4, 0.3, (Math.random()-0.5)*0.4),
                            lifetime: 20
                        });
                    }
                }
            }, 16);
        }
        
        function executeEggEncasement() {
            // Encase player in a giant egg shell, providing invulnerability and healing
            player.specialActive = true;
            player.isInvulnerable = true;
            player.specialEndTime = Date.now() + 5000;
            
            // Create giant egg mesh around player
            const shellGeom = new THREE.SphereGeometry(1.8, 16, 16);
            shellGeom.scale(0.8, 1, 0.8);
            const shellMat = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF, 
                transparent: true, 
                opacity: 0.7 
            });
            const shell = new THREE.Mesh(shellGeom, shellMat);
            shell.position.copy(player.position);
            scene.add(shell);
            
            // Healing over time
            const healInterval = setInterval(() => {
                if (gameState.lives < 3) {
                    gameState.lives = Math.min(3, gameState.lives + 0.5);
                    updateUI();
                }
                
                // Pulsing effect
                shell.scale.multiplyScalar(1.05);
                setTimeout(() => shell.scale.multiplyScalar(0.952), 50);
                
                if (Date.now() >= player.specialEndTime || gameState.isGameOver) {
                    clearInterval(healInterval);
                    scene.remove(shell);
                    player.specialActive = false;
                    player.isInvulnerable = false;
                    
                    // Shell break effect
                    for (let i = 0; i < 20; i++) {
                        const frag = new THREE.Mesh(
                            new THREE.BoxGeometry(0.2, 0.2, 0.05),
                            new THREE.MeshLambertMaterial({ color: 0xFFFFFF })
                        );
                        frag.position.copy(player.position);
                        scene.add(frag);
                        bloodParticles.push({
                            mesh: frag,
                            velocity: new THREE.Vector3((Math.random()-0.5)*0.4, 0.2, (Math.random()-0.5)*0.4),
                            lifetime: 30
                        });
                    }
                }
            }, 1000);
            
            // Update shell position to follow player
            const updatePos = () => {
                if (shell.parent) {
                    shell.position.copy(player.position);
                    requestAnimationFrame(updatePos);
                }
            };
            updatePos();
        }

        function executeChuckFlurry() {
            // Rapid flurry of roundhouse kicks in all directions
            player.specialActive = true;
            player.specialEndTime = Date.now() + 3000;
            
            let kickCount = 0;
            const flurryInterval = setInterval(() => {
                kickCount++;
                
                // Create kick wave
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2 + kickCount * 0.5;
                    const particle = new THREE.Mesh(
                        new THREE.BoxGeometry(0.3, 0.15, 0.15),
                        new THREE.MeshBasicMaterial({ color: 0xFF6600 })
                    );
                    particle.position.copy(player.position);
                    particle.position.x += Math.cos(angle) * 3;
                    particle.position.y += 0.5;
                    particle.position.z += Math.sin(angle) * 3;
                    scene.add(particle);
                    
                    const vel = new THREE.Vector3(Math.cos(angle) * 0.4, 0.15, Math.sin(angle) * 0.4);
                    bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 15 });
                }
                
                // Damage enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const dist = player.position.distanceTo(enemy.position);
                    if (dist < 8) {
                        enemy.health -= 40;
                        if (enemy.health <= 0) {
                            handleEnemyDeath(enemy, i, 'chuckFlurry');
                        }
                    }
                }
                
                if (kickCount >= 6) {
                    clearInterval(flurryInterval);
                    player.specialActive = false;
                }
            }, 400);
        }
        
        function executeBatSwarm() {
            // Release a swarm of bats that seek enemies
            player.specialActive = true;
            player.specialEndTime = Date.now() + 5000;
            
            // Create bat projectiles
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const batGeom = new THREE.ConeGeometry(0.15, 0.3, 4);
                const batMat = new THREE.MeshLambertMaterial({ color: 0x1a1a2e });
                const bat = new THREE.Mesh(batGeom, batMat);
                bat.position.copy(player.position);
                bat.position.y += 1;
                bat.rotation.x = Math.PI / 2;
                scene.add(bat);
                
                projectiles.push({
                    mesh: bat,
                    velocity: new THREE.Vector3(Math.cos(angle) * 0.3, 0.1, Math.sin(angle) * 0.3),
                    damage: 30,
                    lifetime: 150,
                    fromPlayer: true,
                    weaponType: 'batSwarm',
                    seeking: true
                });
            }
            
            player.specialActive = false;
        }

        function executeDoppelgangerDuo() {
            // Remove existing doppelganger if there is one
            if (doppelganger) {
                scene.remove(doppelganger.mesh);
                doppelganger = null;
            }
            
            // Create a ghostly clone of the player
            const cloneMesh = createCharacter('poultrygeist');
            
            // Make clone even more transparent/ghostly
            cloneMesh.traverse(child => {
                if (child.material) {
                    child.material = child.material.clone();
                    child.material.transparent = true;
                    child.material.opacity = Math.min(child.material.opacity || 1, 0.5);
                }
            });
            
            // Position clone mirrored from player
            const clonePos = player.position.clone();
            clonePos.x += 3;
            cloneMesh.position.copy(clonePos);
            cloneMesh.position.y = getTerrainHeight(clonePos.x, clonePos.z) + 1;
            scene.add(cloneMesh);
            
            // Spawn effect
            for (let i = 0; i < 15; i++) {
                const sparkle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1),
                    new THREE.MeshBasicMaterial({ color: 0x88FFFF, transparent: true, opacity: 0.8 })
                );
                sparkle.position.copy(clonePos);
                sparkle.position.x += (Math.random() - 0.5) * 2;
                sparkle.position.y += Math.random() * 2;
                sparkle.position.z += (Math.random() - 0.5) * 2;
                scene.add(sparkle);
                bloodParticles.push({ 
                    mesh: sparkle, 
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 0.2, 0.1, (Math.random() - 0.5) * 0.2), 
                    lifetime: 30 
                });
            }
            
            doppelganger = {
                mesh: cloneMesh,
                position: clonePos.clone(),
                health: 50,
                lastAttackTime: 0,
                attackCooldown: 1000
            };
            
            player.specialActive = true;
            player.specialEndTime = Date.now() + 20000; // Clone lasts 20 seconds
        }
        
        function updateDoppelganger(delta) {
            if (!doppelganger) return;
            
            const now = Date.now();
            
            // Mirror player's movement with offset
            const mirrorOffset = new THREE.Vector3(3, 0, 0);
            mirrorOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.lookAngle);
            
            const targetPos = player.position.clone().add(mirrorOffset);
            const toTarget = targetPos.clone().sub(doppelganger.position);
            const dist = toTarget.length();
            
            if (dist > 0.5) {
                toTarget.normalize().multiplyScalar(0.2);
                doppelganger.position.add(toTarget);
            }
            
            // Keep clone at ground level with slight hover
            const terrainY = getTerrainHeight(doppelganger.position.x, doppelganger.position.z);
            doppelganger.position.y = terrainY + 1 + Math.sin(now * 0.003) * 0.2;
            
            doppelganger.mesh.position.copy(doppelganger.position);
            doppelganger.mesh.rotation.y = player.lookAngle;
            
            // Clone attacks nearby enemies
            if (now - doppelganger.lastAttackTime > doppelganger.attackCooldown) {
                let nearestEnemy = null;
                let nearestDist = 12;
                
                enemies.forEach(enemy => {
                    const d = doppelganger.position.distanceTo(enemy.position);
                    if (d < nearestDist) {
                        nearestDist = d;
                        nearestEnemy = enemy;
                    }
                });
                
                if (nearestEnemy) {
                    doppelganger.lastAttackTime = now;
                    
                    // Ghostly attack projectile
                    const attackDir = nearestEnemy.position.clone().sub(doppelganger.position).normalize();
                    const start = doppelganger.position.clone();
                    start.y += 0.5;
                    
                    const projGeom = new THREE.SphereGeometry(0.15, 6, 6);
                    const projMat = new THREE.MeshBasicMaterial({ 
                        color: 0x88FFFF, 
                        transparent: true, 
                        opacity: 0.8 
                    });
                    const projMesh = new THREE.Mesh(projGeom, projMat);
                    projMesh.position.copy(start);
                    scene.add(projMesh);
                    
                    projectiles.push({
                        mesh: projMesh,
                        velocity: attackDir.clone().multiplyScalar(0.5),
                        damage: 25,
                        lifetime: 80,
                        fromPlayer: true,
                        weaponType: 'doppelganger'
                    });
                }
            }
            
            // Check if clone got hit by enemy projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                if (!proj.fromPlayer) {
                    const dist = proj.mesh.position.distanceTo(doppelganger.position);
                    if (dist < 1.5) {
                        doppelganger.health -= proj.damage || 10;
                        scene.remove(proj.mesh);
                        projectiles.splice(i, 1);
                        
                        // Hit effect
                        for (let j = 0; j < 5; j++) {
                            const spark = new THREE.Mesh(
                                new THREE.SphereGeometry(0.08),
                                new THREE.MeshBasicMaterial({ color: 0x88FFFF })
                            );
                            spark.position.copy(doppelganger.position);
                            scene.add(spark);
                            bloodParticles.push({
                                mesh: spark,
                                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.3, 0.2, (Math.random() - 0.5) * 0.3),
                                lifetime: 15
                            });
                        }
                    }
                }
            }
            
            // Clone dies if health depleted or time runs out
            if (doppelganger.health <= 0 || (player.specialActive && now >= player.specialEndTime)) {
                // Death effect
                for (let i = 0; i < 20; i++) {
                    const ghost = new THREE.Mesh(
                        new THREE.SphereGeometry(0.12),
                        new THREE.MeshBasicMaterial({ color: 0x88FFFF, transparent: true, opacity: 0.7 })
                    );
                    ghost.position.copy(doppelganger.position);
                    ghost.position.x += (Math.random() - 0.5) * 2;
                    ghost.position.y += Math.random() * 2;
                    ghost.position.z += (Math.random() - 0.5) * 2;
                    scene.add(ghost);
                    bloodParticles.push({
                        mesh: ghost,
                        velocity: new THREE.Vector3((Math.random() - 0.5) * 0.2, 0.15, (Math.random() - 0.5) * 0.2),
                        lifetime: 40
                    });
                }
                
                scene.remove(doppelganger.mesh);
                doppelganger = null;
                player.specialActive = false;
            }
        }

        function executeTurkeyStomp() {
            // Jump high and slam down with massive AOE
            player.velocity.y = 0.8;
            player.specialActive = true;
            player.specialEndTime = Date.now() + 1000;
            
            // Delayed ground pound effect
            setTimeout(() => {
                const stompRadius = 12;
                // Ground crack effect
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2;
                    const dist = Math.random() * stompRadius;
                    const particle = new THREE.Mesh(
                        new THREE.BoxGeometry(0.4, 0.2, 0.4),
                        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                    );
                    particle.position.set(
                        player.position.x + Math.cos(angle) * dist,
                        player.position.y,
                        player.position.z + Math.sin(angle) * dist
                    );
                    scene.add(particle);
                    const vel = new THREE.Vector3(Math.cos(angle) * 0.2, 0.3, Math.sin(angle) * 0.2);
                    bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 40 });
                }
                
                // Damage enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const dist = player.position.distanceTo(enemy.position);
                    if (dist < stompRadius) {
                        enemy.health -= 100;
                        if (enemy.health <= 0) {
                            handleEnemyDeath(enemy, i, 'turkeyStomp');
                        }
                    }
                }
                player.specialActive = false;
            }, 500);
        }

        function executeNinjaVanish() {
            // Become invisible for 8 seconds
            player.isInvisible = true;
            player.specialActive = true;
            player.specialEndTime = Date.now() + 8000;
            
            // Make player semi-transparent
            player.mesh.traverse(child => {
                if (child.material) {
                    child.material.transparent = true;
                    child.material.opacity = 0.3;
                }
            });
            
            // Smoke effect
            for (let i = 0; i < 15; i++) {
                const smoke = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x666666, 
                        transparent: true, 
                        opacity: 0.7 
                    })
                );
                smoke.position.copy(player.position);
                smoke.position.x += (Math.random() - 0.5) * 2;
                smoke.position.z += (Math.random() - 0.5) * 2;
                scene.add(smoke);
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    0.1 + Math.random() * 0.1,
                    (Math.random() - 0.5) * 0.1
                );
                bloodParticles.push({ mesh: smoke, velocity: vel, lifetime: 30 });
            }
        }

        function executeFreedomBombs() {
            // Drop 6 bombs from the sky in a pattern
            player.specialActive = true;
            player.specialEndTime = Date.now() + 3000;
            
            for (let i = 0; i < 6; i++) {
                setTimeout(() => {
                    const angle = (i / 6) * Math.PI * 2;
                    const distance = 5 + Math.random() * 5;
                    const targetX = player.position.x + Math.cos(angle) * distance;
                    const targetZ = player.position.z + Math.sin(angle) * distance;
                    
                    // Bomb mesh falling from sky
                    const bomb = new THREE.Mesh(
                        new THREE.SphereGeometry(0.4),
                        new THREE.MeshLambertMaterial({ color: 0xBF0A30 })
                    );
                    bomb.position.set(targetX, 30, targetZ);
                    scene.add(bomb);
                    
                    // Animate bomb falling
                    const fallInterval = setInterval(() => {
                        bomb.position.y -= 1;
                        if (bomb.position.y <= getTerrainHeight(targetX, targetZ)) {
                            clearInterval(fallInterval);
                            scene.remove(bomb);
                            
                            // Explosion!
                            createExplosion(new THREE.Vector3(targetX, getTerrainHeight(targetX, targetZ), targetZ), 6, 80);
                        }
                    }, 30);
                }, i * 200);
            }
            
            setTimeout(() => { player.specialActive = false; }, 3000);
        }
        
        function executeWindyWing67() {
            // 67 Windy Wing tornado attack - invulnerable and pushes enemies back
            player.specialActive = true;
            player.isInvulnerable = true;
            player.specialEndTime = Date.now() + 4000;
            
            // Create tornado visual
            const tornadoGroup = new THREE.Group();
            tornadoGroup.position.copy(player.position);
            scene.add(tornadoGroup);
            
            // Tornado cone layers
            for (let layer = 0; layer < 8; layer++) {
                const radius = 0.5 + layer * 0.4;
                const height = layer * 0.8;
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(radius, 0.15, 6, 16),
                    new THREE.MeshBasicMaterial({ 
                        color: layer % 2 === 0 ? 0x00BCD4 : 0xB2EBF2, 
                        transparent: true, 
                        opacity: 0.6 
                    })
                );
                ring.position.y = height;
                ring.rotation.x = Math.PI / 2;
                tornadoGroup.add(ring);
            }
            
            // Wing animation data
            let wing67Time = 0;
            
            // Tornado effect loop
            const tornadoInterval = setInterval(() => {
                if (!player.specialActive) {
                    clearInterval(tornadoInterval);
                    scene.remove(tornadoGroup);
                    return;
                }
                
                // Animate tornado rotation
                tornadoGroup.rotation.y += 0.3;
                tornadoGroup.position.copy(player.position);
                
                // Animate wings in 67 pattern (one up, one down offset)
                wing67Time += 0.3;
                if (player.mesh.userData.leftWing) {
                    player.mesh.userData.leftWing.rotation.z = -Math.PI / 6 + Math.sin(wing67Time) * 0.8;
                    player.mesh.userData.rightWing.rotation.z = Math.PI / 6 + Math.sin(wing67Time + 0.67 * Math.PI) * 0.8;
                }
                
                // Push enemies back
                const pushRadius = 10;
                enemies.forEach(enemy => {
                    const dist = player.position.distanceTo(enemy.position);
                    if (dist < pushRadius) {
                        const pushDir = enemy.position.clone().sub(player.position).normalize();
                        const pushStrength = (1 - dist / pushRadius) * 0.8;
                        enemy.position.add(pushDir.multiplyScalar(pushStrength));
                        enemy.mesh.position.copy(enemy.position);
                        
                        // Wind particles
                        if (Math.random() < 0.3) {
                            const windParticle = new THREE.Mesh(
                                new THREE.SphereGeometry(0.1),
                                new THREE.MeshBasicMaterial({ color: 0xB2EBF2, transparent: true, opacity: 0.8 })
                            );
                            windParticle.position.copy(enemy.position);
                            scene.add(windParticle);
                            const vel = pushDir.clone().multiplyScalar(0.3);
                            vel.y = 0.1;
                            bloodParticles.push({ mesh: windParticle, velocity: vel, lifetime: 15 });
                        }
                    }
                });
            }, 50);
            
            setTimeout(() => {
                player.specialActive = false;
                player.isInvulnerable = false;
            }, 4000);
        }
        
        function executeBerserkerRage() {
            // Berserker Rage - 80% faster weapon recharge for 10 seconds
            player.specialActive = true;
            player.berserkerRage = true;
            player.specialEndTime = Date.now() + 10000;
            
            // Show rage aura
            if (player.mesh.userData.rageAura) {
                player.mesh.userData.rageAura.visible = true;
            }
            
            // Red screen flash
            for (let i = 0; i < 20; i++) {
                const rageParticle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15),
                    new THREE.MeshBasicMaterial({ color: 0xFF0000, transparent: true, opacity: 0.8 })
                );
                rageParticle.position.copy(player.position);
                rageParticle.position.x += (Math.random() - 0.5) * 3;
                rageParticle.position.y += Math.random() * 2;
                rageParticle.position.z += (Math.random() - 0.5) * 3;
                scene.add(rageParticle);
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    0.2,
                    (Math.random() - 0.5) * 0.2
                );
                bloodParticles.push({ mesh: rageParticle, velocity: vel, lifetime: 30 });
            }
            
            // Pulsing aura animation
            const rageInterval = setInterval(() => {
                if (!player.berserkerRage) {
                    clearInterval(rageInterval);
                    return;
                }
                if (player.mesh.userData.rageAura) {
                    player.mesh.userData.rageAura.material.opacity = 0.2 + Math.sin(Date.now() * 0.01) * 0.15;
                }
            }, 50);
            
            setTimeout(() => {
                player.specialActive = false;
                player.berserkerRage = false;
                if (player.mesh.userData.rageAura) {
                    player.mesh.userData.rageAura.visible = false;
                }
            }, 10000);
        }

        function updateSpecialState(delta) {
            const now = Date.now();
            
            // Check if ninja vanish ended
            if (player.isInvisible && now >= player.specialEndTime) {
                player.isInvisible = false;
                player.specialActive = false;
                
                // Restore player visibility
                player.mesh.traverse(child => {
                    if (child.material) {
                        child.material.transparent = false;
                        child.material.opacity = 1.0;
                    }
                });
                
                // Reappear effect
                for (let i = 0; i < 10; i++) {
                    const puff = new THREE.Mesh(
                        new THREE.SphereGeometry(0.2),
                        new THREE.MeshBasicMaterial({ color: 0x9400D3, transparent: true, opacity: 0.7 })
                    );
                    puff.position.copy(player.position);
                    puff.position.x += (Math.random() - 0.5) * 1.5;
                    puff.position.z += (Math.random() - 0.5) * 1.5;
                    scene.add(puff);
                    const vel = new THREE.Vector3((Math.random() - 0.5) * 0.1, 0.15, (Math.random() - 0.5) * 0.1);
                    bloodParticles.push({ mesh: puff, velocity: vel, lifetime: 20 });
                }
            }
            
            // Update special UI
            updateSpecialUI();
        }

        function createExplosion(position, radius, damage) {
            // Visual explosion
            for (let i = 0; i < 25; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3),
                    new THREE.MeshBasicMaterial({ 
                        color: Math.random() > 0.5 ? 0xFF4500 : 0xFFD700 
                    })
                );
                particle.position.copy(position);
                scene.add(particle);
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 25 });
            }
            
            // Damage enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = position.distanceTo(enemy.position);
                if (dist < radius) {
                    enemy.health -= damage;
                    if (enemy.health <= 0) {
                        handleEnemyDeath(enemy, i, 'freedomBombs');
                    }
                }
            }
        }

        function createPickup(weaponType, position = null) {
            const geom = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const mat = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.castShadow = true;
            
            if (position) {
                mesh.position.copy(position);
                mesh.position.y += 0.5;
            } else {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 15 + 5;
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                mesh.position.set(x, getTerrainHeight(x, z) + 0.5, z);
            }
            
            scene.add(mesh);
            // Loot despawns after 30 seconds
            pickups.push({ mesh, weaponType, rotation: 0, spawnTime: Date.now(), despawnTime: 30000 });
        }

        const weaponTypes = ['sword', 'hammer', 'rifle', 'machineGun', 'catapult', 'cannon'];

        // ==================== INPUT ====================
        const keys = {};
        let mouseDown = false;

        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            // Q key for ability activation
            if (e.key.toLowerCase() === 'q' && gameState.playing) {
                activateAbility();
            }
            // G key for grenade throw
            if (e.key.toLowerCase() === 'g' && gameState.playing && !gameState.isGameOver) {
                throwGrenade();
            }
        });
        window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) mouseDown = true;
            if (e.button === 2 && gameState.playing) {
                activateSpecial();
            }
        });
        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) mouseDown = false;
        });
        window.addEventListener('contextmenu', (e) => {
            if (gameState.playing) e.preventDefault();
        });

        // ==================== COLLISION DETECTION ====================
        function checkCollision(position, radius) {
            for (let obstacle of obstacles) {
                const dist = Math.sqrt(
                    Math.pow(position.x - obstacle.position.x, 2) +
                    Math.pow(position.z - obstacle.position.z, 2)
                );
                if (dist < radius + obstacle.radius) {
                    return true;
                }
            }
            return false;
        }

        function getSpeedModifier(position) {
            let modifier = 1.0;
            
            // Check water
            for (let water of waterZones) {
                const dist = Math.sqrt(
                    Math.pow(position.x - water.position.x, 2) +
                    Math.pow(position.z - water.position.z, 2)
                );
                if (dist < water.radius) {
                    modifier = Math.min(modifier, 0.4);
                }
            }
            
            // Check bushes
            for (let bush of bushZones) {
                const dist = Math.sqrt(
                    Math.pow(position.x - bush.position.x, 2) +
                    Math.pow(position.z - bush.position.z, 2)
                );
                if (dist < bush.radius) {
                    modifier = Math.min(modifier, 0.6);
                }
            }
            
            return modifier;
        }

        // ==================== DAY/NIGHT CYCLE ====================
        function updateDayNight() {
            if (gameState.isPaused || gameState.isGameOver) return;
            
            const timeInSeconds = gameState.gameTime;
            const cycleDuration = 180; // 3 minutes for full day-night cycle
            const cycleProgress = (timeInSeconds % cycleDuration) / cycleDuration;
            
            let skyColor, fogColor, ambientIntensity, directionalIntensity;
            
            if (cycleProgress < 0.5) {
                // Day to dusk (0 - 0.5) - Marsh colors
                const t = cycleProgress * 2;
                skyColor = new THREE.Color().lerpColors(
                    new THREE.Color(0x6B8E7F), // Murky marsh day
                    new THREE.Color(0x1a2618), // Dark swamp night
                    t
                );
                fogColor = new THREE.Color().lerpColors(
                    new THREE.Color(0x8B9A8E), // Marsh fog
                    new THREE.Color(0x2a3a2a), // Night marsh fog
                    t
                );
                ambientIntensity = 0.6 - (t * 0.4);
                directionalIntensity = 0.8 - (t * 0.6);
            } else {
                // Night to dawn (0.5 - 1.0) - Marsh colors
                const t = (cycleProgress - 0.5) * 2;
                skyColor = new THREE.Color().lerpColors(
                    new THREE.Color(0x1a2618), // Dark swamp night
                    new THREE.Color(0x6B8E7F), // Murky marsh day
                    t
                );
                fogColor = new THREE.Color().lerpColors(
                    new THREE.Color(0x2a3a2a), // Night marsh fog
                    new THREE.Color(0x8B9A8E), // Marsh fog
                    t
                );
                ambientIntensity = 0.2 + (t * 0.4);
                directionalIntensity = 0.2 + (t * 0.6);
            }
            
            scene.background = skyColor;
            scene.fog.color = fogColor;
            ambientLight.intensity = ambientIntensity;
            directionalLight.intensity = directionalIntensity;
        }

        // ==================== GAME LOGIC ====================
        function updatePlayer(delta) {
            if (gameState.isPaused || gameState.isGameOver) return;

            let baseSpeed = 0.04; // Slower base speed
            const jumpForce = 1.25; // Increased jump force
            const gravity = -0.04;
            
            // Turkey Trotter speed boost when ability active
            if (gameSettings.character === 'titanTurkey' && player.abilityActive) {
                baseSpeed = 0.08; // Double speed during charge!
            }

            // Get speed modifier based on terrain (only if on ground)
            let speedModifier = 1.0;
            if (player.position.y <= getTerrainHeight(player.position.x, player.position.z) + 1.2) {
                speedModifier = getSpeedModifier(player.position);
            }
            const moveSpeed = baseSpeed * speedModifier * playerStats.speed;

            // Store old position for collision rollback
            const oldPosition = player.position.clone();

            // Movement relative to look direction
            const forward = new THREE.Vector3(-Math.sin(player.lookAngle), 0, -Math.cos(player.lookAngle));
            const right = new THREE.Vector3(Math.cos(player.lookAngle), 0, -Math.sin(player.lookAngle));

            if (keys['w']) {
                player.velocity.add(forward.clone().multiplyScalar(moveSpeed));
            }
            if (keys['s']) {
                player.velocity.add(forward.clone().multiplyScalar(-moveSpeed));
            }
            if (keys['a']) {
                player.velocity.add(right.clone().multiplyScalar(-moveSpeed));
            }
            if (keys['d']) {
                player.velocity.add(right.clone().multiplyScalar(moveSpeed));
            }
            
            // Joystick input (mobile)
            if (joystickState.active) {
                player.velocity.add(forward.clone().multiplyScalar(-joystickState.y * moveSpeed));
                player.velocity.add(right.clone().multiplyScalar(joystickState.x * moveSpeed));
            }

            // Multi-jump with wing flapping (character-specific jump count)
            if (keys[' '] && player.jumpsUsed < player.maxJumps) {
                if (!player.lastJumpKey) {
                    player.velocity.y = jumpForce * playerStats.jumpHeight;
                    player.jumpsUsed++;
                    player.isJumping = true;
                    player.wingFlapTime = 10; // Wing flap duration
                    player.lastJumpKey = true;
                    player.isGliding = false;
                }
            } else {
                player.lastJumpKey = false;
            }
            
            // Gliding - hold space while falling to glide with wings outstretched
            if (keys[' '] && player.velocity.y < 0 && player.jumpsUsed >= player.maxJumps && gameSettings.character !== 'eggySurprise') {
                player.isGliding = true;
                player.velocity.y = Math.max(player.velocity.y, -0.08); // Slow fall while gliding
            } else if (!keys[' ']) {
                player.isGliding = false;
            }

            // Wing animation based on state
            if (player.mesh.userData.leftWing && player.mesh.userData.rightWing) {
                if (player.isGliding) {
                    // Wings outstretched while gliding
                    player.mesh.userData.leftWing.rotation.z = -Math.PI / 2.5;
                    player.mesh.userData.rightWing.rotation.z = Math.PI / 2.5;
                } else if (player.wingFlapTime > 0) {
                    player.wingFlapTime--;
                    
                    // Chick 7 uses special 67 wing pattern when jumping
                    if (gameSettings.character === 'chick7') {
                        player.wing67Time += 0.3;
                        player.mesh.userData.leftWing.rotation.z = -Math.PI / 6 + Math.sin(player.wing67Time) * Math.PI / 3;
                        player.mesh.userData.rightWing.rotation.z = Math.PI / 6 + Math.sin(player.wing67Time + 0.67 * Math.PI) * Math.PI / 3;
                    } else {
                        // Normal wing flapping for other birds
                        const flapAngle = Math.sin(player.wingFlapTime * 0.8) * Math.PI / 3;
                        player.mesh.userData.leftWing.rotation.z = -Math.PI / 6 - flapAngle;
                        player.mesh.userData.rightWing.rotation.z = Math.PI / 6 + flapAngle;
                    }
                } else {
                    // Reset to default position
                    player.mesh.userData.leftWing.rotation.z = -Math.PI / 6;
                    player.mesh.userData.rightWing.rotation.z = Math.PI / 6;
                }
            }

            // Apply velocity
            player.position.add(player.velocity);
            player.velocity.multiplyScalar(0.85);

            // Check collision and rollback if needed
            if (checkCollision(player.position, 0.6)) {
                player.position.copy(oldPosition);
                player.velocity.x *= -0.5;
                player.velocity.z *= -0.5;
            }

            // Gravity and terrain/structure collision
            player.velocity.y += gravity;
            const terrainY = getTerrainHeight(player.position.x, player.position.z);
            
            // Check if player is above a walkable structure (hut or tree)
            let groundY = terrainY;
            for (const obstacle of obstacles) {
                if (obstacle.walkableHeight) {
                    const dist2D = Math.sqrt(
                        Math.pow(player.position.x - obstacle.position.x, 2) +
                        Math.pow(player.position.z - obstacle.position.z, 2)
                    );
                    
                    // If player is within structure radius and above it, use structure height
                    if (dist2D < obstacle.radius && player.position.y >= obstacle.walkableHeight - 1) {
                        groundY = Math.max(groundY, obstacle.walkableHeight);
                    }
                }
            }
            
            if (player.position.y <= groundY + 1) {
                player.position.y = groundY + 1;
                player.velocity.y = 0;
                player.isJumping = false;
                player.jumpsUsed = 0; // Reset jumps when on ground
            }

            // Boundary
            const maxDist = 48;
            if (Math.abs(player.position.x) > maxDist) {
                player.position.x = Math.sign(player.position.x) * maxDist;
            }
            if (Math.abs(player.position.z) > maxDist) {
                player.position.z = Math.sign(player.position.z) * maxDist;
            }

            // Mouse look direction
            const lookDir = new THREE.Vector3(mouseX, 0, -mouseY).normalize();
            player.lookAngle = Math.atan2(lookDir.x, lookDir.z);

            // Update mesh
            player.mesh.position.copy(player.position);
            player.mesh.rotation.y = player.lookAngle;
            
            // Weapon swing animation
            if (player.weaponModel && player.weaponModel.userData.swingTime > 0) {
                player.weaponModel.userData.swingTime--;
                const t = player.weaponModel.userData.swingTime / 15;
                
                if (player.weaponModel.userData.swingType === 'arc') {
                    // Sword arc swing
                    const swingAngle = Math.sin((1 - t) * Math.PI) * Math.PI / 2;
                    player.weaponModel.rotation.z = -Math.PI / 4 + swingAngle;
                    player.weaponModel.rotation.y = Math.sin((1 - t) * Math.PI) * Math.PI / 3;
                } else if (player.weaponModel.userData.swingType === 'chop') {
                    // Hammer vertical chop
                    const chopAngle = Math.sin((1 - t) * Math.PI) * Math.PI / 1.5;
                    player.weaponModel.rotation.x = -chopAngle;
                }
            } else if (player.weaponModel) {
                // Reset to default position
                player.weaponModel.rotation.set(0, 0, -Math.PI / 4);
            }

            // Update injuries based on lives lost
            if (gameState.lives <= 2) {
                player.mesh.userData.body.material.color.setHex(0xFFCC00);
                
                // Blood trail when injured - drip every few frames
                player.bloodDripCounter++;
                const dripRate = gameState.lives === 1 ? 8 : 15; // More frequent when more injured
                if (player.bloodDripCounter >= dripRate) {
                    player.bloodDripCounter = 0;
                    const dripPos = player.position.clone();
                    dripPos.y += 0.3;
                    createBloodParticle(dripPos, 'spray');
                }
            }
            if (gameState.lives <= 1) {
                player.mesh.userData.head.material.color.setHex(0xFF8800);
                player.mesh.rotation.x = 0.1;
            }

            // Camera follow (third-person)
            const camDist = 12;
            const camHeight = 8;
            camera.position.x = player.position.x + Math.sin(player.lookAngle) * camDist;
            camera.position.y = player.position.y + camHeight;
            camera.position.z = player.position.z + Math.cos(player.lookAngle) * camDist;
            camera.lookAt(player.position);

            // Attack (Eggy Surprise can't attack - just rolls around!)
            if (gameSettings.character !== 'eggySurprise') {
                const weapon = weapons[gameState.currentWeapon];
                const now = Date.now();
                // Berserker Rage reduces weapon cooldown by 80%
                // Robot Rooster has 50% faster attacks (attackSpeedMultiplier = 0.5)
                const charConfig = characterConfig[gameSettings.character];
                let effectiveCooldown = weapon.cooldown;
                // Apply player stat attack speed buff
                effectiveCooldown /= playerStats.attackSpeed;
                if (charConfig.attackSpeedMultiplier) {
                    effectiveCooldown *= charConfig.attackSpeedMultiplier;
                }
                // Berserker Rage further reduces cooldown by 80%
                if (player.berserkerRage) {
                    effectiveCooldown *= 0.2;
                }
                if (mouseDown && now - player.lastAttackTime > effectiveCooldown) {
                    player.lastAttackTime = now;
                    
                    // Kung Pow Chicken always performs karate on click
                    if (gameSettings.character === 'kungPowChicken') {
                        performKarateAttack();
                    }

                    if (weapon.type === 'melee') {
                        meleeAttack();
                    } else {
                        shootProjectile();
                    }
                }
            }
        }

        function performKarateAttack() {
            const now = Date.now();
            player.martialArtCycle = ((player.martialArtCycle || 0) + 1) % 2;
            const attackDir = new THREE.Vector3(-Math.sin(player.lookAngle), 0, -Math.cos(player.lookAngle));
            
            if (player.martialArtCycle === 0) {
                // SPINNING KICK
                player.velocity.y = 0.25;
                const kickRing = new THREE.Mesh(
                    new THREE.TorusGeometry(3.0, 0.3, 10, 32),
                    new THREE.MeshBasicMaterial({ color: 0x00FFFF, transparent: true, opacity: 0.9 })
                );
                kickRing.position.copy(player.position).y += 0.5;
                kickRing.rotation.x = Math.PI/2;
                scene.add(kickRing);
                bloodParticles.push({ mesh: kickRing, velocity: new THREE.Vector3(0,0,0), lifetime: 20 });

                let spinCount = 0;
                const spinInt = setInterval(() => {
                    if (player.mesh) player.mesh.rotation.y += 1.25;
                    spinCount++;
                    if (spinCount >= 8) clearInterval(spinInt);
                }, 40);
            } else {
                // WING CHOPS
                const leftWing = player.mesh.getObjectByName('wingL');
                const rightWing = player.mesh.getObjectByName('wingR');
                if (leftWing && rightWing) {
                    leftWing.rotation.z = Math.PI/1.2;
                    rightWing.rotation.z = -Math.PI/1.2;
                    setTimeout(() => {
                        if (leftWing) leftWing.rotation.z = 0;
                        if (rightWing) rightWing.rotation.z = 0;
                    }, 150);
                }
                const slash = new THREE.Mesh(
                    new THREE.BoxGeometry(5, 0.8, 0.3),
                    new THREE.MeshBasicMaterial({ color: 0xFFFFFF, transparent: true, opacity: 1.0 })
                );
                slash.position.copy(player.position).addScaledVector(attackDir, 3);
                slash.position.y += 1.3;
                slash.lookAt(player.position.clone().add(attackDir));
                scene.add(slash);
                bloodParticles.push({ mesh: slash, velocity: attackDir.clone().multiplyScalar(0.3), lifetime: 25 });
            }

            // Damage logic
            enemies.forEach((enemy, i) => {
                const dist = player.position.distanceTo(enemy.position);
                if (dist < 10) {
                    enemy.health -= 75;
                    createBloodParticle(enemy.position.clone(), 'large');
                    if (enemy.health <= 0) handleEnemyDeath(enemy, i, 'martialArts');
                }
            });
        }

        // ==================== ABILITY SYSTEM ====================
        function activateAbility() {
            const charType = gameSettings.character;
            const config = characterConfig[charType];
            if (!config.ability) return;
            
            const now = Date.now();
            if (now < player.abilityCooldownEnd) return;
            if (player.abilityActive) return;
            
            player.abilityActive = true;
            player.abilityEndTime = now + config.abilityDuration;
            player.abilityCooldownEnd = now + config.abilityCooldown;
            
            // Activate character-specific ability
            if (charType === 'titanTurkey') {
                // Show helmet
                if (player.mesh.userData.helmet) {
                    player.mesh.userData.helmet.visible = true;
                    player.mesh.userData.facemask.visible = true;
                }
            } else if (charType === 'kungPowChicken') {
                player.comboCount = 0;
                player.lastMartialArtTime = 0;
                player.martialArtCycle = 0;
            } else if (charType === 'mericaMallard') {
                // Eagle strike - instant damage in area
                executeEagleStrike();
                player.abilityActive = false;
            } else if (charType === 'poultrygeist') {
                // Haunt attack - possess and damage nearby enemies
                executeHauntAttack();
                player.abilityActive = false;
            } else if (charType === 'duckNorris') {
                // Roundhouse kick - instant devastating attack
                executeRoundhouseKick();
                player.abilityActive = false;
            } else if (charType === 'frickinChickin') {
                // Egg Bomber - drop egg straight down
                executeEggBomber();
                player.abilityActive = false;
            } else if (charType === 'quackula') {
                // Blood Drain - lifesteal mode for duration
                player.bloodDrainActive = true;
            }
            
            updateAbilityUI();
        }
        
        function executeRoundhouseKick() {
            const kickRadius = 6;
            const kickDamage = 120;
            
            // Spinning kick animation
            player.velocity.y = 0.2;
            
            // Create spinning kick effect
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const particle = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.1, 0.1),
                    new THREE.MeshBasicMaterial({ color: 0xFF4500 })
                );
                particle.position.copy(player.position);
                particle.position.x += Math.cos(angle) * 2;
                particle.position.y += 0.5;
                particle.position.z += Math.sin(angle) * 2;
                scene.add(particle);
                
                const vel = new THREE.Vector3(Math.cos(angle) * 0.3, 0.1, Math.sin(angle) * 0.3);
                bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 25 });
            }
            
            // Damage all enemies in range
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = player.position.distanceTo(enemy.position);
                if (dist < kickRadius) {
                    enemy.health -= kickDamage;
                    
                    // Knockback
                    const knockDir = enemy.position.clone().sub(player.position).normalize();
                    enemy.position.add(knockDir.multiplyScalar(4));
                    enemy.mesh.position.copy(enemy.position);
                    
                    if (enemy.health <= 0) {
                        handleEnemyDeath(enemy, i, 'roundhouseKick');
                    }
                }
            }
        }
        
        function executeHauntAttack() {
            const hauntRadius = 10;
            const hauntDamage = 50;
            
            // Create ghostly wave effect
            for (let i = 0; i < 25; i++) {
                const angle = (i / 25) * Math.PI * 2;
                const dist = Math.random() * hauntRadius;
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x88FFFF, 
                        transparent: true, 
                        opacity: 0.7 
                    })
                );
                particle.position.copy(player.position);
                particle.position.x += Math.cos(angle) * dist;
                particle.position.z += Math.sin(angle) * dist;
                particle.position.y += Math.random() * 2;
                scene.add(particle);
                
                const vel = new THREE.Vector3(
                    Math.cos(angle) * 0.15,
                    0.2 + Math.random() * 0.1,
                    Math.sin(angle) * 0.15
                );
                bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 40 });
            }
            
            // Create expanding ghost ring
            const ringGeom = new THREE.RingGeometry(0.5, 1, 32);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: 0x88FFFF, 
                transparent: true, 
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.position.copy(player.position);
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);
            
            // Animate ring expansion
            let ringScale = 1;
            const ringInterval = setInterval(() => {
                ringScale += 0.8;
                ring.scale.set(ringScale, ringScale, 1);
                ring.material.opacity -= 0.05;
                if (ring.material.opacity <= 0) {
                    scene.remove(ring);
                    clearInterval(ringInterval);
                }
            }, 50);
            
            // Damage and "haunt" enemies - they take damage and get confused
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = player.position.distanceTo(enemy.position);
                if (dist < hauntRadius) {
                    enemy.health -= hauntDamage;
                    
                    // Haunted effect - enemy briefly stunned/confused
                    enemy.isHaunted = true;
                    enemy.hauntedUntil = Date.now() + 2000;
                    
                    // Ghost particles on enemy
                    for (let j = 0; j < 5; j++) {
                        const ghost = new THREE.Mesh(
                            new THREE.SphereGeometry(0.1),
                            new THREE.MeshBasicMaterial({ 
                                color: 0x88FFFF, 
                                transparent: true, 
                                opacity: 0.8 
                            })
                        );
                        ghost.position.copy(enemy.position);
                        ghost.position.y += Math.random() * 2;
                        scene.add(ghost);
                        bloodParticles.push({ 
                            mesh: ghost, 
                            velocity: new THREE.Vector3(0, 0.1, 0), 
                            lifetime: 30 
                        });
                    }
                    
                    if (enemy.health <= 0) {
                        handleEnemyDeath(enemy, i, 'haunt');
                    }
                }
            }
        }
        
        function executeEagleStrike() {
            // Jump up and slam down
            player.velocity.y = 0.5;
            
            // Create eagle effect particles
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2;
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2),
                    new THREE.MeshBasicMaterial({ color: 0xFFD700 })
                );
                particle.position.copy(player.position);
                particle.position.x += Math.cos(angle) * 2;
                particle.position.z += Math.sin(angle) * 2;
                scene.add(particle);
                
                const vel = new THREE.Vector3(Math.cos(angle) * 0.2, 0.1, Math.sin(angle) * 0.2);
                bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 30 });
            }
            
            // Damage all enemies in range (reverse loop to safely remove)
            const strikeRadius = 8;
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = player.position.distanceTo(enemy.position);
                if (dist < strikeRadius) {
                    enemy.health -= 80;
                    if (enemy.health <= 0) {
                        handleEnemyDeath(enemy, i, 'eagleStrike');
                    }
                }
            }
        }
        
        function updateAbilityState(delta) {
            const charType = gameSettings.character;
            const config = characterConfig[charType];
            const now = Date.now();
            
            // Removed old Kung Pow Chicken auto-attack loop
            
            const abilityBar = document.getElementById('ability-bar');
            const abilityPrompt = document.getElementById('ability-prompt');
            
            if (!abilityBar || !abilityPrompt) return;
            if (!gameState.playing) return;
            
            if (!config.ability) {
                abilityBar.style.display = 'none';
                abilityPrompt.style.display = 'none';
                return;
            }
            
            const now = Date.now();
            
            // Show ability bar for characters with abilities
            abilityBar.style.display = 'block';
            
            if (player.abilityActive && now >= player.abilityEndTime) {
                // Ability ended
                player.abilityActive = false;
                if (charType === 'titanTurkey') {
                    if (player.mesh.userData.helmet) {
                        player.mesh.userData.helmet.visible = false;
                        player.mesh.userData.facemask.visible = false;
                    }
                }
                if (charType === 'quackula') {
                    player.bloodDrainActive = false;
                }
            }
            
            updateAbilityUI();
        }
        
        function updateAbilityUI() {
            const charType = gameSettings.character;
            const config = characterConfig[charType];
            if (!config.ability) return;
            
            const now = Date.now();
            const fill = document.getElementById('ability-fill');
            const text = document.getElementById('ability-text');
            const prompt = document.getElementById('ability-prompt');
            
            if (!fill || !text || !prompt) return;
            
            if (player.abilityActive) {
                // Show remaining duration
                const remaining = Math.max(0, player.abilityEndTime - now);
                const percent = (remaining / config.abilityDuration) * 100;
                fill.style.width = percent + '%';
                fill.style.background = 'linear-gradient(90deg, #FF0000, #FF6600)';
                text.textContent = 'ABILITY ACTIVE!';
                prompt.style.display = 'none';
            } else if (now < player.abilityCooldownEnd) {
                // Show cooldown
                const remaining = player.abilityCooldownEnd - now;
                const percent = 100 - (remaining / config.abilityCooldown) * 100;
                fill.style.width = percent + '%';
                fill.style.background = 'linear-gradient(90deg, #666, #888)';
                text.textContent = 'Cooldown: ' + Math.ceil(remaining / 1000) + 's';
                prompt.style.display = 'none';
            } else {
                // Ready
                fill.style.width = '100%';
                fill.style.background = 'linear-gradient(90deg, #FF6B00, #FFD700)';
                text.textContent = 'ABILITY READY - Press Q';
                prompt.style.display = 'block';
            }
        }

        function performMartialArtsCombo(attackDir) {
            const damage = 30 + (player.comboCount * 15);
            const range = 5.0;
            
            // Create "chi" impact effects
            const chiGeom = new THREE.RingGeometry(0.1, 1.5, 16);
            const chiMat = new THREE.MeshBasicMaterial({ color: 0x00FFFF, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
            const chi = new THREE.Mesh(chiGeom, chiMat);
            chi.position.copy(player.position);
            chi.position.y += 1;
            chi.lookAt(player.position.clone().add(attackDir));
            scene.add(chi);
            
            // Chi ring expands and fades
            bloodParticles.push({
                mesh: chi,
                velocity: new THREE.Vector3(0, 0, 0),
                lifetime: 10,
                update: function() {
                    this.mesh.scale.multiplyScalar(1.2);
                    this.mesh.material.opacity *= 0.8;
                }
            });

            // Hit enemies in range with combo damage
            enemies.forEach((enemy, idx) => {
                const dist = player.position.distanceTo(enemy.position);
                if (dist < range) {
                    const toEnemy = enemy.position.clone().sub(player.position).normalize();
                    if (attackDir.dot(toEnemy) > 0.3) {
                        enemy.health -= damage;
                        
                        // Push back
                        enemy.position.add(toEnemy.multiplyScalar(0.4));
                        enemy.mesh.position.copy(enemy.position);
                        
                        if (enemy.health <= 0) {
                            handleEnemyDeath(enemy, idx, 'martialArts');
                        }
                    }
                }
            });
        }

        function meleeAttack() {
            const charType = gameSettings.character;
            if (charType === 'kungPowChicken') {
                performKarateAttack();
            }

            const weapon = weapons[gameState.currentWeapon];
            const attackDir = new THREE.Vector3(
                -Math.sin(player.lookAngle),
                0,
                -Math.cos(player.lookAngle)
            );
            
            // Kung Pow Chicken combo system when ability active
            if (charType === 'kungPowChicken' && player.abilityActive) {
                player.comboCount++;
                performMartialArtsCombo(attackDir);
            }
            
            // Weapon swing animation
            if (player.weaponModel) {
                if (gameState.currentWeapon === 'sword') {
                    // Sword wide arc swing animation
                    player.weaponModel.userData.swingTime = 15;
                    player.weaponModel.userData.swingType = 'arc';
                } else if (gameState.currentWeapon === 'hammer') {
                    // Hammer vertical chop animation
                    player.weaponModel.userData.swingTime = 20;
                    player.weaponModel.userData.swingType = 'chop';
                }
            }
            
            // Create dramatic wind streak effects for melee weapons
            if (gameState.currentWeapon === 'sword' || gameState.currentWeapon === 'hammer') {
                const streakCount = gameState.currentWeapon === 'sword' ? 8 : 5;
                for (let i = 0; i < streakCount; i++) {
                    const offset = player.position.clone();
                    offset.y += 1 + (Math.random() - 0.5) * 0.4;
                    
                    // Spread streaks in arc for sword, forward for hammer
                    let dir = attackDir.clone();
                    if (gameState.currentWeapon === 'sword') {
                        const spread = (i / streakCount - 0.5) * 1.5;
                        dir = new THREE.Vector3(
                            -Math.sin(player.lookAngle + spread),
                            (Math.random() - 0.5) * 0.2,
                            -Math.cos(player.lookAngle + spread)
                        ).normalize();
                    }
                    
                    offset.add(dir.clone().multiplyScalar(1 + i * 0.3));
                    createWindStreak(offset, dir, gameState.currentWeapon);
                }
            }
            
            // Better hitbox detection - larger multipliers and more forgiving angles
            let hitboxMultiplier = 2.5; // Base multiplier for all melee
            if (gameState.currentWeapon === 'sword') hitboxMultiplier = 1.6;
            if (gameState.currentWeapon === 'hammer') hitboxMultiplier = 1.4;
            
            enemies.forEach((enemy, idx) => {
                const dist = player.position.distanceTo(enemy.position);
                if (dist < weapon.range * hitboxMultiplier) {
                    const toEnemy = enemy.position.clone().sub(player.position).normalize();
                    const angleThreshold = gameState.currentWeapon === 'sword' ? 0.2 : 0.4; // Lower = wider cone
                    if (attackDir.dot(toEnemy) > angleThreshold) {
                        enemy.health -= weapon.damage;
                        if (enemy.health <= 0) {
                            handleEnemyDeath(enemy, idx, gameState.currentWeapon);
                        }
                    }
                }
            });
        }

        function shootProjectile() {
            const charType = gameSettings.character;
            if (charType === 'kungPowChicken') {
                performKarateAttack();
            }

            const weapon = weapons[gameState.currentWeapon];
            const direction = new THREE.Vector3(
                -Math.sin(player.lookAngle),
                weapon.type === 'arc' ? 0.3 : 0,
                -Math.cos(player.lookAngle)
            ).normalize();
            
            const start = player.position.clone();
            start.y += 1;
            
            // Handle special weapon types
            if (weapon.type === 'stream') {
                // Flamethrower - create flame particle stream
                const flameGeom = new THREE.SphereGeometry(0.15, 4, 4);
                const flameMat = new THREE.MeshBasicMaterial({ color: 0xFF4400 });
                const flame = new THREE.Mesh(flameGeom, flameMat);
                flame.position.copy(start);
                scene.add(flame);
                
                projectiles.push({
                    mesh: flame,
                    velocity: direction.clone().multiplyScalar(weapon.speed),
                    damage: weapon.damage,
                    lifetime: 30,
                    fromPlayer: true,
                    weaponType: gameState.currentWeapon,
                    isFlame: true,
                    burnDamage: weapon.burnDamage
                });
                return;
            }
            
            if (weapon.type === 'chain') {
                // Tesla coil - lightning bolt that chains and homes
                const boltGeom = new THREE.CylinderGeometry(0.15, 0.15, 1.0, 4); // Thicker bolt
                const boltMat = new THREE.MeshBasicMaterial({ color: 0x00FFFF });
                const bolt = new THREE.Mesh(boltGeom, boltMat);
                bolt.position.copy(start);
                bolt.rotation.x = Math.PI / 2;
                scene.add(bolt);
                
                projectiles.push({
                    mesh: bolt,
                    velocity: direction.clone().multiplyScalar(weapon.speed),
                    damage: weapon.damage,
                    lifetime: 100, // Longer lifetime for homing
                    fromPlayer: true,
                    weaponType: gameState.currentWeapon,
                    isChain: true,
                    isHoming: true, // Enable homing
                    chainCount: weapon.chainCount,
                    hitEnemies: []
                });
                return;
            }
            
            if (weapon.type === 'returning') {
                // Boomerang - comes back to player
                const boomGroup = new THREE.Group();
                const legMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Wooden brown
                
                // Create two legs for the V shape
                const leg1Geom = new THREE.BoxGeometry(0.1, 0.8, 0.04);
                const leg1 = new THREE.Mesh(leg1Geom, legMat);
                leg1.position.set(0.2, 0, 0);
                leg1.rotation.z = -Math.PI / 4; 
                boomGroup.add(leg1);
                
                const leg2Geom = new THREE.BoxGeometry(0.1, 0.8, 0.04);
                const leg2 = new THREE.Mesh(leg2Geom, legMat);
                leg2.position.set(-0.2, 0, 0);
                leg2.rotation.z = Math.PI / 4;
                boomGroup.add(leg2);
                
                const boom = boomGroup;
                boom.position.copy(start);
                scene.add(boom);
                
                projectiles.push({
                    mesh: boom,
                    velocity: direction.clone().multiplyScalar(weapon.speed),
                    damage: weapon.damage,
                    lifetime: 150,
                    fromPlayer: true,
                    weaponType: gameState.currentWeapon,
                    isBoomerang: true,
                    returning: false,
                    travelDistance: 0,
                    maxDistance: weapon.range,
                    hitEnemies: []
                });
                return;
            }
            
            createProjectile(start, direction, weapon, true, gameState.currentWeapon);
        }

        function updateEnemies(delta) {
            if (gameState.isPaused || gameState.isGameOver) return;

            const now = Date.now();
            
            // Turkey Trotter ram damage check
            if (gameSettings.character === 'titanTurkey' && player.abilityActive) {
                const ramRadius = 1.5;
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const dist = player.position.distanceTo(enemy.position);
                    if (dist < ramRadius) {
                        enemy.health -= 60;
                        // Knockback effect
                        const knockDir = enemy.position.clone().sub(player.position).normalize();
                        enemy.position.add(knockDir.multiplyScalar(2));
                        enemy.mesh.position.copy(enemy.position);
                        
                        if (enemy.health <= 0) {
                            handleEnemyDeath(enemy, i, 'helmetCharge');
                        }
                    }
                }
            }
            
            enemies.forEach((enemy, idx) => {
                // Check haunted status
                if (enemy.isHaunted) {
                    if (now >= enemy.hauntedUntil) {
                        enemy.isHaunted = false;
                    } else {
                        // Haunted enemies wander randomly instead of attacking
                        const wanderDir = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.04,
                            0,
                            (Math.random() - 0.5) * 0.04
                        );
                        enemy.position.add(wanderDir);
                        const terrainY = getTerrainHeight(enemy.position.x, enemy.position.z);
                        enemy.position.y = terrainY + (enemy.type === 'hulk' ? 1.5 : 1);
                        enemy.mesh.position.copy(enemy.position);
                        // Spin around confused
                        enemy.mesh.rotation.y += 0.15;
                        return; // Skip normal behavior while haunted
                    }
                }
                
                // Move toward player (unless invisible)
                const toPlayer = player.position.clone().sub(enemy.position);
                const dist = toPlayer.length();
                
                // Movement speed varies by enemy type
                let moveSpeed = 0.06;
                if (enemy.type === 'hulk') moveSpeed = 0.08; // Hulks move faster
                if (enemy.type === 'catapult') moveSpeed = 0.04; // Catapult hunters are slower
                
                const minDist = enemy.type === 'hulk' ? 3 : 5; // Hulks get closer
                
                if (dist > minDist && !player.isInvisible) {
                    toPlayer.normalize().multiplyScalar(moveSpeed);
                    enemy.position.add(toPlayer);
                    
                    // Keep on terrain
                    const terrainY = getTerrainHeight(enemy.position.x, enemy.position.z);
                    const yOffset = enemy.type === 'hulk' ? 1.5 : 1;
                    enemy.position.y = terrainY + yOffset;
                    
                    enemy.mesh.position.copy(enemy.position);
                    enemy.mesh.lookAt(player.position);
                }
                
                // Combat behavior based on enemy type
                if (!player.isInvisible) {
                    if (enemy.type === 'hulk') {
                        // Hulk melee attack
                        if (dist < 5 && now - enemy.lastMeleeTime > 2000) {
                            enemy.lastMeleeTime = now;
                            
                            // Hulk Stomp/Roar behavior
                            if (Math.random() < 0.4) {
                                // Roar - briefly stun player and push back
                                if (dist < 8) {
                                    const pushDir = player.position.clone().sub(enemy.position).normalize();
                                    player.velocity.add(pushDir.multiplyScalar(0.8));
                                    // Visual effect
                                    for (let i = 0; i < 20; i++) {
                                        createBloodParticle(enemy.position.clone(), 'large');
                                    }
                                }
                            } else {
                                // Club swing animation
                                enemy.mesh.rotation.y += 0.5;
                                
                                // Damage player if in range (check invulnerability)
                                if (dist < 4 && !player.isInvulnerable) {
                                    handlePlayerDamage(1);
                                    
                                    // Knockback effect on player
                                    const knockDir = player.position.clone().sub(enemy.position).normalize();
                                    player.velocity.add(knockDir.multiplyScalar(0.6));
                                }
                            }
                        }
                    } else if (enemy.type === 'catapult') {
                        // Catapult hunter shoots explosive projectiles
                        if (dist < 35 && now - enemy.lastShootTime > enemy.shootCooldown) {
                            enemy.lastShootTime = now;
                            const shootDir = toPlayer.normalize();
                            const start = enemy.position.clone();
                            start.y += 1.5;
                            createCatapultProjectile(start, shootDir, false);
                        }
                    } else {
                        // Basic hunter shoots regular projectiles
                        if (dist < 30 && now - enemy.lastShootTime > enemy.shootCooldown) {
                            enemy.lastShootTime = now;
                            const shootDir = toPlayer.normalize();
                            const start = enemy.position.clone();
                            start.y += 1;
                            createEnemyProjectile(start, shootDir);
                        }
                    }
                }
            });

            // Spawn enemies based on game mode
            let spawnRateModifier = 1.0;
            if (gameSettings.gameMode === 'endless') {
                spawnRateModifier = 0.6; // 40% faster spawns
            } else if (gameSettings.gameMode === 'bossRush') {
                spawnRateModifier = 2.0; // Slower spawns, but spawn hulks more often
            } else if (gameSettings.gameMode === 'timeAttack') {
                spawnRateModifier = 0.5; // Double spawn rate for time attack
            }
            
            if (now - gameState.lastSpawnTime > gameState.enemySpawnRate * spawnRateModifier) {
                gameState.lastSpawnTime = now;
                spawnEnemy();
                gameState.enemySpawnRate = Math.max(1000, gameState.enemySpawnRate - 50);
            }
            
            // Time Attack mode: 3 minute timer
            if (gameSettings.gameMode === 'timeAttack' && gameState.gameTime >= 180 && !gameState.isGameOver) {
                triggerGameOver();
            }
            
            // Spawn trucks occasionally (every 15-25 seconds)
            if (now - lastTruckSpawnTime > 15000 + Math.random() * 10000 && vehicles.length < 5) {
                lastTruckSpawnTime = now;
                spawnTruckWithDriver();
            }
            
            // Spawn tanks in late game (after 6 minutes, every 30-45 seconds)
            const gameMinutes = gameState.gameTime / 60;
            if (gameMinutes >= 6 && now - lastTankSpawnTime > 30000 + Math.random() * 15000 && vehicles.filter(v => v.isTank).length < 2) {
                lastTankSpawnTime = now;
                spawnTankWithDriver();
            }
        }

        function updateVehicles(delta) {
            if (gameState.isPaused || gameState.isGameOver) return;
            
            const now = Date.now();
            
            vehicles.forEach((vehicle, vIdx) => {
                if (gameState.vehicle === vehicle) {
                    // Player is driving this vehicle
                    const driveSpeed = 0.15;
                    const turnSpeed = 0.03;
                    
                    // Keyboard controls
                    if (keys['w']) {
                        vehicle.velocity.x -= Math.sin(vehicle.rotation) * driveSpeed;
                        vehicle.velocity.z -= Math.cos(vehicle.rotation) * driveSpeed;
                    }
                    if (keys['s']) {
                        vehicle.velocity.x += Math.sin(vehicle.rotation) * driveSpeed * 0.5;
                        vehicle.velocity.z += Math.cos(vehicle.rotation) * driveSpeed * 0.5;
                    }
                    if (keys['a']) vehicle.rotation += turnSpeed;
                    if (keys['d']) vehicle.rotation -= turnSpeed;
                    
                    // Joystick controls (mobile)
                    if (joystickState.active) {
                        if (joystickState.y < -0.2) {
                            vehicle.velocity.x -= Math.sin(vehicle.rotation) * driveSpeed * Math.abs(joystickState.y);
                            vehicle.velocity.z -= Math.cos(vehicle.rotation) * driveSpeed * Math.abs(joystickState.y);
                        }
                        if (joystickState.y > 0.2) {
                            vehicle.velocity.x += Math.sin(vehicle.rotation) * driveSpeed * 0.5 * joystickState.y;
                            vehicle.velocity.z += Math.cos(vehicle.rotation) * driveSpeed * 0.5 * joystickState.y;
                        }
                        if (joystickState.x < -0.2) vehicle.rotation += turnSpeed * Math.abs(joystickState.x);
                        if (joystickState.x > 0.2) vehicle.rotation -= turnSpeed * joystickState.x;
                    }
                    
                    vehicle.position.add(vehicle.velocity);
                    vehicle.velocity.multiplyScalar(0.92);
                    
                    const terrainY = getTerrainHeight(vehicle.position.x, vehicle.position.z);
                    vehicle.position.y = terrainY;
                    
                    vehicle.mesh.position.copy(vehicle.position);
                    vehicle.mesh.rotation.y = vehicle.rotation;
                    
                    // Player follows vehicle
                    player.position.copy(vehicle.position);
                    player.position.y += 3;
                    player.mesh.position.copy(player.position);
                    player.mesh.visible = true; // Make bird visible in vehicle
                    player.mesh.scale.set(0.5, 0.5, 0.5); // Shrink bird to fit in driver seat
                    
                    // Tank shooting with click
                    if (vehicle.isTank && mouseDown && now - (vehicle.lastPlayerShot || 0) > 1500) {
                        vehicle.lastPlayerShot = now;
                        const shootDir = new THREE.Vector3(0, 0, -1);
                        shootDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), vehicle.rotation);
                        const start = vehicle.position.clone();
                        start.y += 2.5;
                        start.x -= Math.sin(vehicle.rotation) * 3;
                        start.z -= Math.cos(vehicle.rotation) * 3;
                        createPlayerTankShell(start, shootDir);
                    }
                    
                    // Run over enemies!
                    for (let eIdx = enemies.length - 1; eIdx >= 0; eIdx--) {
                        const enemy = enemies[eIdx];
                        const dist = vehicle.position.distanceTo(enemy.position);
                        if (dist < 3) {
                            enemy.health -= 150; // Instant kill for most enemies
                            if (enemy.health <= 0) {
                                const died = handleEnemyDeath(enemy, eIdx, 'vehicle');
                                if (died) sessionStats.vehicleKills++;
                            }
                        }
                    }
                    
                    // Track vehicle time
                    sessionStats.vehicleTime += delta / 1000;
                    
                    // Exit vehicle with E
                    if (keys['e'] && !vehicle.exitCooldown) {
                        gameState.vehicle = null;
                        player.mesh.visible = true;
                        player.mesh.scale.set(1, 1, 1); // Reset bird size
                        player.position.x = vehicle.position.x + 3;
                        player.position.z = vehicle.position.z;
                        player.position.y = getTerrainHeight(player.position.x, player.position.z) + 1;
                        player.mesh.position.copy(player.position);
                        vehicle.exitCooldown = true;
                        setTimeout(() => vehicle.exitCooldown = false, 500);
                    }
                } else if (vehicle.hasDriver) {
                    // AI drives toward player
                    const toPlayer = player.position.clone().sub(vehicle.position);
                    const dist = toPlayer.length();
                    
                    if (dist > 10) {
                        const targetAngle = Math.atan2(-toPlayer.x, -toPlayer.z);
                        let angleDiff = targetAngle - vehicle.rotation;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        vehicle.rotation += Math.sign(angleDiff) * Math.min(0.02, Math.abs(angleDiff));
                        
                        vehicle.velocity.x -= Math.sin(vehicle.rotation) * 0.08;
                        vehicle.velocity.z -= Math.cos(vehicle.rotation) * 0.08;
                    }
                    
                    vehicle.position.add(vehicle.velocity);
                    vehicle.velocity.multiplyScalar(0.95);
                    
                    const terrainY = getTerrainHeight(vehicle.position.x, vehicle.position.z);
                    vehicle.position.y = terrainY;
                    
                    vehicle.mesh.position.copy(vehicle.position);
                    vehicle.mesh.rotation.y = vehicle.rotation;
                    
                    // Driver shoots
                    if (dist < 35 && now - vehicle.driver.lastShootTime > vehicle.driver.shootCooldown) {
                        vehicle.driver.lastShootTime = now;
                        const shootDir = toPlayer.normalize();
                        const start = vehicle.position.clone();
                        start.y += 3;
                        
                        if (vehicle.isTank) {
                            // Tank fires explosive shell
                            createTankShell(start, shootDir, vehicle);
                        } else {
                            createEnemyProjectile(start, shootDir);
                        }
                    }
                } else {
                    // Empty vehicle - player can enter with E
                    const dist = player.position.distanceTo(vehicle.position);
                    if (dist < 4 && keys['e'] && !gameState.vehicle && !vehicle.enterCooldown) {
                        gameState.vehicle = vehicle;
                        vehicle.enterCooldown = true;
                        setTimeout(() => vehicle.enterCooldown = false, 500);
                    }
                }
            });
        }

        function updateAlligators(delta) {
            if (gameState.isPaused || gameState.isGameOver) return;
            
            const now = Date.now();
            
            alligators.forEach(gator => {
                // Patrol around home position
                const toHome = gator.homePosition.clone().sub(new THREE.Vector3(gator.position.x, 0, gator.position.z));
                const homeDistance = toHome.length();
                
                // Wander if too far from home
                if (homeDistance > gator.patrolRadius) {
                    toHome.normalize().multiplyScalar(0.03);
                    gator.position.x += toHome.x;
                    gator.position.z += toHome.z;
                } else {
                    // Slow patrol
                    gator.angle += 0.01;
                    gator.position.x = gator.homePosition.x + Math.cos(gator.angle) * 2;
                    gator.position.z = gator.homePosition.z + Math.sin(gator.angle) * 2;
                }
                
                // Keep on terrain
                const terrainY = getTerrainHeight(gator.position.x, gator.position.z);
                gator.position.y = terrainY;
                
                // Update mesh
                gator.mesh.position.copy(gator.position);
                gator.mesh.rotation.y = gator.angle;
                
                // Check if player is close enough to bite
                const toPlayer = player.position.clone().sub(gator.position);
                const distToPlayer = toPlayer.length();
                
                if (distToPlayer < 2.5 && now - gator.lastBiteTime > gator.biteCooldown && !player.isInvulnerable) {
                    gator.lastBiteTime = now;
                    handlePlayerDamage(1);
                    
                    // Blood splash when bitten
                    for (let i = 0; i < 10; i++) {
                        createBloodParticle(player.position.clone(), Math.random() < 0.5 ? 'large' : 'normal');
                    }
                }
            });
        }

        function updateProjectiles(delta) {
            const now = Date.now();

            /*if (proj.fromPlayer) {
            enemies.forEach((enemy, idx) => {
            const dist = proj.mesh.position.distanceTo(enemy.position);
            const alreadyHit = proj.hitEnemies && proj.hitEnemies.includes(enemy);


            // Adjustable hit radius by weapon type
            let hitRadius = 1.7;
            if (gameState.currentWeapon === 'rifle') hitRadius = 2.2;
            if (gameState.currentWeapon === 'machineGun') hitRadius = 1.5;


            if (dist < hitRadius && !alreadyHit) {
            enemy.health -= proj.damage;
            
            // Quackula lifesteal
            const charConfig = characterConfig[gameSettings.character];
            if (charConfig.lifesteal && proj.fromPlayer) {
                const healAmount = Math.floor(proj.damage * charConfig.lifesteal);
                if (healAmount > 0 && gameState.lives < 3) {
                    gameState.lives = Math.min(3, gameState.lives + healAmount / 50);
                }
            }
            
            // Blood drain ability bonus lifesteal
            if (player.bloodDrainActive && proj.fromPlayer) {
                gameState.lives = Math.min(3, gameState.lives + proj.damage / 100);
            }


            if (proj.canPierce) {
            proj.hitEnemies.push(enemy);
            }
            
            // Chain lightning - jump to nearby enemy
            if (proj.isChain && proj.chainCount > 0) {
                let nearestEnemy = null;
                let nearestDist = 10;
                enemies.forEach(e => {
                    if (e !== enemy && !proj.hitEnemies.includes(e)) {
                        const d = enemy.position.distanceTo(e.position);
                        if (d < nearestDist) {
                            nearestDist = d;
                            nearestEnemy = e;
                        }
                    }
                });
                
                if (nearestEnemy) {
                    // Create chain bolt to next enemy
                    const chainDir = nearestEnemy.position.clone().sub(proj.mesh.position).normalize();
                    proj.velocity = chainDir.multiplyScalar(2.0);
                    proj.chainCount--;
                    proj.hitEnemies.push(enemy);
                    proj.lifetime = 30;
                }
            }


            if (enemy.health <= 0) {
            for (let i = 0; i < 15; i++) {
            createBloodParticle(enemy.position.clone());
            }
            scene.remove(enemy.mesh);
            enemies.splice(idx, 1);
            gameState.kills++;
            trackKill(proj.weaponType || 'projectile');
            createSpecialOrb(enemy.position.clone());
            updateUI();
            }


            if (!proj.canPierce) {
            proj.lifetime = 0;
            }
            }
            });
            }*/
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                if (proj.isArc) {
                    proj.velocity.y -= 0.015;
                }
                
                // Boomerang behavior
                if (proj.isBoomerang) {
                    proj.travelDistance += proj.velocity.length();
                    proj.mesh.rotation.y += 0.3; // Spin
                    
                    if (!proj.returning && proj.travelDistance > proj.maxDistance) {
                        proj.returning = true;
                    }
                    
                    if (proj.returning) {
                        // Return to player
                        const toPlayer = player.position.clone().sub(proj.mesh.position).normalize();
                        proj.velocity.lerp(toPlayer.multiplyScalar(0.8), 0.2); // Faster return
                        
                        // Check if reached player
                        if (proj.mesh.position.distanceTo(player.position) < 2) {
                            proj.lifetime = 0;
                        }
                    }

                    // Boomerang multi-hit: reset hitEnemies list every 0.5 seconds to allow hitting the same enemy on return
                    if (!proj.lastHitReset || now - proj.lastHitReset > 500) {
                        proj.hitEnemies = [];
                        proj.lastHitReset = now;
                    }
                }
                
                // Flame particles
                if (proj.isFlame) {
                    proj.mesh.scale.multiplyScalar(0.95); // Shrink over time
                }
                
                // Homing behavior for Tesla bolts
                if (proj.isHoming && proj.fromPlayer) {
                    let nearestEnemy = null;
                    let nearestDist = 20;
                    enemies.forEach(e => {
                        const d = proj.mesh.position.distanceTo(e.position);
                        if (d < nearestDist) {
                            nearestDist = d;
                            nearestEnemy = e;
                        }
                    });
                    
                    if (nearestEnemy) {
                        const toEnemy = nearestEnemy.position.clone().sub(proj.mesh.position).normalize();
                        proj.velocity.lerp(toEnemy.multiplyScalar(0.6), 0.1);
                        proj.mesh.lookAt(nearestEnemy.position);
                        proj.mesh.rotation.x = Math.PI / 2;
                    }
                }
                
                proj.mesh.position.add(proj.velocity);

                // Terrain collision for explosive arc projectiles
                if (proj.isExplosive && proj.isArc) {
                    const terrainY = getTerrainHeight(proj.mesh.position.x, proj.mesh.position.z);
                    if (proj.mesh.position.y <= terrainY + 0.5) {
                        createExplosion(proj.mesh.position.clone(), proj.explosionRadius, proj.damage);
                        proj.lifetime = 0;
                    }
                }

                proj.lifetime--;
                
                // Keep on terrain for arc projectiles
                const terrainY = getTerrainHeight(proj.mesh.position.x, proj.mesh.position.z);
                
                // Check obstacle collisions (trees and hut)
                let hitObstacle = false;
                for (const obstacle of obstacles) {
                    const dist = new THREE.Vector2(
                        proj.mesh.position.x - obstacle.position.x,
                        proj.mesh.position.z - obstacle.position.z
                    ).length();
                    if (dist < obstacle.radius) {
                        hitObstacle = true;
                        break;
                    }
                }
                
                if (hitObstacle) {
                    proj.lifetime = 0;
                }
                
                // Check collisions
                if (proj.fromPlayer) {
                    // Larger hit radius for better accuracy
                    let hitRadius = 2.0;
                    if (proj.weaponType === 'rifle') hitRadius = 2.5;
                    if (proj.weaponType === 'machineGun') hitRadius = 1.8;
                    if (proj.weaponType === 'cannon') hitRadius = 3.0;
                    if (proj.weaponType === 'catapult') hitRadius = 2.5;
                    
                    for (let eIdx = enemies.length - 1; eIdx >= 0; eIdx--) {
                        const enemy = enemies[eIdx];
                        const dist = proj.mesh.position.distanceTo(enemy.position);
                        const alreadyHit = proj.hitEnemies && proj.hitEnemies.includes(enemy);
                        
                        if (dist < hitRadius && !alreadyHit) {
                            enemy.health -= proj.damage;
                            
                            if (proj.canPierce) {
                                proj.hitEnemies.push(enemy);
                            }
                            
                            if (enemy.health <= 0) {
                                handleEnemyDeath(enemy, eIdx, proj.weaponType || gameState.currentWeapon);
                            }
                            
                            if (!proj.canPierce) {
                                proj.lifetime = 0;
                            }
                        }
                    }
                    
                    // Hit vehicle drivers
                    vehicles.forEach((vehicle, vIdx) => {
                        if (vehicle.hasDriver) {
                            const driverPos = vehicle.position.clone();
                            driverPos.y += 2.5;
                            const dist = proj.mesh.position.distanceTo(driverPos);
                            const alreadyHit = proj.hitVehicles && proj.hitVehicles.includes(vehicle);
                            
                            if (dist < hitRadius && !alreadyHit) {
                                vehicle.driver.health -= proj.damage;
                                
                                if (proj.canPierce) {
                                    if (!proj.hitVehicles) proj.hitVehicles = [];
                                    proj.hitVehicles.push(vehicle);
                                }
                                
                                if (vehicle.driver.health <= 0) {
                                    for (let i = 0; i < 20; i++) {
                                        createBloodParticle(driverPos, Math.random() < 0.3 ? 'large' : 'normal');
                                    }
                                    vehicle.mesh.remove(vehicle.driver.mesh);
                                    vehicle.hasDriver = false;
                                    gameState.kills++;
                                    trackKill(proj.weaponType || gameState.currentWeapon);
                                    updateUI();
                                }
                                
                                if (!proj.canPierce) {
                                    proj.lifetime = 0;
                                }
                            }
                        }
                    });
                } else {
                    // Enemy projectile hitting player
                    const distToPlayer = proj.mesh.position.distanceTo(player.position);
                    const terrainAtProj = getTerrainHeight(proj.mesh.position.x, proj.mesh.position.z);
                    
                    // Explosive projectiles from catapult hunters
                    if (proj.isExplosive && proj.mesh.position.y <= terrainAtProj + 0.5) {
                        const blastRadius = proj.explosionRadius || 4;
                        
                        // Create explosion effect
                        for (let j = 0; j < 12; j++) {
                            const particle = new THREE.Mesh(
                                new THREE.SphereGeometry(0.25, 6, 6),
                                new THREE.MeshLambertMaterial({ color: 0x8B0000 })
                            );
                            particle.position.copy(proj.mesh.position);
                            scene.add(particle);
                            const vel = new THREE.Vector3(
                                (Math.random() - 0.5) * 0.4,
                                Math.random() * 0.3,
                                (Math.random() - 0.5) * 0.4
                            );
                            bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 25 });
                        }
                        
                        // Check if player is in blast radius (Phoenix Fowl is immune to explosions)
                        const charConfig = characterConfig[gameSettings.character];
                        if (distToPlayer < blastRadius && !player.isInvulnerable && !charConfig.explosionImmune) {
                            const damageAmount = Math.ceil(proj.damage * (1 - distToPlayer / blastRadius));
                            handlePlayerDamage(damageAmount);
                            
                            for (let i = 0; i < 8; i++) {
                                createBloodParticle(player.position.clone());
                            }
                        }
                        proj.lifetime = 0;
                    } else if (distToPlayer < 1.2 && !player.isInvulnerable) {
                        handlePlayerDamage(proj.damage);
                        proj.lifetime = 0;
                        
                        // Blood effect on player
                        for (let i = 0; i < 5; i++) {
                            createBloodParticle(player.position.clone());
                        }
                    }
                }
                
                // Catapult ground blast radius
                if (proj.weaponType === 'catapult' && proj.mesh.position.y <= terrainY + 0.5) {
                    const blastRadius = 6;
                    // Create explosion effect
                    for (let j = 0; j < 15; j++) {
                        const particle = new THREE.Mesh(
                            new THREE.SphereGeometry(0.3, 6, 6),
                            new THREE.MeshLambertMaterial({ color: 0xFF6600 })
                        );
                        particle.position.copy(proj.mesh.position);
                        scene.add(particle);
                        const vel = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.5,
                            Math.random() * 0.4,
                            (Math.random() - 0.5) * 0.5
                        );
                        bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 30 });
                    }
                    
                    // Damage all enemies in blast radius
                    for (let eIdx = enemies.length - 1; eIdx >= 0; eIdx--) {
                        const enemy = enemies[eIdx];
                        const dist = proj.mesh.position.distanceTo(enemy.position);
                        if (dist < blastRadius) {
                            const damage = proj.damage * (1 - dist / blastRadius);
                            enemy.health -= damage;
                            if (enemy.health <= 0) {
                                handleEnemyDeath(enemy, eIdx, 'catapult');
                            }
                        }
                    }
                    proj.lifetime = 0;
                }
                
                if (proj.lifetime <= 0 || proj.mesh.position.y < terrainY) {
                    scene.remove(proj.mesh);
                    projectiles.splice(i, 1);
                }
            }
        }

        function updateBloodParticles(delta) {
            for (let i = bloodParticles.length - 1; i >= 0; i--) {
                const particle = bloodParticles[i];
                
                particle.velocity.y -= 0.02;
                particle.mesh.position.add(particle.velocity);
                particle.lifetime--;
                
                const terrainY = getTerrainHeight(particle.mesh.position.x, particle.mesh.position.z);
                if (particle.mesh.position.y <= terrainY) {
                    particle.mesh.position.y = terrainY + 0.05;
                    particle.velocity.multiplyScalar(0.3);
                    particle.mesh.scale.multiplyScalar(0.95);
                }
                
                if (particle.lifetime <= 0 || particle.mesh.scale.x < 0.1) {
                    scene.remove(particle.mesh);
                    bloodParticles.splice(i, 1);
                }
            }
        }

        function updateWindStreaks(delta) {
            for (let i = windStreaks.length - 1; i >= 0; i--) {
                const streak = windStreaks[i];
                
                // Move forward and fade out
                streak.mesh.position.add(streak.velocity);
                streak.lifetime--;
                
                // Fade out opacity and scale
                const fadeProgress = streak.lifetime / 12;
                streak.mesh.material.opacity = streak.initialOpacity * fadeProgress;
                streak.mesh.scale.multiplyScalar(0.92);
                
                if (streak.lifetime <= 0) {
                    scene.remove(streak.mesh);
                    windStreaks.splice(i, 1);
                }
            }
        }

        function updatePickups(delta) {
            const now = Date.now();
            for (let idx = pickups.length - 1; idx >= 0; idx--) {
                const pickup = pickups[idx];
                pickup.rotation += 0.02;
                pickup.mesh.rotation.y = pickup.rotation;
                pickup.mesh.position.y += Math.sin(pickup.rotation * 2) * 0.01;
                
                // Despawn after time limit
                if (pickup.spawnTime && now - pickup.spawnTime > pickup.despawnTime) {
                    scene.remove(pickup.mesh);
                    pickups.splice(idx, 1);
                    continue;
                }
                
                // Fade effect when close to despawn (last 5 seconds)
                if (pickup.spawnTime && pickup.despawnTime) {
                    const timeLeft = pickup.despawnTime - (now - pickup.spawnTime);
                    if (timeLeft < 5000) {
                        pickup.mesh.material.opacity = timeLeft / 5000;
                        pickup.mesh.material.transparent = true;
                    }
                }
                
                const dist = player.position.distanceTo(pickup.mesh.position);
                if (dist < 1.5) {
                    gameState.currentWeapon = pickup.weaponType;
                    updatePlayerWeapon();
                    updateUI();
                    scene.remove(pickup.mesh);
                    pickups.splice(idx, 1);
                }
            }
        }

        function updateUI() {
            document.getElementById('kills').textContent = gameState.kills;
            document.getElementById('lives').textContent = gameState.lives + (player.shields > 0 ? ` (+${player.shields} shield)` : '');
            document.getElementById('time').textContent = Math.floor(gameState.gameTime);
            document.getElementById('current-weapon').textContent = 
                gameState.currentWeapon.charAt(0).toUpperCase() + gameState.currentWeapon.slice(1);
            document.getElementById('coins-count').textContent = gameState.coins;
        }
        
        function awardCoins(amount) {
            const config = characterConfig[gameSettings.character];
            const multiplier = config.coinMultiplier || 1;
            const finalAmount = Math.floor(amount * multiplier);
            gameState.coins += finalAmount;
            localStorage.setItem('duckDefenseCoins', gameState.coins);
            updateUI();
        }
        
        function openShop() {
            gameState.isPaused = true;
            document.getElementById('shop-page').style.display = 'flex';
            renderShopItems();
        }
        
        function closeShop() {
            document.getElementById('shop-page').style.display = 'none';
            if (gameState.playing) {
                gameState.isPaused = false;
            }
        }
        
        function renderShopItems() {
            document.getElementById('shop-coins').textContent = gameState.coins;
            
            // Render lives
            const livesContainer = document.getElementById('shop-lives');
            livesContainer.innerHTML = '';
            shopItems.lives.forEach(item => {
                const div = createShopItemElement(item);
                livesContainer.appendChild(div);
            });
            
            // Render birds
            const birdsContainer = document.getElementById('shop-birds');
            birdsContainer.innerHTML = '';
            shopItems.birds.forEach(item => {
                const owned = unlockedCharacters.includes(item.unlockId);
                const div = createShopItemElement(item, owned);
                birdsContainer.appendChild(div);
            });
            
            // Render weapons
            const weaponsContainer = document.getElementById('shop-weapons');
            weaponsContainer.innerHTML = '';
            shopItems.weapons.forEach(item => {
                const owned = sessionWeapons.includes(item.weaponId);
                const div = createShopItemElement(item, owned);
                weaponsContainer.appendChild(div);
            });
            
            // Render extras
            const extrasContainer = document.getElementById('shop-extras');
            extrasContainer.innerHTML = '';
            shopItems.extras.forEach(item => {
                const owned = (item.id === 'sideChick' && sideChick !== null);
                const div = createShopItemElement(item, owned);
                extrasContainer.appendChild(div);
            });
            
            // Render stat buffs
            const statsContainer = document.getElementById('shop-stats');
            if (statsContainer) {
                statsContainer.innerHTML = '';
                shopItems.statBuffs.forEach(item => {
                    const div = createShopItemElement(item, false);
                    statsContainer.appendChild(div);
                });
            }
        }
        
        function createShopItemElement(item, owned = false) {
            const div = document.createElement('div');
            div.className = 'shop-item' + (owned ? ' purchased' : '');
            
            const affordable = gameState.coins >= item.price;
            
            div.innerHTML = `
                <div class="shop-item-name">${item.name}</div>
                <div class="shop-item-desc">${item.description}</div>
                <div class="shop-item-price ${affordable && !owned ? 'affordable' : ''}">${owned ? 'OWNED' : item.price + ' coins'}</div>
            `;
            
            if (!owned) {
                div.onclick = () => purchaseItem(item);
            }
            
            return div;
        }
        
        function purchaseItem(item) {
            if (gameState.coins < item.price) {
                alert('Not enough coins!');
                return;
            }
            
            gameState.coins -= item.price;
            localStorage.setItem('duckDefenseCoins', gameState.coins);
            
            switch (item.type) {
                case 'consumable':
                    if (item.id === 'extraLife') {
                        gameState.lives++;
                    } else if (item.id === 'fullHeal') {
                        gameState.lives = 3;
                    }
                    
                    // If game was over, continue!
                    if (gameState.isGameOver && gameState.lives > 0) {
                        gameState.isGameOver = false;
                        gameState.isPaused = false;
                        document.getElementById('game-over').style.display = 'none';
                        
                        // Resume game sounds or animations if needed
                        // Since the game loop (animate) check is !gameState.isGameOver, it should resume automatically
                        
                        // Record that we continued
                        if (!sessionStats.continues) sessionStats.continues = 0;
                        sessionStats.continues++;
                    }
                    
                    updateUI();
                    break;
                    
                case 'character':
                    if (!unlockedCharacters.includes(item.unlockId)) {
                        unlockedCharacters.push(item.unlockId);
                        localStorage.setItem('duckDefenseUnlocks', JSON.stringify(unlockedCharacters));
                        updateCharacterButtons();
                    }
                    break;
                    
                case 'weapon':
                    if (!sessionWeapons.includes(item.weaponId)) {
                        sessionWeapons.push(item.weaponId);
                        gameState.currentWeapon = item.weaponId;
                        updatePlayerWeapon();
                        
                        // Save permanent unlock
                        if (!allTimeStats.unlockedWeapons.includes(item.weaponId)) {
                            allTimeStats.unlockedWeapons.push(item.weaponId);
                            saveAllStats();
                        }
                    }
                    break;
                    
                case 'shield':
                    if (player.shields < 3) {
                        player.shields++;
                    }
                    updateUI();
                    break;
                    
                case 'companion':
                    if (item.id === 'sideChick') {
                        if (item.permanent) {
                            permanentUpgrades.sideChick = true;
                            savePermanentUpgrades();
                            updateUpgradeToggles();
                        }
                        if (!sideChick) spawnSideChick();
                    }
                    break;
                    
                case 'statBuff':
                    playerStats[item.stat] += item.amount;
                    savePlayerStats();
                    updateStatsDisplay();
                    break;
            }
            
            renderShopItems();
            updateUI();
        }
        
        function updateUpgradeToggles() {
            const container = document.getElementById('upgrade-toggles');
            if (!container) return;
            container.innerHTML = '';
            
            if (permanentUpgrades.sideChick) {
                const btn = document.createElement('button');
                btn.className = 'menu-btn secondary';
                btn.style.padding = '10px 20px';
                btn.style.fontSize = '14px';
                btn.style.background = upgradeSettings.sideChick ? 'rgba(76, 175, 80, 0.4)' : 'rgba(255, 255, 255, 0.05)';
                btn.textContent = 'Side Chick: ' + (upgradeSettings.sideChick ? 'ON' : 'OFF');
                btn.onclick = () => {
                    upgradeSettings.sideChick = !upgradeSettings.sideChick;
                    savePermanentUpgrades();
                    updateUpgradeToggles();
                };
                container.appendChild(btn);
            } else {
                container.innerHTML = '<span style="color: #666; font-size: 14px;">No permanent upgrades owned yet. Visit the shop!</span>';
            }
        }
        
        function handlePlayerDamage(damage) {
            if (player.isInvulnerable) return;
            
            // Shield blocks damage
            if (player.shields > 0) {
                player.shields--;
                updateUI();
                // Shield break visual effect
                for (let i = 0; i < 8; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 6, 6),
                        new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.8 })
                    );
                    particle.position.copy(player.position);
                    scene.add(particle);
                    const vel = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        Math.random() * 0.2,
                        (Math.random() - 0.5) * 0.3
                    );
                    bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 20 });
                }
                return;
            }
            
            gameState.lives -= damage;
            updateUI();
            
            // Eggy Surprise visual cracking
            if (gameSettings.character === 'eggySurprise') {
                updateEggCracks();
            }
            
            if (gameState.lives <= 0) {
                // Special handling for Eggy Surprise - eggsplosion and transform!
                if (gameSettings.character === 'eggySurprise') {
                    executeEggsplosion();
                } else {
                    gameOver();
                }
            }
        }
        
        function updateEggCracks() {
            if (!player.mesh.userData.cracks) return;
            
            const livesLost = 3 - gameState.lives;
            player.mesh.userData.crackLevel = livesLost;
            
            // Show cracks based on damage
            if (livesLost >= 1 && !player.mesh.userData.cracks.visible) {
                player.mesh.userData.cracks.visible = true;
                // Add crack lines
                const crackMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
                for (let i = 0; i < 3 + livesLost * 2; i++) {
                    const crack = new THREE.Mesh(
                        new THREE.BoxGeometry(0.02, 0.3 + Math.random() * 0.2, 0.02),
                        crackMat
                    );
                    const angle = Math.random() * Math.PI * 2;
                    crack.position.set(
                        Math.cos(angle) * 0.6,
                        -0.2 + Math.random() * 0.4,
                        Math.sin(angle) * 0.6
                    );
                    crack.rotation.z = (Math.random() - 0.5) * 0.5;
                    player.mesh.userData.cracks.add(crack);
                }
            }
            
            // Show yolk drip at 2+ lives lost
            if (livesLost >= 2 && player.mesh.userData.yolkDrip) {
                player.mesh.userData.yolkDrip.visible = true;
            }
        }
        
        function executeEggsplosion() {
            // Massive explosion
            const explosionRadius = 15;
            const damage = 150;
            
            // Explosion visual - yolk and shell fragments
            for (let i = 0; i < 50; i++) {
                const isYolk = Math.random() < 0.4;
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(isYolk ? 0.3 : 0.15),
                    new THREE.MeshLambertMaterial({ color: isYolk ? 0xFFD700 : 0xFFFACD })
                );
                particle.position.copy(player.position);
                scene.add(particle);
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.8,
                    0.3 + Math.random() * 0.5,
                    (Math.random() - 0.5) * 0.8
                );
                bloodParticles.push({ mesh: particle, velocity: vel, lifetime: 60 });
            }
            
            // Damage all enemies in radius
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dist = player.position.distanceTo(enemy.position);
                if (dist < explosionRadius) {
                    const damageDealt = damage * (1 - dist / explosionRadius);
                    enemy.health -= damageDealt;
                    if (enemy.health <= 0) {
                        handleEnemyDeath(enemy, i, 'eggsplosion');
                    }
                }
            }
            
            // Transform into random other bird!
            const availableChars = ['duck', 'titanTurkey', 'kungPowChicken', 'mericaMallard', 'chick7', 'loonatic'];
            const newChar = availableChars[Math.floor(Math.random() * availableChars.length)];
            gameSettings.character = newChar;
            
            // Reset player with new character
            scene.remove(player.mesh);
            player.mesh = createCharacter(newChar);
            player.mesh.position.copy(player.position);
            scene.add(player.mesh);
            
            // Full health on transform
            gameState.lives = 3;
            updateUI();
            
            // Hatch effect
            for (let i = 0; i < 20; i++) {
                const sparkle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1),
                    new THREE.MeshBasicMaterial({ color: 0xFFFF00 })
                );
                sparkle.position.copy(player.position);
                sparkle.position.x += (Math.random() - 0.5) * 2;
                sparkle.position.y += Math.random() * 2;
                sparkle.position.z += (Math.random() - 0.5) * 2;
                scene.add(sparkle);
                const vel = new THREE.Vector3((Math.random() - 0.5) * 0.2, 0.2, (Math.random() - 0.5) * 0.2);
                bloodParticles.push({ mesh: sparkle, velocity: vel, lifetime: 30 });
            }
            
            // Show transform message
            console.log('Eggy transformed into ' + characterConfig[newChar].name + '!');
        }

        function gameOver() {
            gameState.isGameOver = true;
            const finalScore = gameState.kills * 100 + Math.floor(gameState.gameTime);
            document.getElementById('final-score').textContent = finalScore;
            document.getElementById('game-over').style.display = 'block';
            
            // Record stats
            sessionStats.timeAlive = Math.floor(gameState.gameTime);
            recordGameEnd(finalScore, sessionStats.timeAlive);
        }

        function resetGame() {
            gameState.kills = 0;
            gameState.lives = 3;
            gameState.currentWeapon = 'pistol';
            gameState.isGameOver = false;
            gameState.isPaused = false;
            gameState.enemySpawnRate = 3000;
            gameState.lastSpawnTime = Date.now();
            gameState.gameStartTime = Date.now();
            gameState.gameTime = 0;
            
            player.position.set(8, getTerrainHeight(8, 0) + 1, 0); // Start outside hut
            player.velocity.set(0, 0, 0);
            player.lookAngle = 0;
            
            // Reset ability state
            player.abilityActive = false;
            player.abilityEndTime = 0;
            player.abilityCooldownEnd = 0;
            player.comboCount = 0;
            player.specialCharges = 0;
            player.specialActive = false;
            player.specialEndTime = 0;
            player.isInvisible = false;
            player.isInvulnerable = false;
            player.berserkerRage = false;
            player.wing67Time = 0;
            player.isGliding = false;
            player.maxJumps = characterConfig[gameSettings.character].maxJumps || 2;
            player.shields = 0;
            
            // Remove Side Chick if exists
            if (sideChick) {
                scene.remove(sideChick.mesh);
                sideChick = null;
            }
            
            // Remove Doppelganger if exists
            if (doppelganger) {
                scene.remove(doppelganger.mesh);
                doppelganger = null;
            }
            
            // Clear special orbs
            specialOrbs.forEach(orb => scene.remove(orb.mesh));
            specialOrbs.length = 0;
            
            // Recreate character mesh with selected character
            scene.remove(player.mesh);
            player.mesh = createCharacter(gameSettings.character);
            player.mesh.position.copy(player.position);
            scene.add(player.mesh);
            
            updatePlayerWeapon();
            
            enemies.forEach(e => scene.remove(e.mesh));
            enemies.length = 0;
            
            alligators.forEach(g => scene.remove(g.mesh));
            alligators.length = 0;
            
            vehicles.forEach(v => scene.remove(v.mesh));
            vehicles.length = 0;
            gameState.vehicle = null;
            lastTruckSpawnTime = Date.now();
            lastTankSpawnTime = Date.now();
            player.mesh.visible = true;
            
            // Clear grenades
            grenades.forEach(g => scene.remove(g.mesh));
            grenades.length = 0;
            lastGrenadeTime = 0;
            
            // Respawn alligators
            for (let i = 0; i < 8; i++) {
                const waterZone = waterZones[Math.floor(Math.random() * waterZones.length)];
                const angle = Math.random() * Math.PI * 2;
                const dist = waterZone.radius + 1;
                const x = waterZone.position.x + Math.cos(angle) * dist;
                const z = waterZone.position.z + Math.sin(angle) * dist;
                
                const gator = {
                    mesh: createAlligator(),
                    position: new THREE.Vector3(x, getTerrainHeight(x, z), z),
                    angle: angle,
                    homePosition: new THREE.Vector3(x, 0, z),
                    patrolRadius: 5,
                    lastBiteTime: 0,
                    biteCooldown: 2000
                };
                
                gator.mesh.position.copy(gator.position);
                gator.mesh.rotation.y = angle;
                scene.add(gator.mesh);
                alligators.push(gator);
            }
            
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles.length = 0;
            
            bloodParticles.forEach(p => scene.remove(p.mesh));
            bloodParticles.length = 0;
            
            windStreaks.forEach(w => scene.remove(w.mesh));
            windStreaks.length = 0;
            
            document.getElementById('game-over').style.display = 'none';
            updateUI();
        }

        // ==================== EVENT LISTENERS ====================
        // Joystick logic
        const joystickState = { active: false, x: 0, y: 0 };
        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');
        
        function updateJoystick(touch) {
            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const maxDist = rect.width / 2 - 25;
            
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dy = (dy / dist) * maxDist;
            }
            
            joystickThumb.style.left = `calc(50% + ${dx}px)`;
            joystickThumb.style.top = `calc(50% + ${dy}px)`;
            
            joystickState.x = dx / maxDist;
            joystickState.y = dy / maxDist;
        }
        
        function resetJoystick() {
            joystickState.active = false;
            joystickState.x = 0;
            joystickState.y = 0;
            joystickThumb.style.left = '50%';
            joystickThumb.style.top = '50%';
        }
        
        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickState.active = true;
            updateJoystick(e.touches[0]);
        });
        
        joystickContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (joystickState.active) {
                updateJoystick(e.touches[0]);
            }
        });
        
        joystickContainer.addEventListener('touchend', (e) => {
            e.preventDefault();
            resetJoystick();
        });
        
        joystickContainer.addEventListener('touchcancel', (e) => {
            resetJoystick();
        });

        // Mobile button logic
        document.getElementById('mobile-jump').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.isPaused && !gameState.isGameOver && player.jumpsUsed < player.maxJumps) {
                player.velocity.y = 0.2;
                player.jumpsUsed++;
                player.isJumping = true;
                player.wingFlapTime = 10;
            }
        });

        document.getElementById('mobile-attack').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.isPaused && !gameState.isGameOver) {
                const weapon = weapons[gameState.currentWeapon];
                if (weapon.type === 'melee') {
                    meleeAttack();
                } else {
                    shootProjectile();
                }
            }
        });
        
        document.getElementById('mobile-ability').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.isPaused && !gameState.isGameOver) {
                activateAbility();
            }
        });

        document.getElementById('mobile-special').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.isPaused && !gameState.isGameOver) {
                activateSpecial();
            }
        });

        // ==================== MENU NAVIGATION ====================
        function showMenu() {
            gameState.playing = false;
            updateUpgradeToggles();
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('settings-page').style.display = 'none';
            document.getElementById('stats-page').style.display = 'none';
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('quit-btn').style.display = 'none';
            document.getElementById('shop-btn').style.display = 'none';
            document.getElementById('coins-display').style.display = 'none';
            document.getElementById('shop-page').style.display = 'none';
            document.getElementById('ability-bar').style.display = 'none';
            document.getElementById('ability-prompt').style.display = 'none';
            document.getElementById('special-btn').style.display = 'none';
        }
        
        function hideAllMenus() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('settings-page').style.display = 'none';
            document.getElementById('stats-page').style.display = 'none';
        }
        
        function startGame() {
            hideAllMenus();
            resetSessionStats();
            gameState.playing = true;
            document.getElementById('quit-btn').style.display = 'block';
            document.getElementById('shop-btn').style.display = 'block';
            document.getElementById('coins-display').style.display = 'block';
            
            // Apply permanent weapon unlocks
            sessionWeapons = [...allTimeStats.unlockedWeapons];
            
            // Apply difficulty settings
            const diff = difficultyConfig[gameSettings.difficulty];
            gameState.enemySpawnRate = diff.spawnRate;
            
            // Apply input method
            if (gameSettings.inputMethod === 'mobile') {
                document.getElementById('mobile-controls').style.display = 'flex';
            } else {
                document.getElementById('mobile-controls').style.display = 'none';
            }
            
            // Start with permanent upgrades if enabled
            if (permanentUpgrades.sideChick && upgradeSettings.sideChick) {
                spawnSideChick();
            }
            
            gameState.isPaused = false;
            gameState.gameStartTime = Date.now();
            gameState.lastSpawnTime = Date.now();
            lastTruckSpawnTime = Date.now();
            updateUI();
        }
        
        // Draw score graph
        function drawScoreGraph() {
            const canvas = document.getElementById('score-graph');
            const ctx = canvas.getContext('2d');
            const games = allTimeStats.games;
            
            // Set canvas size
            canvas.width = canvas.parentElement.clientWidth - 40;
            canvas.height = 200;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (games.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No games played yet!', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const padding = 40;
            const graphWidth = canvas.width - padding * 2;
            const graphHeight = canvas.height - padding * 2;
            
            const maxScore = Math.max(...games.map(g => g.score), 100);
            
            // Draw axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            // Draw grid lines
            ctx.strokeStyle = '#333';
            for (let i = 0; i <= 4; i++) {
                const y = padding + (graphHeight / 4) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();
                
                ctx.fillStyle = '#666';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(Math.round(maxScore - (maxScore / 4) * i), padding - 5, y + 3);
            }
            
            // Draw line graph
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            games.forEach((game, i) => {
                const x = padding + (graphWidth / Math.max(games.length - 1, 1)) * i;
                const y = canvas.height - padding - (game.score / maxScore) * graphHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#66BB6A';
            games.forEach((game, i) => {
                const x = padding + (graphWidth / Math.max(games.length - 1, 1)) * i;
                const y = canvas.height - padding - (game.score / maxScore) * graphHeight;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function populateStats() {
            const grid = document.getElementById('stats-grid');
            const stats = allTimeStats;
            const games = stats.games;
            
            if (games.length === 0) {
                grid.innerHTML = '<div class="no-stats">Play some games to see your statistics!</div>';
                return;
            }
            
            const highScore = Math.max(...games.map(g => g.score));
            const avgScore = Math.round(games.reduce((sum, g) => sum + g.score, 0) / games.length);
            const totalGames = games.length;
            const totalTime = Math.floor(stats.totalTime);
            const vehicleTime = Math.floor(stats.totalVehicleTime);
            
            // Find favorite weapon
            let favoriteWeapon = 'None';
            let maxKills = 0;
            for (const [weapon, kills] of Object.entries(stats.weaponKills)) {
                if (kills > maxKills) {
                    maxKills = kills;
                    favoriteWeapon = weapon.charAt(0).toUpperCase() + weapon.slice(1);
                }
            }
            
            grid.innerHTML = `
                <div class="stat-card highlight">
                    <div class="stat-value">${highScore}</div>
                    <div class="stat-label">High Score</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${avgScore}</div>
                    <div class="stat-label">Average Score</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${stats.totalKills}</div>
                    <div class="stat-label">Total Hunters Killed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${totalGames}</div>
                    <div class="stat-label">Games Played</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${Math.floor(totalTime / 60)}m ${totalTime % 60}s</div>
                    <div class="stat-label">Total Time Played</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${Math.floor(vehicleTime / 60)}m ${vehicleTime % 60}s</div>
                    <div class="stat-label">Time in Vehicles</div>
                </div>
                <div class="stat-card highlight">
                    <div class="stat-value">${favoriteWeapon}</div>
                    <div class="stat-label">Favorite Weapon</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${Math.round(totalTime / Math.max(totalGames, 1))}s</div>
                    <div class="stat-label">Avg Survival Time</div>
                </div>
            `;
        }
        
        // Initialize settings UI
        function initSettingsUI() {
            // Set active difficulty button
            document.querySelectorAll('.diff-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.diff === gameSettings.difficulty);
            });
            
            // Set active input button
            document.querySelectorAll('.input-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.input === gameSettings.inputMethod);
            });
            
            // Set active character button
            document.querySelectorAll('.char-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.char === gameSettings.character);
            });
            
            // Update character description
            const config = characterConfig[gameSettings.character];
            document.getElementById('char-description').textContent = config ? config.description : '';
        }
        
        // Menu button handlers
        document.getElementById('play-btn').addEventListener('click', () => {
            resetGame();
            startGame();
            // Start the animation loop if it hasn't started
            if (!animationFrameId) {
                lastTime = Date.now();
                animate();
            }
        });
        
        document.getElementById('settings-menu-btn').addEventListener('click', () => {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('settings-page').style.display = 'flex';
            initSettingsUI();
        });
        
        document.getElementById('stats-btn').addEventListener('click', () => {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('stats-page').style.display = 'flex';
            populateStats();
            setTimeout(drawScoreGraph, 50);
        });
        
        document.getElementById('settings-back-btn').addEventListener('click', showMenu);
        document.getElementById('stats-back-btn').addEventListener('click', showMenu);
        
        // Difficulty buttons
        document.querySelectorAll('.diff-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameSettings.difficulty = btn.dataset.diff;
                saveSettings();
            });
        });
        
        // Input method buttons
        document.querySelectorAll('.input-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.input-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameSettings.inputMethod = btn.dataset.input;
                saveSettings();
            });
        });
        
        // Character selection buttons
        document.querySelectorAll('.char-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const charId = btn.dataset.char;
                
                // Check if character is unlocked
                if (!unlockedCharacters.includes(charId)) {
                    alert('This character is locked! Purchase it from the Shop during gameplay.');
                    return;
                }
                
                document.querySelectorAll('.char-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameSettings.character = charId;
                const config = characterConfig[gameSettings.character];
                document.getElementById('char-description').textContent = config ? config.description : '';
                saveSettings();
            });
        });
        
        // Game mode buttons
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameSettings.gameMode = btn.dataset.mode;
                saveSettings();
            });
        });
        
        // Initialize stats display
        updateStatsDisplay();
        
        // Update locked status of character buttons
        function updateCharacterButtons() {
            document.querySelectorAll('.char-btn').forEach(btn => {
                const charId = btn.dataset.char;
                if (unlockedCharacters.includes(charId)) {
                    btn.classList.remove('locked');
                    btn.textContent = characterConfig[charId].name;
                } else {
                    btn.classList.add('locked');
                    btn.textContent = characterConfig[charId].name + ' (Shop)';
                }
            });
        }
        updateCharacterButtons();

        document.getElementById('restart-btn').addEventListener('click', () => {
            resetGame();
            startGame();
        });

        document.getElementById('shop-continue-btn').addEventListener('click', () => {
            openShop();
        });

        document.getElementById('special-btn').addEventListener('click', () => {
            if (gameState.playing && player.specialCharges > 0 && !player.specialActive) {
                activateSpecial();
            }
        });

        document.getElementById('shop-btn').addEventListener('click', openShop);

        document.getElementById('quit-btn').addEventListener('click', () => {
            gameState.isPaused = true;
            
            // Reset game state without showing game over
            gameState.kills = 0;
            gameState.lives = 3;
            gameState.currentWeapon = 'pistol';
            gameState.enemySpawnRate = 3000;
            player.position.set(8, 1, 0);
            player.velocity.set(0, 0, 0);
            player.isJumping = false;
            player.jumpsUsed = 0;
            player.bloodDripCounter = 0;
            sessionWeapons = ['pistol'];
            
            // Reset player appearance
            player.mesh.userData.body.material.color.setHex(0xFFFF00);
            player.mesh.userData.head.material.color.setHex(0xFFFF00);
            player.mesh.rotation.x = 0;
            
            updatePlayerWeapon();
            
            enemies.forEach(e => scene.remove(e.mesh));
            enemies.length = 0;
            
            alligators.forEach(g => scene.remove(g.mesh));
            alligators.length = 0;
            
            vehicles.forEach(v => scene.remove(v.mesh));
            vehicles.length = 0;
            gameState.vehicle = null;
            lastTruckSpawnTime = 0;
            player.mesh.visible = true;
            
            projectiles.forEach(p => scene.remove(p.mesh));
            projectiles.length = 0;
            
            bloodParticles.forEach(p => scene.remove(p.mesh));
            bloodParticles.length = 0;
            
            windStreaks.forEach(w => scene.remove(w.mesh));
            windStreaks.length = 0;
            
            updateUI();
            showMenu();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==================== GAME LOOP ====================
        let lastTime = Date.now();
        let animationFrameId = null;

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            
            const now = Date.now();
            const delta = now - lastTime;
            lastTime = now;
            
            if (!gameState.isPaused && !gameState.isGameOver) {
                gameState.gameTime = (now - gameState.gameStartTime) / 1000;
            }
            
            updateDayNight();
            updatePlayer(delta);
            updateAbilityState(delta);
            updateEnemies(delta);
            updateAlligators(delta);
            updateVehicles(delta);
            updateProjectiles(delta);
            updateGrenades();
            updateSideChick(delta);
            updateDoppelganger(delta);
            updateBloodParticles(delta);
            updateWindStreaks(delta);
            updatePickups(delta);
            updateSpecialOrbs(delta);
            updateSpecialState(delta);
            
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>